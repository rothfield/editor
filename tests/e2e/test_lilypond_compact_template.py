"""
LilyPond Compact Template E2E Tests

Tests that the compact template (used by the converter for minimal layouts)
produces properly minimal SVG output without branding.

COMPLETE E2E PIPELINE:
1. Load editor (WASM loads)
2. Enter notation through UI
3. Trigger LilyPond export (converter uses compact template)
4. Send generated LilyPond to lilypond-service (Docker)
5. Verify actual SVG output: dimensions and no branding
"""

import pytest
import requests
import re
import xml.etree.ElementTree as ET
from typing import Tuple


def parse_svg_dimensions(svg_string: str) -> Tuple[str, str]:
    """Extract width and height from SVG root element."""
    try:
        root = ET.fromstring(svg_string)
        width = root.get('width', '')
        height = root.get('height', '')
        return (width, height)
    except ET.ParseError as e:
        raise Exception(f"Failed to parse SVG: {e}")


def has_a4_dimensions(width: str, height: str) -> bool:
    """Check if dimensions match A4 paper size (210mm × 297mm)."""
    width_match = re.match(r'([\d.]+)(mm|in|pt|px)', width)
    height_match = re.match(r'([\d.]+)(mm|in|pt|px)', height)

    if not width_match or not height_match:
        return False

    w_val, w_unit = float(width_match.group(1)), width_match.group(2)
    h_val, h_unit = float(height_match.group(1)), height_match.group(2)

    # Normalize to mm
    unit_to_mm = {'mm': 1, 'in': 25.4, 'pt': 0.352777, 'px': 0.264583}
    w_mm = w_val * unit_to_mm.get(w_unit, 1)
    h_mm = h_val * unit_to_mm.get(h_unit, 1)

    # A4 is 210mm × 297mm (allow 1mm tolerance)
    a4_w, a4_h = 210, 297
    return (
        abs(w_mm - a4_w) < 1 and abs(h_mm - a4_h) < 1
    ) or (
        abs(w_mm - a4_h) < 1 and abs(h_mm - a4_w) < 1  # Landscape
    )


def find_lilypond_branding_links(svg_string: str) -> list:
    """Find LilyPond branding links in SVG."""
    pattern = r'<g\s+transform="[^"]*">[^<]*<a\s+[^>]*xlink:href="https://lilypond\.org/"'
    return re.findall(pattern, svg_string)


def render_lilypond_to_svg(lilypond_source: str, service_url: str) -> str:
    """Send LilyPond source to lilypond-service and get SVG."""
    payload = {
        "ly": lilypond_source,
        "format": "svg"
    }

    response = requests.post(service_url, json=payload, timeout=30)

    if response.status_code != 200:
        error_msg = response.text if response.text else f"HTTP {response.status_code}"
        raise Exception(f"LilyPond rendering failed: {error_msg}")

    return response.text


@pytest.mark.asyncio
@pytest.mark.e2e
async def test_compact_template_minimal_paper_size(editor_page):
    """
    Test that compact template produces minimal paper size.

    E2E PIPELINE:
    1. Load editor (WASM loads)
    2. Type notation (single note)
    3. Export via converter (selects compact template)
    4. Send to lilypond-service
    5. Verify SVG is 200mm × 50mm, NOT A4
    """
    lilypond_service_url = "http://localhost:8787/engrave"

    # Step 1: Type notation in editor
    await editor_page.keyboard.type("1")
    await editor_page.wait_for_timeout(500)

    # Step 2-3: Export to LilyPond through WASM converter
    lilypond_source = await editor_page.evaluate("""
    () => {
        if (!window.musicEditor || !window.musicEditor.wasmModule) {
            return null;
        }

        // Export document to MusicXML
        const musicxml = window.musicEditor.wasmModule.exportMusicXML(
            window.musicEditor.theDocument
        );

        // Convert MusicXML to LilyPond
        // Converter selects compact template for minimal layouts
        const result = window.musicEditor.wasmModule.convertMusicXMLToLilyPond(
            musicxml,
            null  // No special settings
        );

        const parsed = JSON.parse(result);
        return parsed.lilypond_source || null;
    }
    """)

    assert lilypond_source is not None, (
        "Converter should produce LilyPond source - "
        "check WASM module is loaded"
    )

    print(f"\n=== LilyPond Source Generated by Converter ===")
    print(f"Length: {len(lilypond_source)} chars")

    # Verify converter used compact template
    has_compact_settings = (
        "tagline = ##f" in lilypond_source and
        "paper-width = 200\\mm" in lilypond_source and
        "paper-height = 50\\mm" in lilypond_source
    )

    if has_compact_settings:
        print("✓ Converter selected compact template")
    else:
        print("❌ Converter did NOT select compact template")
        print(f"Source: {lilypond_source[:300]}")

    # Step 4: Send to lilypond-service Docker container
    svg_output = render_lilypond_to_svg(lilypond_source, lilypond_service_url)

    # Step 5: Verify SVG dimensions
    width, height = parse_svg_dimensions(svg_output)

    print(f"\n=== SVG Output from lilypond-service ===")
    print(f"Width: {width}")
    print(f"Height: {height}")

    is_a4 = has_a4_dimensions(width, height)

    if is_a4:
        print(f"❌ FAIL: SVG has A4 dimensions")
    else:
        print(f"✓ PASS: SVG has minimal dimensions")

    assert not is_a4, (
        f"SVG should have minimal dimensions (compact template), "
        f"but got A4 size ({width} × {height}). "
        f"Expected ~200mm × ~50mm or similar compact size."
    )


@pytest.mark.asyncio
@pytest.mark.e2e
async def test_compact_template_no_branding_links(editor_page):
    """
    Test that compact template removes LilyPond branding.

    E2E PIPELINE:
    1. Load editor (WASM loads)
    2. Type notation
    3. Export via converter (compact template has tagline = ##f)
    4. Send to lilypond-service
    5. Verify SVG has NO branding links
    """
    lilypond_service_url = "http://localhost:8787/engrave"

    # Type notation
    await editor_page.keyboard.type("c d e")
    await editor_page.wait_for_timeout(500)

    # Export to LilyPond through WASM converter
    lilypond_source = await editor_page.evaluate("""
    () => {
        if (!window.musicEditor || !window.musicEditor.wasmModule) {
            return null;
        }

        const musicxml = window.musicEditor.wasmModule.exportMusicXML(
            window.musicEditor.theDocument
        );

        const result = window.musicEditor.wasmModule.convertMusicXMLToLilyPond(
            musicxml,
            null
        );

        const parsed = JSON.parse(result);
        return parsed.lilypond_source || null;
    }
    """)

    assert lilypond_source is not None, "Converter should produce LilyPond source"

    print(f"\n=== LilyPond Source ===")
    has_tagline_disabled = "tagline = ##f" in lilypond_source

    if has_tagline_disabled:
        print("✓ Converter: tagline = ##f (branding will be suppressed)")
    else:
        print("❌ Converter: tagline setting missing")

    # Send to lilypond-service
    svg_output = render_lilypond_to_svg(lilypond_source, lilypond_service_url)

    # Check for branding links in SVG
    branding_links = find_lilypond_branding_links(svg_output)
    has_lilypond_url = "https://lilypond.org/" in svg_output

    print(f"\n=== SVG Branding Check ===")

    if branding_links:
        print(f"❌ FAIL: Found {len(branding_links)} branding link(s)")
        for i, link in enumerate(branding_links, 1):
            print(f"   {i}. {link[:100]}")
    else:
        print(f"✓ PASS: No branding links in SVG")

    if has_lilypond_url:
        print(f"⚠️  WARNING: lilypond.org URL found in SVG")

    assert len(branding_links) == 0, (
        f"Compact template should suppress branding, "
        f"but found {len(branding_links)} branding link(s) in rendered SVG"
    )


@pytest.mark.asyncio
@pytest.mark.e2e
async def test_full_pipeline_integration(editor_page):
    """
    Test complete integration: WASM → Converter → lilypond-service → SVG.

    Verifies:
    1. WASM loads and converter works
    2. Compact template is used for minimal layouts
    3. SVG is produced correctly with minimal dimensions
    """
    lilypond_service_url = "http://localhost:8787/engrave"

    # Verify WASM loaded
    wasm_ready = await editor_page.evaluate("""
    () => {
        return typeof window.wasm !== 'undefined' &&
               window.wasm !== null;
    }
    """)

    assert wasm_ready, "WASM module should be loaded"
    print("✓ Step 1: WASM loaded")

    # Enter notation
    await editor_page.keyboard.type("1 2 3")
    await editor_page.wait_for_timeout(300)

    # Get converter output
    lilypond_source = await editor_page.evaluate("""
    () => {
        if (!window.musicEditor || !window.musicEditor.wasmModule) {
            return null;
        }

        const musicxml = window.musicEditor.wasmModule.exportMusicXML(
            window.musicEditor.theDocument
        );

        const result = window.musicEditor.wasmModule.convertMusicXMLToLilyPond(
            musicxml,
            null
        );

        const parsed = JSON.parse(result);
        return parsed.lilypond_source || null;
    }
    """)

    assert lilypond_source is not None, "Converter should produce output"
    assert '\\version' in lilypond_source, "Should be valid LilyPond"
    print("✓ Step 2: Converter produces LilyPond")

    # Verify compact template
    has_compact = (
        "tagline = ##f" in lilypond_source and
        "paper-width" in lilypond_source
    )
    assert has_compact, "Should use compact template"
    print("✓ Step 3: Compact template selected")

    # Render SVG
    svg_output = render_lilypond_to_svg(lilypond_source, lilypond_service_url)
    assert '<svg' in svg_output, "Should produce valid SVG"
    print("✓ Step 4: lilypond-service renders SVG")

    # Verify output
    width, height = parse_svg_dimensions(svg_output)
    is_a4 = has_a4_dimensions(width, height)
    has_branding = "https://lilypond.org/" in svg_output

    print(f"\n=== Full Pipeline Result ===")
    print(f"SVG dimensions: {width} × {height}")
    print(f"Is A4: {is_a4}")
    print(f"Has branding: {has_branding}")

    assert not is_a4, f"Should not be A4 size, got {width} × {height}"
    assert not has_branding, "Should not contain branding URLs"

    print("✓ Step 5: SVG output verified (minimal size, no branding)")
    print("✅ Full pipeline integration test PASSED")
