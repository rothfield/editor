# Font Architecture: Noto Music to Notation Pipeline

**Last Updated:** November 2025
**Status:** Live/Production
**System Design:** Single source of truth via atoms.yaml with compile-time code generation

## Overview

The notation font system follows a **pipeline architecture** where configuration flows from a single YAML file through both Python and Rust toolchains to produce a unified notation font and matching Rust constants.

```
┌──────────────────────────────────────────────────────────────┐
│  tools/fontgen/atoms.yaml (SINGLE SOURCE OF TRUTH)          │
│  - Pitch systems definitions (number, western, sargam, doremi)│
│  - Character order (47 chars total)                         │
│  - PUA allocation scheme                                    │
│  - Symbol definitions (accidentals, barlines, ornaments)    │
│  - Font metrics (dot positioning, accidental offsets)       │
└───────────┬──────────────────────────┬──────────────────────┘
            │                          │
            ▼                          ▼
    ┌──────────────────┐      ┌──────────────────────┐
    │   build.rs       │      │  generate_noto.py    │
    │  (Rust build)    │      │  (Python fontforge)  │
    └────────┬─────────┘      └──────────┬───────────┘
             │                           │
             ▼                           ▼
    ┌──────────────────┐      ┌──────────────────────┐
    │ font_constants   │      │  NotationFont.ttf    │
    │ (Rust module)    │      │  (TrueType font)     │
    └────────┬─────────┘      └──────────┬───────────┘
             │                           │
             ├───────────┬───────────────┘
             │           │
             ▼           ▼
        Rust code  Browser rendering
        (font_utils.rs)  (HTML/CSS/JS)
```

## Data Structures

### 1. Configuration: atoms.yaml

**Purpose:** Central configuration for the entire font system

**Sections:**

#### notation_systems
```yaml
notation_systems:
  - system_name: number
    display_name: "Number System"
    characters:
      - char: "1"
        label: "1 (first degree)"
```

Defines 4 pitch notation systems with all their characters.
- **Number:** 1-7 (default)
- **Western:** C-B, c-b
- **Sargam:** Indian classical (Sa Re Ga Ma Pa Dha Ni)
- **Doremi:** Solfège (do re mi fa sol la ti)

#### source_fonts
```yaml
source_fonts:
  base_font:
    path: "tools/fontgen/sources/NotoMusic.ttf"
    name: "Noto Music"
    version: "2.001"
    license: "SIL OFL 1.1"
```

Specifies the source font and location.

#### character_order
```yaml
character_order: "1234567CDEFGABcdefgabSrRgGmMPdDnNdrmfsltDRMFSLT"
```

**CRITICAL:** This string determines glyph allocation in the PUA. Must be maintained consistently across:
- `build.rs` (reads from atoms.yaml)
- Python generator (reads from atoms.yaml)
- All lookups use index in this string

#### pua
```yaml
pua:
  start: 0xE000
  formula: "codepoint = pua_start + (character_index × 4) + variant_index"
```

PUA allocation scheme for all custom glyphs.

#### geometry
```yaml
geometry:
  dots:
    above_gap: 50
    below_gap: 50
    vertical_step: 100
    horizontal_center: true
  symbols:
    accidental_scale: 1.0
    accidental_x_offset: 0
    accidental_y_offset: 0
```

Font metrics for dot and symbol positioning.

#### bravura_symbols
```yaml
bravura_symbols:
  - glyph_name: "accidentalSharp"
    label: "Sharp (#)"
    smufl_codepoint: 0xE262
    codepoint_offset: 0
```

Musical symbols to extract from Noto Music (SMuFL glyphs).

### 2. Build Artifact: font_constants.rs

**Generated by:** build.rs at compile time
**Location:** `target/debug/build/editor-wasm-*/out/font_constants.rs`
**Included in:** `src/lib.rs` via `include!()` macro

**Generated content:**
```rust
pub const ALL_CHARS: &str = "1234567...";  // From atoms.yaml
pub const PUA_START: u32 = 0xE000;         // From atoms.yaml
pub const CHARS_PER_VARIANT: u32 = 4;      // Fixed
pub const ACCIDENTAL_PUA_START: u32 = 0xE1F0;
pub const TOTAL_CHARACTERS: usize = 47;
```

**Accessed by:** `src/renderers/font_utils.rs` via `use crate::{...}`

### 3. Output Font: NotationFont.ttf

**Generated by:** `scripts/fonts/generate_noto.py`
**Location:** `static/fonts/NotationFont.ttf`
**Size:** ~600-700 KB

**Glyph inventory:**
- **Base characters:** 47 glyphs (0xE000-0xE02E)
- **Octave variants:** 188 glyphs (0xE000-0xE0BB, 4 variants per char)
  - Variant 0: 1 dot above (octave +1)
  - Variant 1: 2 dots above (octave +2)
  - Variant 2: 1 dot below (octave -1)
  - Variant 3: 2 dots below (octave -2)
- **Sharp accidentals:** 47 glyphs (0xE1F0-0xE21E)
- **Musical symbols:** 14 glyphs (0xE220 onwards)
  - Accidentals: sharp, flat, natural, double-sharp, double-flat
  - Barlines: single, double, repeat-left, repeat-right, repeat-both
  - Ornaments: mordent, inverted-mordent, turn, trill

## Code Flow

### 1. Compilation (Rust)

```
cargo build
  ├─ build.rs runs
  │  ├─ Read tools/fontgen/atoms.yaml
  │  ├─ Parse YAML (serde_yaml)
  │  ├─ Generate font_constants.rs
  │  └─ Write to target/.../out/
  │
  └─ src/lib.rs compiles
     ├─ include!(concat!(env!("OUT_DIR"), "/font_constants.rs"))
     ├─ src/renderers/font_utils.rs uses crate::{ALL_CHARS, ...}
     └─ Constants are now available to all Rust code
```

### 2. Font Generation (Python)

```
python3 scripts/fonts/generate_noto.py
  ├─ Read tools/fontgen/atoms.yaml
  ├─ Load tools/fontgen/sources/NotoMusic.ttf
  │
  ├─ For each of 47 characters:
  │  ├─ Extract from Noto Music (basic Latin)
  │  ├─ Create 4 octave variants (composite glyphs with dots)
  │  └─ Create accidental variant (composite glyph with sharp)
  │
  ├─ Extract musical symbols from Noto Music SMuFL glyphs
  │
  └─ Write static/fonts/NotationFont.ttf
```

### 3. Runtime (Rust)

```
When app calls get_glyph_codepoint('1', 1):
  ├─ ALL_CHARS.find('1') → 0 (character index)
  ├─ variant_idx = 0 (octave +1 → 1 dot above)
  ├─ codepoint = PUA_START + (0 * CHARS_PER_VARIANT) + 0
  │            = 0xE000 + 0 + 0 = 0xE000
  └─ char::from_u32(0xE000) → Unicode character at PUA codepoint
```

### 4. Browser Rendering (JavaScript)

```
HTML <span> with content 'Ê' (the glyph at U+E000)
  ├─ CSS: font-family: 'NotationFont'
  ├─ Browser looks up U+E000 in NotationFont.ttf
  ├─ Renders 1 with 1 dot above (octave +1)
  └─ Display on page
```

## Key Design Principles

### 1. Single Source of Truth

✅ **atoms.yaml** is THE source for:
- Pitch systems and characters
- Character order (critical for PUA allocation)
- Font metrics and positioning
- Symbol definitions

Both Python and Rust tools read from atoms.yaml → guaranteed sync.

### 2. Build-Time Verification

✅ **build.rs** runs at compile time:
- Parses atoms.yaml
- Generates Rust constants
- **Build fails if atoms.yaml is invalid**
- Ensures constants match font generator

### 3. No Hardcoded Strings

✅ **Character order is never hardcoded:**
```rust
// OLD (bad):
const ALL_CHARS: &str = "1234567...";  // Hardcoded, can diverge

// NEW (good):
use crate::ALL_CHARS;  // From build.rs, which read atoms.yaml
```

### 4. PUA Allocation Formula

```
codepoint = PUA_START + (character_index * CHARS_PER_VARIANT) + variant_index

Where:
- character_index = position in ALL_CHARS string
- CHARS_PER_VARIANT = 4 (always)
- variant_index = 0-3 (octave shift indicator)
```

**Example: '1' (index 0) with octave +1:**
```
0xE000 + (0 * 4) + 0 = 0xE000
```

**Example: '7' (index 6) with octave -2:**
```
0xE000 + (6 * 4) + 3 = 0xE000 + 24 + 3 = 0xE01B
```

### 5. Composite Glyphs

Font contains **references** to base characters and dots, then **decomposes** to outlines:

```python
# In generate_noto.py:
variant_glyph.addReference(base_glyph_name, (...))  # Add base char
variant_glyph.addReference(dot_glyph_name, (...))   # Add dot at position
variant_glyph.decompose()  # Convert references to outlines
```

Benefits:
- Easy to maintain in generator
- Portable (no dependency on reference resolution)
- Works in all browsers

## Critical Dependencies

### Python
- **fontforge** - Font manipulation via Python API
- **pyyaml** - YAML parsing for atoms.yaml
- **serde_yaml** (Rust build-dependency) - YAML parsing in build.rs

### Rust
- **serde_yaml** - Parse atoms.yaml during build
- **serde** - Serialize/deserialize YAML

### Font Files
- **tools/fontgen/sources/NotoMusic.ttf** - Must be manually downloaded
- **static/fonts/NotationFont.ttf** - Generated output

## Testing Strategy

### Unit Tests (Rust)

```bash
cargo test -p editor-wasm --lib font_utils
```

22 tests covering:
- Octave shift calculations
- Accidental glyph allocation
- Character order completeness
- Edge cases (unknown chars, out-of-range shifts)

All tests use generated constants from build.rs.

### Integration Tests (E2E)

```bash
npx playwright test tests/e2e-pw/tests/
```

Browser tests verify:
- NotationFont.ttf loads
- Glyphs render correctly
- No font-loading errors

### Visual Tests

Manual testing at http://localhost:8080:
- Type notation and observe glyphs
- Check Font Test tab for all available glyphs
- Verify octave dots appear
- Test accidental symbols (#, b, etc.)

## Troubleshooting

### Constant mismatch errors

**Symptom:** "Character index out of range" in tests

**Cause:** atoms.yaml character_order changed but Rust code recompiled with old constants

**Solution:**
```bash
cargo clean
cargo build  # Will regenerate font_constants.rs
```

### Font not updating in browser

**Symptom:** Glyphs unchanged after running `make fonts`

**Cause:** Browser cache or font file not regenerated

**Solution:**
```bash
make fonts                # Regenerate NotationFont.ttf
make build               # Rebuild app
Hard refresh in browser  # Ctrl+Shift+R
```

### Python generator fails

**Symptom:** `FileNotFoundError: NotoMusic.ttf`

**Cause:** Noto Music font not downloaded

**Solution:**
```bash
mkdir -p tools/fontgen/sources
wget https://github.com/notofonts/music/releases/download/v2.001/NotoMusic-Regular.ttf \
     -O tools/fontgen/sources/NotoMusic.ttf
```

## Future Improvements

### Phase 2: Enhanced Features
- [ ] Flat and natural accidental glyphs (currently only sharp)
- [ ] Double-sharp and double-flat variants
- [ ] Configurable dot positioning per system
- [ ] Font metrics auto-adjustment from Noto Music

### Phase 3: Optimization
- [ ] WOFF2 conversion for web delivery
- [ ] Subsetting to remove unused glyphs
- [ ] Variable font support (weight/width variations)

### Phase 4: Extensions
- [ ] Per-system style customization
- [ ] Extended symbol coverage (dynamics, articulations)
- [ ] Integration with LilyPond SMuFL

## References

- **atoms.yaml:** `tools/fontgen/atoms.yaml`
- **build.rs:** `build.rs` (compile-time code generation)
- **Generator:** `scripts/fonts/generate_noto.py`
- **Font utilities:** `src/renderers/font_utils.rs`
- **Noto Music:** https://github.com/notofonts/music
- **SMuFL:** https://w3c.github.io/smufl/
- **FontForge Python:** https://fontforge.org/docs/scripting/python.html

---

**Version:** 2.0 (Noto Music Edition)
**Last Verified:** November 2025
