//! Font utilities for notation font glyph substitution
//!
//! This module provides utilities for mapping pitch characters with octave shifts
//! to Private Use Area (PUA) codepoints in the NotationFont.ttf.
//!
//! The NotationFont.ttf is a composite font combining:
//! - **Noto Sans**: Base font providing pitch character glyphs (1-7, A-Z, a-z)
//! - **Noto Music**: SMuFL musical symbols (accidentals, barlines, ornaments)
//!
//! **Octave Variants** (188 glyphs - 47 chars × 4 variants in PUA):
//! - 7 number system characters (1-7)
//! - 14 western system characters (C-B, c-b)
//! - 12 sargam system characters (S, r, R, g, G, m, M, P, d, D, n, N)
//! - 14 doremi system characters (d, r, m, f, s, l, t, D, R, M, F, S, L, T)
//!
//! Each character has 4 octave shift variants in the PUA:
//! - Variant 0: 1 dot above (octave +1)
//! - Variant 1: 2 dots above (octave +2)
//! - Variant 2: 1 dot below (octave -1)
//! - Variant 3: 2 dots below (octave -2)
//!
//! **Music Symbols** (14 glyphs from Noto Music SMuFL ranges):
//! - Accidentals: Sharp, flat, natural, double-sharp, double-flat
//! - Barlines: Single, double, repeat (left/right/both)
//! - Ornaments: Mordent, inverted mordent, turn, trill
//!
//! Symbol codepoints are loaded at runtime from `NotationFont-map.json`.
//!
//! **Note:** All note atom constants are generated at compile-time from tools/fontgen/atoms.yaml
//! by build.rs to ensure perfect sync between Python font generator and Rust code.

// Use constants generated by build.rs from atoms.yaml
use crate::{ALL_CHARS, PUA_START, CHARS_PER_VARIANT};
use wasm_bindgen::prelude::*;

/// Export font configuration to JavaScript
/// This ensures JavaScript always uses the correct code points from build.rs
///
/// Returns a JSON object with:
/// - all_chars: String of all characters in canonical order
/// - pua_start: Starting codepoint for octave variants (0xE600)
/// - chars_per_variant: Number of variants per character (4)
/// - total_characters: Total number of characters (47)
///
/// Note: Symbol codepoints (accidentals, barlines, ornaments) are loaded from
/// NotationFont-map.json at runtime, not from this compile-time config.
#[wasm_bindgen(js_name = getFontConfig)]
pub fn get_font_config() -> JsValue {
    #[derive(serde::Serialize)]
    struct FontConfig {
        all_chars: String,
        pua_start: u32,
        chars_per_variant: u32,
        total_characters: usize,
    }

    let config = FontConfig {
        all_chars: ALL_CHARS.to_string(),
        pua_start: PUA_START,
        chars_per_variant: CHARS_PER_VARIANT,
        total_characters: ALL_CHARS.len(),
    };

    serde_wasm_bindgen::to_value(&config).unwrap_or(JsValue::NULL)
}

/// Get the glyph codepoint for a pitch character with octave shift
///
/// # Arguments
/// * `base_char` - The pitch character (1, C, S, f, etc.)
/// * `octave_shift` - Octave shift: -2, -1, 0, 1, or 2
///
/// # Returns
/// A Unicode codepoint as a character:
/// - If octave_shift is 0 or character not found: returns base_char unchanged
/// - If octave_shift is non-zero and char found: returns PUA glyph codepoint
///
/// # Examples
/// ```
/// assert_eq!(get_glyph_codepoint('1', 0), '1');  // No octave shift
/// assert_eq!(get_glyph_codepoint('1', 1), '\u{E000}');  // 1 with 1 dot above
/// assert_eq!(get_glyph_codepoint('1', -2), '\u{E003}');  // 1 with 2 dots below
/// assert_eq!(get_glyph_codepoint('C', 1), '\u{E01C}');  // C with 1 dot above
/// ```
pub fn get_glyph_codepoint(base_char: char, octave_shift: i8) -> char {
    // No octave shift means use base character
    if octave_shift == 0 {
        return base_char;
    }

    // Find the character index in our canonical string
    let char_index = match ALL_CHARS.find(base_char) {
        Some(idx) => idx as u32,
        None => return base_char, // Unknown character, return as-is
    };

    // Map octave shift to variant index
    let variant_idx: u32 = match octave_shift {
        1 => 0,   // 1 dot above
        2 => 1,   // 2 dots above
        -1 => 2,  // 1 dot below
        -2 => 3,  // 2 dots below
        _ => return base_char, // Out of range, return base character
    };

    // Calculate the codepoint: base + (char_index * 4) + variant
    let codepoint = PUA_START + (char_index * CHARS_PER_VARIANT) + variant_idx;

    // Convert to character, fallback to base if conversion fails
    char::from_u32(codepoint).unwrap_or(base_char)
}

/// Get the glyph codepoint for a pitch character with an accidental (sharp/flat)
///
/// # Arguments
/// * `base_char` - The pitch character (1, C, S, f, etc.)
/// * `accidental` - The accidental type:
///   - 0 or 'n' = natural (no accidental, returns base char)
///   - 1 or 's' = sharp (U+E1F0-E21E: 47 glyphs)
///   - 2 or 'b' = flat (U+E220-E24E: 47 glyphs)
///   - 3 or 'x' = double sharp (U+E250-E27E: 47 glyphs)
///   - 4 or 'y' = double flat (U+E280-E2AE: 47 glyphs)
///
/// # Returns
/// A Unicode codepoint as a character:
/// - If accidental is natural or character not found: returns base_char unchanged
/// - If accidental is non-natural and char found: returns PUA glyph codepoint
///
/// # Examples
/// ```
/// assert_eq!(get_accidental_glyph_codepoint('1', 0), '1');  // Natural (no accidental)
/// assert_eq!(get_accidental_glyph_codepoint('1', 1), '\u{E1F0}');  // 1 sharp
/// assert_eq!(get_accidental_glyph_codepoint('2', 1), '\u{E1F1}');  // 2 sharp
/// assert_eq!(get_accidental_glyph_codepoint('1', 2), '\u{E220}');  // 1 flat
/// assert_eq!(get_accidental_glyph_codepoint('1', 3), '\u{E250}');  // 1 double sharp
/// assert_eq!(get_accidental_glyph_codepoint('1', 4), '\u{E280}');  // 1 double flat
/// ```
pub fn get_accidental_glyph_codepoint(base_char: char, accidental: u8) -> char {
    // Natural accidental: return base character unchanged
    if accidental == 0 || accidental == b'n' {
        return base_char;
    }

    // Find the character index in our canonical string
    let char_index = match ALL_CHARS.find(base_char) {
        Some(idx) => idx as u32,
        None => return base_char, // Unknown character, return as-is
    };

    // Map accidental code to PUA range start
    let pua_start: u32 = match accidental {
        1 | b's' => 0xE1F0,  // Sharp composites
        2 | b'b' => 0xE220,  // Flat composites
        3 | b'x' => 0xE250,  // Double-sharp composites
        4 | b'y' => 0xE280,  // Double-flat composites
        _ => return base_char, // Unknown accidental code, return base character
    };

    // Calculate the codepoint: pua_start + char_index
    let codepoint = pua_start + char_index;

    // Convert to character, fallback to base if conversion fails
    char::from_u32(codepoint).unwrap_or(base_char)
}

/// Get codepoint for combined accidental + octave glyph
///
/// This function handles the case where a note has BOTH an accidental AND an octave shift.
/// For example: "1# with octave +1" (1 sharp with dot above)
///
/// Code point allocation (752 glyphs total):
/// - Sharp + octave:        0xE2B0 - 0xE36F (188 glyphs: 47 chars × 4 octave variants)
/// - Flat + octave:         0xE370 - 0xE42F (188 glyphs: 47 chars × 4 octave variants)
/// - Double-sharp + octave: 0xE430 - 0xE4EF (188 glyphs: 47 chars × 4 octave variants)
/// - Double-flat + octave:  0xE4F0 - 0xE5AF (188 glyphs: 47 chars × 4 octave variants)
///
/// Formula: `pua_start + (char_index × 4) + variant_index`
///
/// # Arguments
/// * `base_char` - The base note character ('1', '2', ..., 'C', 'D', etc.)
/// * `accidental` - Accidental type (1=sharp, 2=flat, 3=double-sharp, 4=double-flat)
/// * `octave_shift` - Octave shift (-2 to +2)
///
/// # Examples
/// ```
/// assert_eq!(get_combined_accidental_octave_glyph('1', 1, 1), '\u{E2B0}');  // 1# with +1 octave
/// assert_eq!(get_combined_accidental_octave_glyph('1', 1, -1), '\u{E2B2}');  // 1# with -1 octave
/// assert_eq!(get_combined_accidental_octave_glyph('2', 2, 2), '\u{E375}');  // 2b with +2 octaves
/// ```
pub fn get_combined_accidental_octave_glyph(base_char: char, accidental: u8, octave_shift: i8) -> char {
    // No octave shift: use plain accidental glyph
    if octave_shift == 0 {
        return get_accidental_glyph_codepoint(base_char, accidental);
    }

    // No accidental: use plain octave glyph
    if accidental == 0 || accidental == b'n' {
        return get_glyph_codepoint(base_char, octave_shift);
    }

    // Find the character index in our canonical string
    let char_index = match ALL_CHARS.find(base_char) {
        Some(idx) => idx as u32,
        None => return base_char, // Unknown character, return as-is
    };

    // Map octave shift to variant index (0-3)
    let variant_index = match octave_shift {
        1 => 0,   // +1 octave (1 dot above)
        2 => 1,   // +2 octaves (2 dots above)
        -1 => 2,  // -1 octave (1 dot below)
        -2 => 3,  // -2 octaves (2 dots below)
        _ => return get_accidental_glyph_codepoint(base_char, accidental), // Invalid octave, fallback to plain accidental
    };

    // Map accidental code to PUA range start (for combined accidental+octave glyphs)
    let pua_start: u32 = match accidental {
        1 | b's' => 0xE2B0,  // Sharp + octave composites
        2 | b'b' => 0xE370,  // Flat + octave composites
        3 | b'x' => 0xE430,  // Double-sharp + octave composites
        4 | b'y' => 0xE4F0,  // Double-flat + octave composites
        _ => return get_accidental_glyph_codepoint(base_char, accidental), // Unknown accidental, fallback
    };

    // Calculate the codepoint: pua_start + (char_index × 4) + variant_index
    let codepoint = pua_start + (char_index * 4) + variant_index;

    // Convert to character, fallback to plain accidental if conversion fails
    char::from_u32(codepoint).unwrap_or_else(|| get_accidental_glyph_codepoint(base_char, accidental))
}

// Deprecated: use get_accidental_glyph_codepoint instead
pub fn get_sharp_glyph_codepoint(base_char: char, accidental: u8) -> char {
    get_accidental_glyph_codepoint(base_char, accidental)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_octave_shift_zero_returns_base_char() {
        assert_eq!(get_glyph_codepoint('1', 0), '1');
        assert_eq!(get_glyph_codepoint('C', 0), 'C');
        assert_eq!(get_glyph_codepoint('S', 0), 'S');
        assert_eq!(get_glyph_codepoint('f', 0), 'f');
    }

    #[test]
    fn test_unknown_character_returns_base() {
        assert_eq!(get_glyph_codepoint('x', 1), 'x');
        assert_eq!(get_glyph_codepoint('!', -1), '!');
        assert_eq!(get_glyph_codepoint('∞', 2), '∞');
    }

    #[test]
    fn test_out_of_range_octave_returns_base() {
        assert_eq!(get_glyph_codepoint('1', 3), '1'); // +3 is out of range
        assert_eq!(get_glyph_codepoint('1', -3), '1'); // -3 is out of range
    }

    #[test]
    fn test_number_system_octave_plus_1() {
        // Character index 0
        let cp = get_glyph_codepoint('1', 1);
        assert_eq!(cp as u32, 0xE600); // 0xE600 + (0 * 4) + 0

        // Character index 6
        let cp = get_glyph_codepoint('7', 1);
        assert_eq!(cp as u32, 0xE618); // 0xE600 + (6 * 4) + 0
    }

    #[test]
    fn test_number_system_octave_plus_2() {
        // Character index 0
        let cp = get_glyph_codepoint('1', 2);
        assert_eq!(cp as u32, 0xE601); // 0xE600 + (0 * 4) + 1

        // Character index 6
        let cp = get_glyph_codepoint('7', 2);
        assert_eq!(cp as u32, 0xE619); // 0xE600 + (6 * 4) + 1
    }

    #[test]
    fn test_number_system_octave_minus_1() {
        // Character index 0
        let cp = get_glyph_codepoint('1', -1);
        assert_eq!(cp as u32, 0xE602); // 0xE600 + (0 * 4) + 2

        // Character index 6
        let cp = get_glyph_codepoint('7', -1);
        assert_eq!(cp as u32, 0xE61A); // 0xE600 + (6 * 4) + 2
    }

    #[test]
    fn test_number_system_octave_minus_2() {
        // Character index 0
        let cp = get_glyph_codepoint('1', -2);
        assert_eq!(cp as u32, 0xE603); // 0xE600 + (0 * 4) + 3

        // Character index 6
        let cp = get_glyph_codepoint('7', -2);
        assert_eq!(cp as u32, 0xE61B); // 0xE600 + (6 * 4) + 3
    }

    #[test]
    fn test_western_system_uppercase() {
        // C is at index 7 (unique)
        let cp = get_glyph_codepoint('C', 1);
        assert_eq!(cp as u32, 0xE61C); // 0xE600 + (7 * 4) + 0 = 58908

        // B is at index 13 (unique)
        let cp = get_glyph_codepoint('B', -1);
        assert_eq!(cp as u32, 0xE636); // 0xE600 + (13 * 4) + 2 = 58934
    }

    #[test]
    fn test_western_system_lowercase() {
        // c is at index 14 (unique in Western, also in Doremi at 33 but first occurrence wins)
        let cp = get_glyph_codepoint('c', 2);
        assert_eq!(cp as u32, 0xE639); // 0xE600 + (14 * 4) + 1 = 58937

        // b is at index 20 (unique)
        let cp = get_glyph_codepoint('b', -2);
        assert_eq!(cp as u32, 0xE653); // 0xE600 + (20 * 4) + 3 = 58963
    }

    #[test]
    fn test_sargam_system() {
        // S is at index 21 (first and only occurrence in SARGAM context)
        let cp = get_glyph_codepoint('S', 1);
        assert_eq!(cp as u32, 0xE654); // 0xE600 + (21 * 4) + 0

        // r is at index 22 (first occurrence - used for all systems)
        let cp = get_glyph_codepoint('r', -1);
        assert_eq!(cp as u32, 0xE65A); // 0xE600 + (22 * 4) + 2

        // N is at index 32 (unique to Sargam uppercase)
        let cp = get_glyph_codepoint('N', 2);
        assert_eq!(cp as u32, 0xE681); // 0xE600 + (32 * 4) + 1
    }

    #[test]
    fn test_doremi_system() {
        // Note: Doremi system shares some lowercase characters with Western and Sargam
        // Lookup uses FIRST occurrence of each character

        // 'd' first appears at index 15 (Western lowercase), not 33 (Doremi)
        let cp = get_glyph_codepoint('d', 1);
        assert_eq!(cp as u32, 0xE63C); // 0xE600 + (15 * 4) + 0 = 58940

        // 'f' first appears at index 17 (Western lowercase), not 36 (Doremi)
        let cp = get_glyph_codepoint('f', -1);
        assert_eq!(cp as u32, 0xE646); // 0xE600 + (17 * 4) + 2 = 58950

        // 't' first appears at index 39 (Doremi lowercase) - unique
        let cp = get_glyph_codepoint('t', 2);
        assert_eq!(cp as u32, 0xE69D); // 0xE600 + (39 * 4) + 1 = 59037
    }

    #[test]
    fn test_all_number_characters_exist_in_font() {
        for ch in "1234567".chars() {
            let cp = get_glyph_codepoint(ch, 1);
            assert_ne!(cp, ch, "Character '{}' should have a PUA glyph", ch);
            assert!(cp as u32 >= 0xE600, "Codepoint for '{}' should be in PUA range", ch);
            assert!(cp as u32 <= 0xE6BB, "Codepoint for '{}' should be in PUA range", ch);
        }
    }

    #[test]
    fn test_character_order_completeness() {
        // Verify the character order string is not empty and has expected content
        assert!(!ALL_CHARS.is_empty());
        assert!(ALL_CHARS.contains('1'));
        assert!(ALL_CHARS.contains('C'));
        assert!(ALL_CHARS.contains('S'));
        assert!(ALL_CHARS.contains('d')); // Lowercase d (appears multiple times)
        assert!(ALL_CHARS.contains('T')); // Uppercase T (unique to Doremi)

        // Verify length matches expected: 7 + 14 + 12 + 14 = 47 unique chars
        // (some chars repeat, total length is 47 with duplicates)
        assert_eq!(ALL_CHARS.len(), 47);
    }

    // ===== Tests for accidental glyphs (sharp, flat, double-sharp, double-flat) =====

    #[test]
    fn test_accidental_natural_returns_base_char() {
        assert_eq!(get_accidental_glyph_codepoint('1', 0), '1');
        assert_eq!(get_accidental_glyph_codepoint('1', b'n'), '1');
        assert_eq!(get_accidental_glyph_codepoint('C', 0), 'C');
        assert_eq!(get_accidental_glyph_codepoint('S', b'n'), 'S');
    }

    #[test]
    fn test_accidental_unknown_character_returns_base() {
        assert_eq!(get_accidental_glyph_codepoint('x', 1), 'x');
        assert_eq!(get_accidental_glyph_codepoint('!', 2), '!');
        assert_eq!(get_accidental_glyph_codepoint('∞', 3), '∞');
    }

    #[test]
    fn test_accidental_unknown_code_returns_base() {
        assert_eq!(get_accidental_glyph_codepoint('1', 99), '1'); // Invalid accidental code
        assert_eq!(get_accidental_glyph_codepoint('C', 255), 'C');
    }

    #[test]
    fn test_number_system_sharp() {
        // Character index 0: '1' at U+E1F0
        let cp = get_accidental_glyph_codepoint('1', 1);
        assert_eq!(cp as u32, 0xE1F0); // 0xE1F0 + 0

        // Character index 6: '7' at U+E1F6
        let cp = get_accidental_glyph_codepoint('7', b's');
        assert_eq!(cp as u32, 0xE1F6); // 0xE1F0 + 6
    }

    #[test]
    fn test_number_system_flat() {
        // Character index 0: '1' flat at U+E220
        let cp = get_accidental_glyph_codepoint('1', 2);
        assert_eq!(cp as u32, 0xE220); // 0xE220 + 0

        // Character index 6: '7' flat at U+E226
        let cp = get_accidental_glyph_codepoint('7', b'b');
        assert_eq!(cp as u32, 0xE226); // 0xE220 + 6
    }

    #[test]
    fn test_number_system_double_sharp() {
        // Character index 0: '1' double sharp at U+E250
        let cp = get_accidental_glyph_codepoint('1', 3);
        assert_eq!(cp as u32, 0xE250); // 0xE250 + 0

        // Character index 6: '7' double sharp at U+E256
        let cp = get_accidental_glyph_codepoint('7', b'x');
        assert_eq!(cp as u32, 0xE256); // 0xE250 + 6
    }

    #[test]
    fn test_number_system_double_flat() {
        // Character index 0: '1' double flat at U+E280
        let cp = get_accidental_glyph_codepoint('1', 4);
        assert_eq!(cp as u32, 0xE280); // 0xE280 + 0

        // Character index 6: '7' double flat at U+E286
        let cp = get_accidental_glyph_codepoint('7', b'y');
        assert_eq!(cp as u32, 0xE286); // 0xE280 + 6
    }

    #[test]
    fn test_western_system_sharp() {
        // C is at index 7: C# at U+E1F7
        let cp_sharp = get_accidental_glyph_codepoint('C', 1);
        assert_eq!(cp_sharp as u32, 0xE1F7); // 0xE1F0 + 7

        // B is at index 13: B# at U+E1FD
        let cp = get_accidental_glyph_codepoint('B', 1);
        assert_eq!(cp as u32, 0xE1FD); // 0xE1F0 + 13
    }

    #[test]
    fn test_western_system_flat() {
        // C is at index 7: C♭ at U+E227
        let cp = get_accidental_glyph_codepoint('C', 2);
        assert_eq!(cp as u32, 0xE227); // 0xE220 + 7

        // B is at index 13: B♭ at U+E22D
        let cp = get_accidental_glyph_codepoint('B', 2);
        assert_eq!(cp as u32, 0xE22D); // 0xE220 + 13
    }

    #[test]
    fn test_all_number_characters_have_accidental_glyphs() {
        for ch in "1234567".chars() {
            // Test sharp
            let cp = get_accidental_glyph_codepoint(ch, 1);
            assert_ne!(cp, ch, "Character '{}' should have a sharp glyph", ch);
            assert!(cp as u32 >= 0xE1F0, "Sharp codepoint for '{}' should be in range", ch);
            assert!(cp as u32 <= 0xE21E, "Sharp codepoint for '{}' should be in range", ch);

            // Test flat
            let cp = get_accidental_glyph_codepoint(ch, 2);
            assert_ne!(cp, ch, "Character '{}' should have a flat glyph", ch);
            assert!(cp as u32 >= 0xE220, "Flat codepoint for '{}' should be in range", ch);
            assert!(cp as u32 <= 0xE24E, "Flat codepoint for '{}' should be in range", ch);

            // Test double sharp
            let cp = get_accidental_glyph_codepoint(ch, 3);
            assert_ne!(cp, ch, "Character '{}' should have a double sharp glyph", ch);
            assert!(cp as u32 >= 0xE250, "Double sharp codepoint for '{}' should be in range", ch);
            assert!(cp as u32 <= 0xE27E, "Double sharp codepoint for '{}' should be in range", ch);

            // Test double flat
            let cp = get_accidental_glyph_codepoint(ch, 4);
            assert_ne!(cp, ch, "Character '{}' should have a double flat glyph", ch);
            assert!(cp as u32 >= 0xE280, "Double flat codepoint for '{}' should be in range", ch);
            assert!(cp as u32 <= 0xE2AE, "Double flat codepoint for '{}' should be in range", ch);
        }
    }

    #[test]
    fn test_backward_compatibility_get_sharp_glyph_codepoint() {
        // Old function should still work and delegate to new function
        assert_eq!(get_sharp_glyph_codepoint('1', 0), '1');
        assert_eq!(get_sharp_glyph_codepoint('1', 1), get_accidental_glyph_codepoint('1', 1));
        assert_eq!(get_sharp_glyph_codepoint('C', 2), get_accidental_glyph_codepoint('C', 2));
    }
}
