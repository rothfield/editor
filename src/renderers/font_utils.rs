//! Font utilities for notation font glyph substitution
//!
//! This module provides utilities for mapping pitch characters with octave shifts
//! to Private Use Area (PUA) codepoints in the NotationFont.ttf.
//!
//! The NotationFont.ttf is a composite font combining:
//! - **Noto Sans**: Base font providing pitch character glyphs (1-7, A-Z, a-z)
//! - **Noto Music**: SMuFL musical symbols (accidentals, barlines, ornaments)
//!
//! **Octave Variants** (188 glyphs - 47 chars × 4 variants in PUA):
//! - 7 number system characters (1-7)
//! - 14 western system characters (C-B, c-b)
//! - 12 sargam system characters (S, r, R, g, G, m, M, P, d, D, n, N)
//! - 14 doremi system characters (d, r, m, f, s, l, t, D, R, M, F, S, L, T)
//!
//! Each character has 4 octave shift variants in the PUA:
//! - Variant 0: 1 dot above (octave +1)
//! - Variant 1: 2 dots above (octave +2)
//! - Variant 2: 1 dot below (octave -1)
//! - Variant 3: 2 dots below (octave -2)
//!
//! **Music Symbols** (14 glyphs from Noto Music SMuFL ranges):
//! - Accidentals: Sharp, flat, natural, double-sharp, double-flat
//! - Barlines: Single, double, repeat (left/right/both)
//! - Ornaments: Mordent, inverted mordent, turn, trill
//!
//! Symbol codepoints are loaded at runtime from `NotationFont-map.json`.
//!
//! **Note:** All note atom constants are generated at compile-time from tools/fontgen/atoms.yaml
//! by build.rs to ensure perfect sync between Python font generator and Rust code.

// Use constants generated by build.rs from atoms.yaml
use crate::{ALL_CHARS, PUA_START, CHARS_PER_VARIANT};
use wasm_bindgen::prelude::*;

/// Export font configuration to JavaScript
/// This ensures JavaScript always uses the correct code points from build.rs
///
/// Returns a JSON object with:
/// - all_chars: String of all characters in canonical order
/// - pua_start: Starting codepoint for octave variants (0xE600)
/// - chars_per_variant: Number of variants per character (4)
/// - total_characters: Total number of characters (47)
///
/// Note: Symbol codepoints (accidentals, barlines, ornaments) are loaded from
/// NotationFont-map.json at runtime, not from this compile-time config.
#[wasm_bindgen(js_name = getFontConfig)]
pub fn get_font_config() -> JsValue {
    #[derive(serde::Serialize)]
    struct FontConfig {
        all_chars: String,
        pua_start: u32,
        chars_per_variant: u32,
        total_characters: usize,
    }

    let config = FontConfig {
        all_chars: ALL_CHARS.to_string(),
        pua_start: PUA_START,
        chars_per_variant: CHARS_PER_VARIANT,
        total_characters: ALL_CHARS.len(),
    };

    serde_wasm_bindgen::to_value(&config).unwrap_or(JsValue::NULL)
}

/// Get the glyph codepoint for a pitch character with octave shift
///
/// # Arguments
/// * `base_char` - The pitch character (1, C, S, f, etc.)
/// * `octave_shift` - Octave shift: -2, -1, 0, 1, or 2
///
/// # Returns
/// A Unicode codepoint as a character:
/// - If octave_shift is 0 or character not found: returns base_char unchanged
/// - If octave_shift is non-zero and char found: returns PUA glyph codepoint
///
/// # Examples
/// ```
/// assert_eq!(get_glyph_codepoint('1', 0), '1');  // No octave shift
/// assert_eq!(get_glyph_codepoint('1', 1), '\u{E000}');  // 1 with 1 dot above
/// assert_eq!(get_glyph_codepoint('1', -2), '\u{E003}');  // 1 with 2 dots below
/// assert_eq!(get_glyph_codepoint('C', 1), '\u{E01C}');  // C with 1 dot above
/// ```
pub fn get_glyph_codepoint(base_char: char, octave_shift: i8) -> char {
    // No octave shift means use base character
    if octave_shift == 0 {
        return base_char;
    }

    // Find the character index in our canonical string
    let char_index = match ALL_CHARS.find(base_char) {
        Some(idx) => idx as u32,
        None => return base_char, // Unknown character, return as-is
    };

    // Map octave shift to variant index
    let variant_idx: u32 = match octave_shift {
        1 => 0,   // 1 dot above
        2 => 1,   // 2 dots above
        -1 => 2,  // 1 dot below
        -2 => 3,  // 2 dots below
        _ => return base_char, // Out of range, return base character
    };

    // Calculate the codepoint: base + (char_index * 4) + variant
    let codepoint = PUA_START + (char_index * CHARS_PER_VARIANT) + variant_idx;

    // Convert to character, fallback to base if conversion fails
    char::from_u32(codepoint).unwrap_or(base_char)
}

/// Get the glyph codepoint for a pitch character with an accidental (sharp/flat)
///
/// # Arguments
/// * `base_char` - The pitch character (1, C, S, f, etc.)
/// * `accidental` - The accidental type:
///   - 0 or 'n' = natural (no accidental, returns base char)
///   - 1 or 's' = sharp
///   - 2 or 'b' = flat
///   - 3 or 'x' = double sharp
///   - 4 or 'y' = double flat
///
/// # Returns
/// A Unicode codepoint as a character:
/// - If accidental is natural or character not found: returns base_char unchanged
/// - If accidental is non-natural and char found: returns PUA glyph codepoint
///
/// # Examples
/// ```
/// assert_eq!(get_sharp_glyph_codepoint('1', 0), '1');  // Natural (no accidental)
/// assert_eq!(get_sharp_glyph_codepoint('1', 1), '\u{E1F0}');  // 1 sharp
/// assert_eq!(get_sharp_glyph_codepoint('2', 1), '\u{E1F1}');  // 2 sharp
/// assert_eq!(get_sharp_glyph_codepoint('1', 2), '1');  // 1 flat (not in font yet, returns base)
/// ```
pub fn get_sharp_glyph_codepoint(base_char: char, _accidental: u8) -> char {
    // DEFERRED: Accidental support is deferred to v2.0 (see SPEC.md section 15).
    // In the current architecture (Noto Sans + Noto Music), accidentals are:
    // - Provided as separate symbols from Noto Music SMuFL ranges
    // - Rendered via CSS ::after pseudo-elements (not pre-composed glyphs)
    // - Not yet allocated as pre-composed glyphs in the PUA
    //
    // This function is kept for API compatibility but currently always returns
    // the base character. Accidental rendering is handled at the HTML/CSS layer.
    base_char
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_octave_shift_zero_returns_base_char() {
        assert_eq!(get_glyph_codepoint('1', 0), '1');
        assert_eq!(get_glyph_codepoint('C', 0), 'C');
        assert_eq!(get_glyph_codepoint('S', 0), 'S');
        assert_eq!(get_glyph_codepoint('f', 0), 'f');
    }

    #[test]
    fn test_unknown_character_returns_base() {
        assert_eq!(get_glyph_codepoint('x', 1), 'x');
        assert_eq!(get_glyph_codepoint('!', -1), '!');
        assert_eq!(get_glyph_codepoint('∞', 2), '∞');
    }

    #[test]
    fn test_out_of_range_octave_returns_base() {
        assert_eq!(get_glyph_codepoint('1', 3), '1'); // +3 is out of range
        assert_eq!(get_glyph_codepoint('1', -3), '1'); // -3 is out of range
    }

    #[test]
    fn test_number_system_octave_plus_1() {
        // Character index 0
        let cp = get_glyph_codepoint('1', 1);
        assert_eq!(cp as u32, 0xE000); // 0xE000 + (0 * 4) + 0

        // Character index 6
        let cp = get_glyph_codepoint('7', 1);
        assert_eq!(cp as u32, 0xE018); // 0xE000 + (6 * 4) + 0
    }

    #[test]
    fn test_number_system_octave_plus_2() {
        // Character index 0
        let cp = get_glyph_codepoint('1', 2);
        assert_eq!(cp as u32, 0xE001); // 0xE000 + (0 * 4) + 1

        // Character index 6
        let cp = get_glyph_codepoint('7', 2);
        assert_eq!(cp as u32, 0xE019); // 0xE000 + (6 * 4) + 1
    }

    #[test]
    fn test_number_system_octave_minus_1() {
        // Character index 0
        let cp = get_glyph_codepoint('1', -1);
        assert_eq!(cp as u32, 0xE002); // 0xE000 + (0 * 4) + 2

        // Character index 6
        let cp = get_glyph_codepoint('7', -1);
        assert_eq!(cp as u32, 0xE01A); // 0xE000 + (6 * 4) + 2
    }

    #[test]
    fn test_number_system_octave_minus_2() {
        // Character index 0
        let cp = get_glyph_codepoint('1', -2);
        assert_eq!(cp as u32, 0xE003); // 0xE000 + (0 * 4) + 3

        // Character index 6
        let cp = get_glyph_codepoint('7', -2);
        assert_eq!(cp as u32, 0xE01B); // 0xE000 + (6 * 4) + 3
    }

    #[test]
    fn test_western_system_uppercase() {
        // C is at index 7 (unique)
        let cp = get_glyph_codepoint('C', 1);
        assert_eq!(cp as u32, 0xE01C); // 0xE000 + (7 * 4) + 0 = 57372

        // B is at index 13 (unique)
        let cp = get_glyph_codepoint('B', -1);
        assert_eq!(cp as u32, 0xE036); // 0xE000 + (13 * 4) + 2 = 57398
    }

    #[test]
    fn test_western_system_lowercase() {
        // c is at index 14 (unique in Western, also in Doremi at 33 but first occurrence wins)
        let cp = get_glyph_codepoint('c', 2);
        assert_eq!(cp as u32, 0xE039); // 0xE000 + (14 * 4) + 1 = 57401

        // b is at index 20 (unique)
        let cp = get_glyph_codepoint('b', -2);
        assert_eq!(cp as u32, 0xE053); // 0xE000 + (20 * 4) + 3 = 57427
    }

    #[test]
    fn test_sargam_system() {
        // S is at index 21 (first and only occurrence in SARGAM context)
        let cp = get_glyph_codepoint('S', 1);
        assert_eq!(cp as u32, 0xE054); // 0xE000 + (21 * 4) + 0

        // r is at index 22 (first occurrence - used for all systems)
        let cp = get_glyph_codepoint('r', -1);
        assert_eq!(cp as u32, 0xE05A); // 0xE000 + (22 * 4) + 2

        // N is at index 32 (unique to Sargam uppercase)
        let cp = get_glyph_codepoint('N', 2);
        assert_eq!(cp as u32, 0xE081); // 0xE000 + (32 * 4) + 1
    }

    #[test]
    fn test_doremi_system() {
        // Note: Doremi system shares some lowercase characters with Western and Sargam
        // Lookup uses FIRST occurrence of each character

        // 'd' first appears at index 15 (Western lowercase), not 33 (Doremi)
        let cp = get_glyph_codepoint('d', 1);
        assert_eq!(cp as u32, 0xE03C); // 0xE000 + (15 * 4) + 0 = 57404

        // 'f' first appears at index 17 (Western lowercase), not 36 (Doremi)
        let cp = get_glyph_codepoint('f', -1);
        assert_eq!(cp as u32, 0xE046); // 0xE000 + (17 * 4) + 2 = 57414

        // 't' first appears at index 39 (Doremi lowercase) - unique
        let cp = get_glyph_codepoint('t', 2);
        assert_eq!(cp as u32, 0xE09D); // 0xE000 + (39 * 4) + 1 = 57501
    }

    #[test]
    fn test_all_number_characters_exist_in_font() {
        for ch in "1234567".chars() {
            let cp = get_glyph_codepoint(ch, 1);
            assert_ne!(cp, ch, "Character '{}' should have a PUA glyph", ch);
            assert!(cp as u32 >= 0xE000, "Codepoint for '{}' should be in PUA range", ch);
            assert!(cp as u32 <= 0xE0FF, "Codepoint for '{}' should be in PUA range", ch);
        }
    }

    #[test]
    fn test_character_order_completeness() {
        // Verify the character order string is not empty and has expected content
        assert!(!ALL_CHARS.is_empty());
        assert!(ALL_CHARS.contains('1'));
        assert!(ALL_CHARS.contains('C'));
        assert!(ALL_CHARS.contains('S'));
        assert!(ALL_CHARS.contains('d')); // Lowercase d (appears multiple times)
        assert!(ALL_CHARS.contains('T')); // Uppercase T (unique to Doremi)

        // Verify length matches expected: 7 + 14 + 12 + 14 = 47 unique chars
        // (some chars repeat, total length is 47 with duplicates)
        assert_eq!(ALL_CHARS.len(), 47);
    }

    // ===== Tests for sharp/flat accidental glyphs =====

    #[test]
    fn test_accidental_natural_returns_base_char() {
        assert_eq!(get_sharp_glyph_codepoint('1', 0), '1');
        assert_eq!(get_sharp_glyph_codepoint('1', b'n'), '1');
        assert_eq!(get_sharp_glyph_codepoint('C', 0), 'C');
        assert_eq!(get_sharp_glyph_codepoint('S', b'n'), 'S');
    }

    #[test]
    fn test_accidental_unknown_character_returns_base() {
        assert_eq!(get_sharp_glyph_codepoint('x', 1), 'x');
        assert_eq!(get_sharp_glyph_codepoint('!', 2), '!');
        assert_eq!(get_sharp_glyph_codepoint('∞', 3), '∞');
    }

    #[test]
    fn test_accidental_unknown_code_returns_base() {
        assert_eq!(get_sharp_glyph_codepoint('1', 99), '1'); // Invalid accidental code
        assert_eq!(get_sharp_glyph_codepoint('C', 255), 'C');
    }

    #[test]
    fn test_number_system_sharp() {
        // Character index 0: '1' at U+E1F0
        let cp = get_sharp_glyph_codepoint('1', 1);
        assert_eq!(cp as u32, 0xE1F0); // 0xE1F0 + 0

        // Character index 6: '7' at U+E1F6
        let cp = get_sharp_glyph_codepoint('7', b's');
        assert_eq!(cp as u32, 0xE1F6); // 0xE1F0 + 6
    }

    #[test]
    fn test_flat_not_in_font() {
        // Flat accidentals not yet in font, should return base character
        let cp = get_sharp_glyph_codepoint('1', 2);
        assert_eq!(cp, '1'); // Returns base char, not a glyph
    }

    #[test]
    fn test_double_sharp_not_in_font() {
        // Double sharp accidentals not yet in font, should return base character
        let cp = get_sharp_glyph_codepoint('7', b'x');
        assert_eq!(cp, '7'); // Returns base char, not a glyph
    }

    #[test]
    fn test_double_flat_not_in_font() {
        // Double flat accidentals not yet in font, should return base character
        let cp = get_sharp_glyph_codepoint('7', b'y');
        assert_eq!(cp, '7'); // Returns base char, not a glyph
    }

    #[test]
    fn test_western_system_sharp() {
        // C is at index 7: C# at U+E1F7
        let cp_sharp = get_sharp_glyph_codepoint('C', 1);
        assert_eq!(cp_sharp as u32, 0xE1F7); // 0xE1F0 + 7

        // B is at index 13: B# at U+E1FD
        let cp = get_sharp_glyph_codepoint('B', 1);
        assert_eq!(cp as u32, 0xE1FD); // 0xE1F0 + 13
    }

    #[test]
    fn test_all_number_characters_have_sharp_glyphs() {
        for ch in "1234567".chars() {
            let cp = get_sharp_glyph_codepoint(ch, 1);
            assert_ne!(cp, ch, "Character '{}' should have a sharp glyph", ch);
            assert!(cp as u32 >= 0xE1F0, "Sharp codepoint for '{}' should be in accidental range", ch);
            assert!(cp as u32 <= 0xE21E, "Sharp codepoint for '{}' should be in accidental range", ch);
        }
    }
}
