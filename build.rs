use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let atoms_path = PathBuf::from("tools/fontgen/atoms.yaml");

    // Tell Cargo to rebuild if atoms.yaml changes
    println!("cargo:rerun-if-changed=tools/fontgen/atoms.yaml");

    // Read and parse atoms.yaml
    let atoms_content = fs::read_to_string(&atoms_path)
        .expect("Failed to read atoms.yaml");

    let atoms: serde_yaml::Value = serde_yaml::from_str(&atoms_content)
        .expect("Failed to parse atoms.yaml as YAML");

    // Extract character order
    let char_order = atoms
        .get("character_order")
        .and_then(|v| v.as_str())
        .expect("character_order field not found in atoms.yaml");

    let char_count = char_order.len();

    // Extract PUA allocation
    let pua_start = atoms
        .get("pua")
        .and_then(|p| p.get("start"))
        .and_then(|v| {
            if let serde_yaml::Value::Number(n) = v {
                n.as_u64().map(|u| u as u32)
            } else if let serde_yaml::Value::String(s) = v {
                u32::from_str_radix(s.trim_start_matches("0x"), 16).ok()
            } else {
                None
            }
        })
        .unwrap_or(0xE000);

    // NOTE: Symbol codepoints are handled by the Python font generator (generate.py)
    // and available at runtime via NotationFont-map.json
    // build.rs only needs to generate constants for note atoms (pitch characters)

    // Count notation systems to generate per-system indices
    let systems = atoms
        .get("notation_systems")
        .and_then(|v| v.as_sequence())
        .expect("notation_systems not found in atoms.yaml");

    let mut system_info = String::new();
    let mut char_index = 0;
    let mut prev_system = "";

    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        let char_count_in_system = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .map(|seq| seq.len())
            .unwrap_or(0);

        // Create a marker comment for each system
        if prev_system != system_name {
            system_info.push_str(&format!("// {} system: indices {}", system_name, char_index));
            prev_system = system_name;
        }

        char_index += char_count_in_system;
        if char_index < char_order.len() {
            system_info.push_str(&format!("-{}\n", char_index - 1));
        }
    }

    // Generate font_constants.rs
    let code = format!(
        r#"/// Auto-generated font constants from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: tools/fontgen/atoms.yaml
/// Generated at compile time
///
/// NOTE: Symbol codepoints are handled dynamically via NotationFont-map.json
/// This file only contains constants for note atoms (pitch characters)

/// All pitch system characters in canonical order
/// This is the single source of truth from atoms.yaml character_order field
/// CRITICAL: This order must match the font generation and JSON mapping
///
/// Architecture:
/// - Noto Sans: Base font providing pitch character glyphs (1-7, A-Z, a-z)
/// - Noto Music: Provides SMuFL musical symbols (accidentals, barlines, ornaments)
pub const ALL_CHARS: &str = "{}";

/// Total number of characters across all notation systems
pub const TOTAL_CHARACTERS: usize = {};

/// Characters per octave variant (dots above/below)
/// Each character gets 4 variants: +1 octave, +2 octaves, -1 octave, -2 octaves
pub const CHARS_PER_VARIANT: u32 = 4;

/// Base codepoint for Private Use Area (PUA) - note octave variants
/// Allocated sequentially in PUA starting at this offset
/// Value from atoms.yaml pua.start (typically 0xE600)
///
/// Allocation: 0x{{PUA_START}} through 0x{{PUA_START}} + (47 chars Ã— 4 variants) - 1
pub const PUA_START: u32 = 0x{:X};

// System indices (for future per-system operations)
{}
"#,
        char_order,
        char_count,
        pua_start,
        system_info
    );

    // Write to OUT_DIR
    let dest_file = out_dir.join("font_constants.rs");
    fs::write(&dest_file, code).expect("Failed to write font_constants.rs");

    println!("cargo:warning=Generated font constants from atoms.yaml (Noto Sans + Noto Music)");
    println!("cargo:warning=  ALL_CHARS: {} ({} characters)", char_order, char_count);
    println!("cargo:warning=  PUA_START: 0x{:X} (note octave variants)", pua_start);
    println!("cargo:warning=  Symbols: Loaded from NotationFont.ttf via NotationFont-map.json at runtime");
}
