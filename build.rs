use std::env;
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let atoms_path = PathBuf::from("tools/fontgen/atoms.yaml");

    // Tell Cargo to rebuild if atoms.yaml changes
    println!("cargo:rerun-if-changed=tools/fontgen/atoms.yaml");

    // Read and parse atoms.yaml
    let atoms_content = fs::read_to_string(&atoms_path)
        .expect("Failed to read atoms.yaml");

    let atoms: serde_yaml::Value = serde_yaml::from_str(&atoms_content)
        .expect("Failed to parse atoms.yaml as YAML");

    // Extract character order
    let char_order = atoms
        .get("character_order")
        .and_then(|v| v.as_str())
        .expect("character_order field not found in atoms.yaml");

    let char_count = char_order.len();

    // Extract PUA allocation
    let pua_start = atoms
        .get("pua")
        .and_then(|p| p.get("start"))
        .and_then(|v| {
            if let serde_yaml::Value::Number(n) = v {
                n.as_u64().map(|u| u as u32)
            } else if let serde_yaml::Value::String(s) = v {
                u32::from_str_radix(s.trim_start_matches("0x"), 16).ok()
            } else {
                None
            }
        })
        .unwrap_or(0xE000);

    // NOTE: Symbol codepoints are handled by the Python font generator (generate.py)
    // and available at runtime via NotationFont-map.json
    // build.rs only needs to generate constants for note atoms (pitch characters)

    // Count notation systems to generate per-system indices
    let systems = atoms
        .get("notation_systems")
        .and_then(|v| v.as_sequence())
        .expect("notation_systems not found in atoms.yaml");

    let mut system_info = String::new();
    let mut char_index = 0;
    let mut prev_system = "";

    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        let char_count_in_system = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .map(|seq| seq.len())
            .unwrap_or(0);

        // Create a marker comment for each system
        if prev_system != system_name {
            system_info.push_str(&format!("// {} system: indices {}", system_name, char_index));
            prev_system = system_name;
        }

        char_index += char_count_in_system;
        if char_index < char_order.len() {
            system_info.push_str(&format!("-{}\n", char_index - 1));
        }
    }

    // Generate font_constants.rs
    let code = format!(
        r#"/// Auto-generated font constants from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: tools/fontgen/atoms.yaml
/// Generated at compile time
///
/// NOTE: Symbol codepoints are handled dynamically via NotationFont-map.json
/// This file only contains constants for note atoms (pitch characters)

/// All pitch system characters in canonical order
/// This is the single source of truth from atoms.yaml character_order field
/// CRITICAL: This order must match the font generation and JSON mapping
///
/// Architecture:
/// - Noto Sans: Base font providing pitch character glyphs (1-7, A-Z, a-z)
/// - Noto Music: Provides SMuFL musical symbols (accidentals, barlines, ornaments)
pub const ALL_CHARS: &str = "{}";

/// Total number of characters across all notation systems
pub const TOTAL_CHARACTERS: usize = {};

/// Characters per octave variant (dots above/below)
/// Each character gets 4 variants: +1 octave, +2 octaves, -1 octave, -2 octaves
pub const CHARS_PER_VARIANT: u32 = 4;

/// Base codepoint for Private Use Area (PUA) - note octave variants
/// Allocated sequentially in PUA starting at this offset
/// Value from atoms.yaml pua.start (typically 0xE600)
///
/// Allocation: 0x{{PUA_START}} through 0x{{PUA_START}} + (47 chars × 4 variants) - 1
pub const PUA_START: u32 = 0x{:X};

// System indices (for future per-system operations)
{}
"#,
        char_order,
        char_count,
        pua_start,
        system_info
    );

    // Write to OUT_DIR
    let dest_file = out_dir.join("font_constants.rs");
    fs::write(&dest_file, code).expect("Failed to write font_constants.rs");

    println!("cargo:warning=Generated font constants from atoms.yaml (Noto Sans + Noto Music)");
    println!("cargo:warning=  ALL_CHARS: {} ({} characters)", char_order, char_count);
    println!("cargo:warning=  PUA_START: 0x{:X} (note octave variants)", pua_start);
    println!("cargo:warning=  Symbols: Loaded from NotationFont.ttf via NotationFont-map.json at runtime");

    // Generate lookup tables
    generate_lookup_tables(&atoms, &out_dir, char_order, pua_start);
}

/// Generate dense lookup tables for (PitchCode, octave, PitchSystem) → char
fn generate_lookup_tables(atoms: &serde_yaml::Value, out_dir: &PathBuf, char_order: &str, pua_start: u32) {
    // Extract octave variants range
    let octave_start = atoms
        .get("octave_variants")
        .and_then(|v| v.get("start"))
        .and_then(|v| parse_hex(v))
        .unwrap_or(pua_start);

    // Build character index map
    let char_to_index: HashMap<char, usize> = char_order
        .chars()
        .enumerate()
        .map(|(i, c)| (c, i))
        .collect();

    // Define all 35 PitchCode variants in order
    let pitch_codes = vec![
        "N1", "N1s", "N1b", "N1ss", "N1bb",
        "N2", "N2s", "N2b", "N2ss", "N2bb",
        "N3", "N3s", "N3b", "N3ss", "N3bb",
        "N4", "N4s", "N4b", "N4ss", "N4bb",
        "N5", "N5s", "N5b", "N5ss", "N5bb",
        "N6", "N6s", "N6b", "N6ss", "N6bb",
        "N7", "N7s", "N7b", "N7ss", "N7bb",
    ];

    // Map PitchCode to base characters for each system
    // Number: 1-7
    // Western: c-b (lowercase)
    // Sargam: S, r, R, g, G, m, M, P, d, D, n, N
    // Doremi: d, r, m, f, s, l, t (lowercase)
    let number_chars = vec!['1', '2', '3', '4', '5', '6', '7'];
    let western_chars = vec!['c', 'd', 'e', 'f', 'g', 'a', 'b'];
    let sargam_chars = vec!['S', 'R', 'G', 'm', 'P', 'D', 'N'];
    let doremi_chars = vec!['d', 'r', 'm', 'f', 's', 'l', 't'];

    // Generate lookup tables for each system
    let mut code = String::from(
        r#"/// Auto-generated lookup tables from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: tools/fontgen/atoms.yaml

use crate::models::pitch_code::PitchCode;

// Constants
pub const OCTAVE_MIN: i8 = -2;
pub const OCTAVE_MAX: i8 = 2;
pub const OCTAVE_COUNT: usize = 5;
pub const PITCH_CODE_COUNT: usize = 35;

"#
    );

    // Generate pitch_code_index function
    code.push_str("/// Map PitchCode to array index (0-34)\n");
    code.push_str("pub fn pitch_code_index(p: PitchCode) -> usize {\n");
    code.push_str("    match p {\n");
    for (i, pc) in pitch_codes.iter().enumerate() {
        code.push_str(&format!("        PitchCode::{} => {},\n", pc, i));
    }
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Generate octave_index function
    code.push_str("/// Map octave shift to array index (0-4)\n");
    code.push_str("pub fn octave_index(o: i8) -> Option<usize> {\n");
    code.push_str("    if o < OCTAVE_MIN || o > OCTAVE_MAX {\n");
    code.push_str("        None\n");
    code.push_str("    } else {\n");
    code.push_str("        Some((o - OCTAVE_MIN) as usize)\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Generate dense 2D lookup tables for each pitch system
    for (system_name, base_chars) in [
        ("NUMBER", &number_chars),
        ("WESTERN", &western_chars),
        ("SARGAM", &sargam_chars),
        ("DOREMI", &doremi_chars),
    ] {
        code.push_str(&format!("/// {} system: [35 pitch codes][5 octaves]\n", system_name));
        code.push_str(&format!("pub static {}_TABLE: [[char; OCTAVE_COUNT]; PITCH_CODE_COUNT] = [\n", system_name));

        for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
            let degree = (pitch_idx / 5) as usize; // 0-6 (for 7 degrees)
            let base_char = base_chars[degree];

            code.push_str(&format!("    // PitchCode::{}\n", pitch_code));
            code.push_str("    [");

            // Generate code points for each octave: -2, -1, 0, +1, +2
            for octave in -2..=2 {
                let codepoint = calculate_codepoint(
                    pitch_code,
                    base_char,
                    octave,
                    &char_to_index,
                    octave_start,
                );
                code.push_str(&format!("'\\u{{{:04X}}}', ", codepoint));
            }

            code.push_str("],\n");
        }

        code.push_str("];\n\n");
    }

    // Generate reverse lookup functions (char → (PitchCode, octave))
    code.push_str("/// Reverse lookup: char → (PitchCode, i8) for each pitch system\n");
    code.push_str("/// Returns None if char is not a known pitch glyph\n\n");

    for (system_name, base_chars) in [
        ("NUMBER", &number_chars),
        ("WESTERN", &western_chars),
        ("SARGAM", &sargam_chars),
        ("DOREMI", &doremi_chars),
    ] {
        code.push_str(&format!("/// Reverse lookup for {} system\n", system_name));
        code.push_str(&format!("pub fn pitch_from_glyph_{}(ch: char) -> Option<(PitchCode, i8)> {{\n", system_name.to_lowercase()));
        code.push_str("    match ch {\n");

        // Generate match arms for each (pitch_code, octave) → char mapping
        for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
            let degree = (pitch_idx / 5) as usize;
            let base_char = base_chars[degree];

            for octave in -2..=2 {
                let codepoint = calculate_codepoint(
                    pitch_code,
                    base_char,
                    octave,
                    &char_to_index,
                    octave_start,
                );
                code.push_str(&format!(
                    "        '\\u{{{:04X}}}' => Some((PitchCode::{}, {})),\n",
                    codepoint, pitch_code, octave
                ));
            }
        }

        code.push_str("        _ => None,\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
    }

    // Write to OUT_DIR
    let dest_file = out_dir.join("font_lookup_tables.rs");
    fs::write(&dest_file, code).expect("Failed to write font_lookup_tables.rs");

    println!("cargo:warning=Generated lookup tables: 4 systems × 35 pitch codes × 5 octaves");
    println!("cargo:warning=Generated reverse lookups: 4 systems × 175 glyphs each");
}

/// Calculate the code point for a given (PitchCode, base_char, octave) combination
fn calculate_codepoint(
    pitch_code: &str,
    base_char: char,
    octave: i8,
    char_to_index: &HashMap<char, usize>,
    octave_start: u32,
) -> u32 {
    let char_index = char_to_index.get(&base_char).copied().unwrap_or(0) as u32;

    // Determine accidental type from PitchCode suffix
    let (accidental_type, has_accidental) = if pitch_code.ends_with("ss") {
        (3, true) // Double sharp
    } else if pitch_code.ends_with("bb") {
        (4, true) // Double flat
    } else if pitch_code.ends_with('s') {
        (1, true) // Sharp
    } else if pitch_code.ends_with('b') {
        (2, true) // Flat
    } else {
        (0, false) // Natural
    };

    // Calculate code point based on octave and accidental
    if octave == 0 && !has_accidental {
        // Base character (no octave shift, no accidental)
        return base_char as u32;
    } else if octave == 0 && has_accidental {
        // Accidental composite at base octave
        let pua_start = match accidental_type {
            1 => 0xE1F0, // Sharp
            2 => 0xE220, // Flat
            3 => 0xE250, // Double sharp
            4 => 0xE280, // Double flat
            _ => return base_char as u32,
        };
        return pua_start + char_index;
    } else if octave != 0 && !has_accidental {
        // Octave variant (no accidental)
        let variant_idx = match octave {
            1 => 0,  // +1 octave
            2 => 1,  // +2 octaves
            -1 => 2, // -1 octave
            -2 => 3, // -2 octaves
            _ => return base_char as u32,
        };
        return octave_start + (char_index * 4) + variant_idx;
    } else {
        // Combined accidental + octave
        let pua_start = match accidental_type {
            1 => 0xE2B0, // Sharp + octave
            2 => 0xE370, // Flat + octave
            3 => 0xE430, // Double sharp + octave
            4 => 0xE4F0, // Double flat + octave
            _ => return base_char as u32,
        };
        let variant_idx = match octave {
            1 => 0,  // +1 octave
            2 => 1,  // +2 octaves
            -1 => 2, // -1 octave
            -2 => 3, // -2 octaves
            _ => return base_char as u32,
        };
        return pua_start + (char_index * 4) + variant_idx;
    }
}

/// Parse hex value from YAML (handles both numbers and "0x..." strings)
fn parse_hex(v: &serde_yaml::Value) -> Option<u32> {
    if let serde_yaml::Value::Number(n) = v {
        n.as_u64().map(|u| u as u32)
    } else if let serde_yaml::Value::String(s) = v {
        u32::from_str_radix(s.trim_start_matches("0x"), 16).ok()
    } else {
        None
    }
}
