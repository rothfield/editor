use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let atoms_path = PathBuf::from("tools/fontgen/atoms.yaml");

    // Tell Cargo to rebuild if atoms.yaml changes
    println!("cargo:rerun-if-changed=tools/fontgen/atoms.yaml");

    // Read and parse atoms.yaml
    let atoms_content = fs::read_to_string(&atoms_path)
        .expect("Failed to read atoms.yaml");

    let atoms: serde_yaml::Value = serde_yaml::from_str(&atoms_content)
        .expect("Failed to parse atoms.yaml as YAML");

    // Extract character order
    let char_order = atoms
        .get("character_order")
        .and_then(|v| v.as_str())
        .expect("character_order field not found in atoms.yaml");

    let char_count = char_order.len();

    // Extract PUA allocation
    let pua_start = atoms
        .get("pua")
        .and_then(|p| p.get("start"))
        .and_then(|v| {
            if let serde_yaml::Value::Number(n) = v {
                n.as_u64().map(|u| u as u32)
            } else if let serde_yaml::Value::String(s) = v {
                u32::from_str_radix(s.trim_start_matches("0x"), 16).ok()
            } else {
                None
            }
        })
        .unwrap_or(0xE000);

    // Extract accidental PUA start (default to 0xE1F0)
    let accidental_start = 0xE1F0u32;

    // Count notation systems to generate per-system indices
    let systems = atoms
        .get("notation_systems")
        .and_then(|v| v.as_sequence())
        .expect("notation_systems not found in atoms.yaml");

    let mut system_info = String::new();
    let mut char_index = 0;
    let mut prev_system = "";

    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        let char_count_in_system = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .map(|seq| seq.len())
            .unwrap_or(0);

        // Create a marker comment for each system
        if prev_system != system_name {
            system_info.push_str(&format!("// {} system: indices {}", system_name, char_index));
            prev_system = system_name;
        }

        char_index += char_count_in_system;
        if char_index < char_order.len() {
            system_info.push_str(&format!("-{}\n", char_index - 1));
        }
    }

    // Generate font_constants.rs
    let code = format!(
        r#"/// Auto-generated font constants from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: tools/fontgen/atoms.yaml
/// Generated at compile time

/// All pitch system characters in canonical order
/// This is the single source of truth from atoms.yaml character_order field
/// CRITICAL: This order must match the font generation and JSON mapping
pub const ALL_CHARS: &str = "{}";

/// Total number of characters across all notation systems
pub const TOTAL_CHARACTERS: usize = {};

/// Characters per octave variant
pub const CHARS_PER_VARIANT: u32 = 4;

/// Base codepoint for Private Use Area (PUA) - note octave variants
/// Allocated sequentially in PUA to avoid conflicts with SMuFL standard codepoints
/// Value from atoms.yaml pua.start (typically 0xE600)
pub const PUA_START: u32 = 0x{:X};

/// Starting codepoint for accidental variants (sharp glyphs)
/// Located in SMuFL standard range U+E1F0 (NOT in PUA)
/// Range: 0xE1F0 - 0xE21E (47 chars for sharp accidentals)
pub const ACCIDENTAL_PUA_START: u32 = 0x{:X};

/// Symbols and musical articulations start here (SMuFL standard ranges)
/// Barlines: 0xE030-0xE042, Accidentals: 0xE260-0xE264, Ornaments: 0xE566-0xE56E
/// Value from atoms.yaml smufl_symbols (standard SMuFL codepoints)
pub const SYMBOLS_PUA_START: u32 = 0xE030;

// System indices (for future per-system operations)
{}
"#,
        char_order,
        char_count,
        pua_start,
        accidental_start,
        system_info
    );

    // Write to OUT_DIR
    let dest_file = out_dir.join("font_constants.rs");
    fs::write(&dest_file, code).expect("Failed to write font_constants.rs");

    println!("cargo:warning=Generated font constants from atoms.yaml");
    println!("cargo:warning=  ALL_CHARS: {} ({} chars)", char_order, char_count);
    println!("cargo:warning=  PUA_START: 0x{:X}", pua_start);
    println!("cargo:warning=  ACCIDENTAL_PUA_START: 0x{:X}", accidental_start);
}
