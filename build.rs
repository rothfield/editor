use std::env;
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let atoms_path = PathBuf::from("build/atoms.yaml");

    // Tell Cargo to rebuild if atoms.yaml changes
    println!("cargo:rerun-if-changed=build/atoms.yaml");

    // Read and parse atoms.yaml
    let atoms_content = fs::read_to_string(&atoms_path)
        .expect("Failed to read atoms.yaml");

    let atoms: serde_yaml::Value = serde_yaml::from_str(&atoms_content)
        .expect("Failed to parse atoms.yaml as YAML");

    // Generate font constants with new per-system architecture
    generate_font_constants(&atoms, &out_dir);

    // Generate per-system lookup tables
    generate_lookup_tables(&atoms, &out_dir);

    // NEW: Generate fontspec.json for Python consumption
    generate_fontspec_json(&atoms, &out_dir);
}

/// Generate font constants from per-system notation systems
fn generate_font_constants(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    // Configuration for 30-variant system with accidentals
    const _ACCIDENTAL_TYPES: usize = 6; // natural, flat, half-flat, double-flat, sharp, double-sharp
    const _OCTAVE_VARIANTS: usize = 5;  // 5 octave patterns: 0, -2, -1, +1, +2
    const VARIANTS_PER_CHAR: usize = 30; // 6 accidentals × 5 octave variants

    let systems = atoms
        .get("notation_systems")
        .and_then(|v| v.as_sequence())
        .expect("notation_systems not found in atoms.yaml");

    let mut system_constants = String::new();

    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_uppercase();

        let pua_base = system
            .get("pua_base")
            .and_then(|v| parse_hex(v))
            .unwrap_or(0xE000);

        let char_count = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .map(|seq| seq.len())
            .unwrap_or(0);

        // NEW LAYOUT: group-by-accidental-then-octave
        // Each character gets VARIANTS_PER_CHAR codepoints:
        // - ACCIDENTAL_TYPES accidental types (natural, flat, double-flat, sharp, double-sharp)
        // - OCTAVE_VARIANTS octaves each (0, -2, -1, +1, +2)
        let total_glyphs = char_count * VARIANTS_PER_CHAR;

        system_constants.push_str(&format!(
            "pub const {}_PUA_BASE: u32 = 0x{:X};\n",
            system_name, pua_base
        ));
        system_constants.push_str(&format!(
            "pub const {}_CHAR_COUNT: usize = {};\n",
            system_name, char_count
        ));
        system_constants.push_str(&format!(
            "pub const {}_TOTAL_GLYPHS: usize = {};\n",
            system_name, total_glyphs
        ));
    }

    let code = format!(
        r#"/// Auto-generated font constants from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: build/atoms.yaml
/// Generated at compile time
///
/// ARCHITECTURE: Separate PUA blocks per notation system
/// Each notation system has its own contiguous PUA block to ensure character isolation.
/// Example: D(Western) ≠ D(Sargam) ≠ D(Doremi)

/// Variants per character across all systems (30-variant system with accidentals)
/// Each character gets 30 codepoints for accidental + octave combinations:
/// - Variants 0-4: Natural with octave dots (0, -2, -1, +1, +2)
/// - Variants 5-9: Flat with octave dots (0, -2, -1, +1, +2)
/// - Variants 10-14: Half-flat with octave dots (0, -2, -1, +1, +2)
/// - Variants 15-19: Double-flat with octave dots (0, -2, -1, +1, +2)
/// - Variants 20-24: Sharp with octave dots (0, -2, -1, +1, +2)
/// - Variants 25-29: Double-sharp with octave dots (0, -2, -1, +1, +2)
///
/// Layout within a system with N characters:
/// - Characters 0 to N-1: Each has 30 variants (6 accidentals × 5 octaves)
pub const VARIANTS_PER_CHARACTER: usize = 30;

// Per-system PUA allocation constants
{}
"#,
        system_constants
    );

    let dest_file = out_dir.join("font_constants.rs");
    fs::write(&dest_file, code).expect("Failed to write font_constants.rs");
}

/// Generate per-system lookup tables from notation_systems
fn generate_lookup_tables(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    let systems = atoms
        .get("notation_systems")
        .and_then(|v| v.as_sequence())
        .expect("notation_systems not found in atoms.yaml");

    let mut code = String::from(
        r#"/// Auto-generated per-system lookup tables from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: build/atoms.yaml
/// Architecture: Separate PUA blocks per notation system
///
/// Formula per system: codepoint = system_base + (char_index × 30) + variant_index
/// Where variant_index (0-29) represents accidental+octave combinations:
///   variant_index = (accidental_type × 5) + octave_idx
///   accidental_type: 0=natural, 1=flat, 2=half-flat, 3=double-flat, 4=double-sharp, 5=sharp
///   octave_idx: 0=base, 1=-2, 2=-1, 3=+1, 4=+2

use crate::models::pitch_code::PitchCode;

// Constants
pub const OCTAVE_MIN: i8 = -2;
pub const OCTAVE_MAX: i8 = 2;
pub const OCTAVE_COUNT: usize = 5;
pub const PITCH_CODE_COUNT: usize = 42;

/// Map PitchCode to array index (0-41)
pub fn pitch_code_index(p: PitchCode) -> usize {
    match p {
        PitchCode::N1 => 0,
        PitchCode::N1s => 1,
        PitchCode::N1b => 2,
        PitchCode::N1hf => 3,
        PitchCode::N1ss => 4,
        PitchCode::N1bb => 5,
        PitchCode::N2 => 6,
        PitchCode::N2s => 7,
        PitchCode::N2b => 8,
        PitchCode::N2hf => 9,
        PitchCode::N2ss => 10,
        PitchCode::N2bb => 11,
        PitchCode::N3 => 12,
        PitchCode::N3s => 13,
        PitchCode::N3b => 14,
        PitchCode::N3hf => 15,
        PitchCode::N3ss => 16,
        PitchCode::N3bb => 17,
        PitchCode::N4 => 18,
        PitchCode::N4s => 19,
        PitchCode::N4b => 20,
        PitchCode::N4hf => 21,
        PitchCode::N4ss => 22,
        PitchCode::N4bb => 23,
        PitchCode::N5 => 24,
        PitchCode::N5s => 25,
        PitchCode::N5b => 26,
        PitchCode::N5hf => 27,
        PitchCode::N5ss => 28,
        PitchCode::N5bb => 29,
        PitchCode::N6 => 30,
        PitchCode::N6s => 31,
        PitchCode::N6b => 32,
        PitchCode::N6hf => 33,
        PitchCode::N6ss => 34,
        PitchCode::N6bb => 35,
        PitchCode::N7 => 36,
        PitchCode::N7s => 37,
        PitchCode::N7b => 38,
        PitchCode::N7hf => 39,
        PitchCode::N7ss => 40,
        PitchCode::N7bb => 41,
    }
}

/// Map octave shift to array index (0-4)
/// Maps to position in lookup table ordered as [0, -2, -1, +1, +2]
/// (must match generate.py line 316 octave_order)
pub fn octave_index(o: i8) -> Option<usize> {
    match o {
        0 => Some(0),    // Octave 0 (base) → index 0
        -2 => Some(1),   // Octave -2 → index 1
        -1 => Some(2),   // Octave -1 → index 2
        1 => Some(3),    // Octave +1 → index 3
        2 => Some(4),    // Octave +2 → index 4
        _ => None,
    }
}

"#
    );

    // Generate lookup tables for each notation system
    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        let system_name_upper = system_name.to_uppercase();
        let pua_base = system
            .get("pua_base")
            .and_then(|v| parse_hex(v))
            .unwrap_or(0xE000);

        let characters = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .expect(&format!("No characters in {} system", system_name));

        // Build character-to-index map for this system
        let mut char_to_index: HashMap<char, usize> = HashMap::new();
        for (idx, char_entry) in characters.iter().enumerate() {
            if let Some(ch) = char_entry.get("char").and_then(|v| v.as_str()) {
                if let Some(c) = ch.chars().next() {
                    char_to_index.insert(c, idx);
                }
            }
        }

        // Generate system-specific lookup table
        // CRITICAL: Must use same octave order as generate.py (line 316)
        // Order: [0, -2, -1, 1, 2] - NOT [-2, -1, 0, 1, 2]
        generate_system_lookup_table(
            &mut code,
            &system_name_upper,
            pua_base,
            &char_to_index,
            &characters,
        );
    }

    let dest_file = out_dir.join("font_lookup_tables.rs");
    fs::write(&dest_file, code).expect("Failed to write font_lookup_tables.rs");
}

/// Generate lookup table for a single notation system
fn generate_system_lookup_table(
    code: &mut String,
    system_name_upper: &str,
    pua_base: u32,
    char_to_index: &HashMap<char, usize>,
    characters: &[serde_yaml::Value],
) {
    let is_sargam = system_name_upper == "SARGAM";
    let num_chars = characters.len() as u32;
    let pitch_codes = vec![
        "N1", "N1s", "N1b", "N1hf", "N1ss", "N1bb",
        "N2", "N2s", "N2b", "N2hf", "N2ss", "N2bb",
        "N3", "N3s", "N3b", "N3hf", "N3ss", "N3bb",
        "N4", "N4s", "N4b", "N4hf", "N4ss", "N4bb",
        "N5", "N5s", "N5b", "N5hf", "N5ss", "N5bb",
        "N6", "N6s", "N6b", "N6hf", "N6ss", "N6bb",
        "N7", "N7s", "N7b", "N7hf", "N7ss", "N7bb",
    ];

    // Generate lookup table
    code.push_str(&format!(
        "/// {} system: [42 pitch codes][5 octaves]\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "/// PUA base: 0x{:X}, Octave order: [0, -2, -1, +1, +2] (matches generate.py line 316)\n",
        pua_base
    ));
    code.push_str(&format!(
        "pub static {}_TABLE: [[char; OCTAVE_COUNT]; PITCH_CODE_COUNT] = [\n",
        system_name_upper
    ));

    for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
        let degree = (pitch_idx / 6) as usize; // 0-6 for 7 degrees (6 accidentals per degree)

        // Get the base character for this degree/pitch code
        // For Sargam, use special mapping based on pitch code (komal/shuddha)
        let base_char = if is_sargam {
            get_sargam_char(pitch_code)
        } else {
            // Other systems: use sequential character order by degree
            if let Some(char_entry) = characters.get(degree) {
                if let Some(ch_str) = char_entry.get("char").and_then(|v| v.as_str()) {
                    ch_str.chars().next().unwrap_or('?')
                } else {
                    '?'
                }
            } else {
                '?'
            }
        };

        code.push_str(&format!("    // {} (degree {}, char '{}')\n", pitch_code, degree, base_char));
        code.push_str("    [");

        // Generate codepoints for each octave, in SAME ORDER as generate.py (line 316)
        // Order: 0, -2, -1, +1, +2 (NOT -2, -1, 0, +1, +2)
        // This must match generate.py's octave_order = [0, -2, -1, 1, 2]
        for octave in [0, -2, -1, 1, 2].iter().copied() {
            let codepoint = calculate_system_codepoint(
                pitch_code,
                base_char,
                octave,
                char_to_index,
                pua_base,
                num_chars,
            );
            code.push_str(&format!("'\\u{{{:04X}}}', ", codepoint));
        }

        code.push_str("],\n");
    }

    code.push_str("];\n\n");

    // Generate reverse lookup function
    code.push_str(&format!(
        "/// Reverse lookup for {} system: char → (PitchCode, i8)\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "pub fn pitch_from_glyph_{}(ch: char) -> Option<(PitchCode, i8)> {{\n",
        system_name_upper.to_lowercase()
    ));
    code.push_str("    match ch {\n");

    for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
        let degree = (pitch_idx / 6) as usize; // 6 accidentals per degree

        // Get the base character for this degree/pitch code
        // For Sargam, use special mapping based on pitch code (komal/shuddha)
        let base_char = if is_sargam {
            get_sargam_char(pitch_code)
        } else {
            // Other systems: use sequential character order by degree
            if let Some(char_entry) = characters.get(degree) {
                if let Some(ch_str) = char_entry.get("char").and_then(|v| v.as_str()) {
                    ch_str.chars().next().unwrap_or('?')
                } else {
                    '?'
                }
            } else {
                '?'
            }
        };

        // CRITICAL: Same octave order as forward lookup
        // Order: 0, -2, -1, +1, +2 (matches generate.py line 316)
        for octave in [0, -2, -1, 1, 2].iter().copied() {
            let codepoint = calculate_system_codepoint(
                pitch_code,
                base_char,
                octave,
                char_to_index,
                pua_base,
                num_chars,
            );

            // All codepoints are valid in new fully-PUA architecture
            // (octave 0 naturals are now in PUA, not ASCII)

            code.push_str(&format!(
                "        '\\u{{{:04X}}}' => Some((PitchCode::{}, {})),\n",
                codepoint, pitch_code, octave
            ));
        }
    }

    // Add ASCII characters for octave 0 (for backward compatibility with test inputs like "1 2 3")
    // Only add naturals (no accidentals) - these are the base input characters
    for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
        // Only process naturals (every 6th pitch code)
        if pitch_idx % 6 == 0 {
            let degree = (pitch_idx / 6) as usize;
            if let Some(char_entry) = characters.get(degree) {
                if let Some(ch_str) = char_entry.get("char").and_then(|v| v.as_str()) {
                    if let Some(base_char) = ch_str.chars().next() {
                        // Map ASCII character to (PitchCode, octave=0)
                        code.push_str(&format!(
                            "        '{}' => Some((PitchCode::{}, 0)),\n",
                            base_char, pitch_code
                        ));
                    }
                }
            }
        }
    }

    code.push_str("        _ => None,\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
}

/// Map PitchCode to Sargam character (case-sensitive for komal/shuddha)
/// Sargam uses uppercase for shuddha (natural) and lowercase for komal (flat)
fn get_sargam_char(pitch_code: &str) -> char {
    match pitch_code {
        // N1 (Sa) - always uppercase, no komal
        "N1" | "N1s" | "N1b" | "N1hf" | "N1ss" | "N1bb" => 'S',

        // N2 (Re) - uppercase for shuddha, lowercase for komal
        "N2" | "N2s" | "N2hf" | "N2ss" | "N2bb" => 'R',
        "N2b" => 'r', // komal Re

        // N3 (Ga) - uppercase for shuddha, lowercase for komal
        "N3" | "N3s" | "N3hf" | "N3ss" | "N3bb" => 'G',
        "N3b" => 'g', // komal Ga

        // N4 (ma) - lowercase for shuddha, uppercase for tivra
        "N4" | "N4b" | "N4hf" | "N4bb" => 'm',
        "N4s" | "N4ss" => 'M', // tivra Ma

        // N5 (Pa) - always uppercase, no komal
        "N5" | "N5s" | "N5b" | "N5hf" | "N5ss" | "N5bb" => 'P',

        // N6 (Dha) - uppercase for shuddha, lowercase for komal
        "N6" | "N6s" | "N6hf" | "N6ss" | "N6bb" => 'D',
        "N6b" => 'd', // komal Dha

        // N7 (Ni) - uppercase for shuddha, lowercase for komal
        "N7" | "N7s" | "N7hf" | "N7ss" | "N7bb" => 'N',
        "N7b" => 'n', // komal Ni

        _ => '?',
    }
}

/// Calculate codepoint for (PitchCode, base_char, octave) in a specific notation system
///
/// NEW ARCHITECTURE: 30 variants per character
/// Each character gets 30 consecutive codepoints for all accidental+octave combinations
/// - Variants 0-4: Natural (octave 0, -2, -1, +1, +2)
/// - Variants 5-9: Flat (octave 0, -2, -1, +1, +2)
/// - Variants 10-14: Half-flat (octave 0, -2, -1, +1, +2)
/// - Variants 15-19: Double-flat (octave 0, -2, -1, +1, +2)
/// - Variants 20-24: Double-sharp (octave 0, -2, -1, +1, +2)
/// - Variants 25-29: Sharp (octave 0, -2, -1, +1, +2)
///
/// Formula: pua_base + (char_idx × 30) + variant_index
///   where variant_index = (accidental_type × 5) + octave_idx
fn calculate_system_codepoint(
    pitch_code: &str,
    base_char: char,
    octave: i8,
    char_to_index: &HashMap<char, usize>,
    pua_base: u32,
    _num_chars: u32,
) -> u32 {
    let char_idx = char_to_index.get(&base_char).copied().unwrap_or(0) as u32;

    // Determine accidental type from PitchCode suffix
    let accidental_type = if pitch_code.ends_with("ss") {
        4 // Double sharp
    } else if pitch_code.ends_with("bb") {
        3 // Double flat
    } else if pitch_code.ends_with("hf") {
        2 // Half flat
    } else if pitch_code.ends_with('s') {
        5 // Sharp
    } else if pitch_code.ends_with('b') {
        1 // Flat
    } else {
        0 // Natural
    };

    // Map octave to index: 0->0, -2->1, -1->2, +1->3, +2->4
    let octave_idx = match octave {
        0 => 0,
        -2 => 1,
        -1 => 2,
        1 => 3,
        2 => 4,
        _ => return base_char as u32, // Out of range
    };

    // NEW ARCHITECTURE: 30 variants per character
    // Formula: pua_base + (char_idx × 30) + variant_index
    // where variant_index = (accidental_type × 5) + octave_idx

    const VARIANTS_PER_CHARACTER: u32 = 30; // 6 accidentals × 5 octaves
    let variant_index = (accidental_type * 5) + octave_idx as u32;

    pua_base + (char_idx * VARIANTS_PER_CHARACTER) + variant_index
}

/// Parse hex value from YAML (handles both numbers and "0x..." strings)
fn parse_hex(v: &serde_yaml::Value) -> Option<u32> {
    if let serde_yaml::Value::Number(n) = v {
        n.as_u64().map(|u| u as u32)
    } else if let serde_yaml::Value::String(s) = v {
        u32::from_str_radix(s.trim_start_matches("0x"), 16).ok()
    } else {
        None
    }
}

/// Generate fontspec.json for Python font generator
///
/// This creates the canonical FontSpec in JSON format that Python
/// will consume to generate the actual font files.
fn generate_fontspec_json(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    // Extract notation systems
    let mut notation_systems = Vec::new();

    // Calculate PUA bases for each system (30 variants per character)
    const VARIANTS_PER_CHAR: u32 = 30;  // 6 accidentals × 5 octaves
    let mut current_pua_base = 0xE000u32;

    if let Some(systems) = atoms.get("notation_systems")
        .and_then(|v| v.as_sequence()) {
        for system in systems {
            let system_name = system
                .get("system_name")
                .and_then(|v| v.as_str())
                .unwrap_or("unknown")
                .to_string();

            let characters = system
                .get("characters")
                .and_then(|v| v.as_sequence())
                .map(|seq| {
                    seq.iter()
                        .filter_map(|char_value| {
                            char_value
                                .get("char")
                                .and_then(|v| v.as_str())
                                .and_then(|s| s.chars().next())
                        })
                        .collect::<Vec<_>>()
                })
                .unwrap_or_default();

            // Use per-system PUA base if specified, otherwise use calculated sequential base
            let pua_base = system
                .get("pua_base")
                .and_then(|v| parse_hex(v))
                .unwrap_or(current_pua_base);

            notation_systems.push(serde_json::json!({
                "name": system_name,
                "characters": characters,
                "pua_base": pua_base,
                "variants_per_char": VARIANTS_PER_CHAR
            }));

            // Calculate next PUA base (current + num_chars * variants_per_char)
            current_pua_base += (characters.len() as u32) * VARIANTS_PER_CHAR;
        }
    }

    // Extract glyph variants (30-variant system with accidentals)
    let mut accidental_types = 6;  // natural, flat, half-flat, double-flat, sharp, double-sharp
    let mut octave_variants = 5;   // 5 octave patterns (0, -2, -1, +1, +2)

    if let Some(glyph_variants) = atoms.get("glyph_variants") {
        if let Some(acc_types) = glyph_variants.get("accidental_types")
            .and_then(|v| v.as_u64()) {
            accidental_types = acc_types as usize;
        }
        if let Some(oct_variants) = glyph_variants.get("octave_variants")
            .and_then(|v| v.as_u64()) {
            octave_variants = oct_variants as usize;
        }
    }

    // Build FontSpec JSON
    let fontspec = serde_json::json!({
        "notation_systems": notation_systems,
        "glyph_variants": {
            "accidental_types": accidental_types,
            "octave_variants": octave_variants
        }
    });

    // Write fontspec.json to OUT_DIR (for Rust to consume during tests/builds)
    let fontspec_path = out_dir.join("fontspec.json");
    let json_str = serde_json::to_string_pretty(&fontspec)
        .expect("Failed to serialize FontSpec to JSON");

    fs::write(&fontspec_path, &json_str)
        .expect("Failed to write fontspec.json");

    // Also write to tools/fontgen/fontspec.json for Python consumption
    let python_fontspec_path = PathBuf::from("tools/fontgen/fontspec.json");
    fs::write(&python_fontspec_path, &json_str)
        .expect("Failed to write tools/fontgen/fontspec.json");
}
