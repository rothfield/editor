use std::env;
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    // Single source of truth: tools/fontgen/atoms.yaml
    let atoms_path = PathBuf::from("tools/fontgen/atoms.yaml");

    // Tell Cargo to rebuild if atoms.yaml changes
    println!("cargo:rerun-if-changed=tools/fontgen/atoms.yaml");

    // Read and parse atoms.yaml
    let atoms_content = fs::read_to_string(&atoms_path)
        .expect("Failed to read atoms.yaml");

    let atoms: serde_yaml::Value = serde_yaml::from_str(&atoms_content)
        .expect("Failed to parse atoms.yaml as YAML");

    // Generate font constants with new per-system architecture
    generate_font_constants(&atoms, &out_dir);

    // Generate per-system lookup tables
    generate_lookup_tables(&atoms, &out_dir);

    // Generate fontspec.json for Python consumption
    generate_fontspec_json(&atoms, &out_dir);

    // Generate measurement system configs for getFontConfig()
    generate_measurement_systems(&atoms, &out_dir);

    // Generate superscript lookup tables for ornament rendering
    generate_superscript_tables(&atoms, &out_dir);

    // Generate beat element predicates from atoms.yaml
    generate_beat_element_predicates(&atoms, &out_dir);
}

/// Generate font constants from per-system notation systems
fn generate_font_constants(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    // Configuration for 30-variant system with accidentals
    const _ACCIDENTAL_TYPES: usize = 6; // natural, flat, half-flat, double-flat, sharp, double-sharp
    const _OCTAVE_VARIANTS: usize = 5;  // 5 octave patterns: 0, -2, -1, +1, +2
    const VARIANTS_PER_CHAR: usize = 30; // 6 accidentals × 5 octave variants

    let systems = atoms
        .get("notation_systems")
        .and_then(|v| v.as_sequence())
        .expect("notation_systems not found in atoms.yaml");

    let mut system_constants = String::new();

    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_uppercase();

        let pua_base = system
            .get("pua_base")
            .and_then(|v| parse_hex(v))
            .unwrap_or(0xE000);

        let char_count = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .map(|seq| seq.len())
            .unwrap_or(0);

        // NEW LAYOUT: group-by-accidental-then-octave
        // Each character gets VARIANTS_PER_CHAR codepoints:
        // - ACCIDENTAL_TYPES accidental types (natural, flat, double-flat, sharp, double-sharp)
        // - OCTAVE_VARIANTS octaves each (0, -2, -1, +1, +2)
        let total_glyphs = char_count * VARIANTS_PER_CHAR;

        system_constants.push_str(&format!(
            "pub const {}_PUA_BASE: u32 = 0x{:X};\n",
            system_name, pua_base
        ));
        system_constants.push_str(&format!(
            "pub const {}_CHAR_COUNT: usize = {};\n",
            system_name, char_count
        ));
        system_constants.push_str(&format!(
            "pub const {}_TOTAL_GLYPHS: usize = {};\n",
            system_name, total_glyphs
        ));
    }

    let code = format!(
        r#"/// Auto-generated font constants from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: build/atoms.yaml
/// Generated at compile time
///
/// ARCHITECTURE: Separate PUA blocks per notation system
/// Each notation system has its own contiguous PUA block to ensure character isolation.
/// Example: D(Western) ≠ D(Sargam) ≠ D(Doremi)

/// Variants per character across all systems (30-variant system with accidentals)
/// Each character gets 30 codepoints for accidental + octave combinations:
/// - Variants 0-4: Natural with octave dots (0, -2, -1, +1, +2)
/// - Variants 5-9: Flat with octave dots (0, -2, -1, +1, +2)
/// - Variants 10-14: Half-flat with octave dots (0, -2, -1, +1, +2)
/// - Variants 15-19: Double-flat with octave dots (0, -2, -1, +1, +2)
/// - Variants 20-24: Sharp with octave dots (0, -2, -1, +1, +2)
/// - Variants 25-29: Double-sharp with octave dots (0, -2, -1, +1, +2)
///
/// Layout within a system with N characters:
/// - Characters 0 to N-1: Each has 30 variants (6 accidentals × 5 octaves)
pub const VARIANTS_PER_CHARACTER: usize = 30;

// Per-system PUA allocation constants
{}
"#,
        system_constants
    );

    let dest_file = out_dir.join("font_constants.rs");
    fs::write(&dest_file, code).expect("Failed to write font_constants.rs");
}

/// Generate per-system lookup tables from notation_systems
fn generate_lookup_tables(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    let systems = atoms
        .get("notation_systems")
        .and_then(|v| v.as_sequence())
        .expect("notation_systems not found in atoms.yaml");

    let mut code = String::from(
        r#"/// Auto-generated per-system lookup tables from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: build/atoms.yaml
/// Architecture: Separate PUA blocks per notation system
///
/// Formula per system: codepoint = system_base + (char_index × 30) + variant_index
/// Where variant_index (0-29) represents accidental+octave combinations:
///   variant_index = (accidental_type × 5) + octave_idx
///   accidental_type: 0=natural, 1=flat, 2=half-flat, 3=double-flat, 4=double-sharp, 5=sharp
///   octave_idx: 0=base, 1=-2, 2=-1, 3=+1, 4=+2

use crate::models::pitch_code::PitchCode;

// Constants
pub const OCTAVE_MIN: i8 = -2;
pub const OCTAVE_MAX: i8 = 2;
pub const OCTAVE_COUNT: usize = 5;
pub const PITCH_CODE_COUNT: usize = 42;

/// Map PitchCode to array index (0-41)
pub fn pitch_code_index(p: PitchCode) -> usize {
    match p {
        PitchCode::N1 => 0,
        PitchCode::N1s => 1,
        PitchCode::N1b => 2,
        PitchCode::N1hf => 3,
        PitchCode::N1ss => 4,
        PitchCode::N1bb => 5,
        PitchCode::N2 => 6,
        PitchCode::N2s => 7,
        PitchCode::N2b => 8,
        PitchCode::N2hf => 9,
        PitchCode::N2ss => 10,
        PitchCode::N2bb => 11,
        PitchCode::N3 => 12,
        PitchCode::N3s => 13,
        PitchCode::N3b => 14,
        PitchCode::N3hf => 15,
        PitchCode::N3ss => 16,
        PitchCode::N3bb => 17,
        PitchCode::N4 => 18,
        PitchCode::N4s => 19,
        PitchCode::N4b => 20,
        PitchCode::N4hf => 21,
        PitchCode::N4ss => 22,
        PitchCode::N4bb => 23,
        PitchCode::N5 => 24,
        PitchCode::N5s => 25,
        PitchCode::N5b => 26,
        PitchCode::N5hf => 27,
        PitchCode::N5ss => 28,
        PitchCode::N5bb => 29,
        PitchCode::N6 => 30,
        PitchCode::N6s => 31,
        PitchCode::N6b => 32,
        PitchCode::N6hf => 33,
        PitchCode::N6ss => 34,
        PitchCode::N6bb => 35,
        PitchCode::N7 => 36,
        PitchCode::N7s => 37,
        PitchCode::N7b => 38,
        PitchCode::N7hf => 39,
        PitchCode::N7ss => 40,
        PitchCode::N7bb => 41,
    }
}

/// Map octave shift to array index (0-4)
/// Maps to position in lookup table ordered as [0, -2, -1, +1, +2]
/// (must match generate.py line 316 octave_order)
pub fn octave_index(o: i8) -> Option<usize> {
    match o {
        0 => Some(0),    // Octave 0 (base) → index 0
        -2 => Some(1),   // Octave -2 → index 1
        -1 => Some(2),   // Octave -1 → index 2
        1 => Some(3),    // Octave +1 → index 3
        2 => Some(4),    // Octave +2 → index 4
        _ => None,
    }
}

"#
    );

    // Generate lookup tables for each notation system
    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        let system_name_upper = system_name.to_uppercase();
        let pua_base = system
            .get("pua_base")
            .and_then(|v| parse_hex(v))
            .unwrap_or(0xE000);

        let characters = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .expect(&format!("No characters in {} system", system_name));

        // Build character-to-index map for this system
        let mut char_to_index: HashMap<char, usize> = HashMap::new();
        for (idx, char_entry) in characters.iter().enumerate() {
            if let Some(ch) = char_entry.get("char").and_then(|v| v.as_str()) {
                if let Some(c) = ch.chars().next() {
                    char_to_index.insert(c, idx);
                }
            }
        }

        // Generate system-specific lookup table
        // CRITICAL: Must use same octave order as generate.py (line 316)
        // Order: [0, -2, -1, 1, 2] - NOT [-2, -1, 0, 1, 2]
        generate_system_lookup_table(
            &mut code,
            &system_name_upper,
            pua_base,
            &char_to_index,
            &characters,
        );
    }

    // Generate underlined lookup tables (parallel to base tables)
    // Underlined PUA bases from atoms.yaml underlined_notes section
    let underlined_bases: HashMap<u32, u32> = [
        (0xE000, 0x16000), // Number
        (0xE100, 0x16100), // Western
        (0xE300, 0x16300), // Sargam
        (0xE500, 0x16500), // Doremi
    ].iter().cloned().collect();

    code.push_str("// =============================================================================\n");
    code.push_str("// UNDERLINED LOOKUP TABLES (for beat grouping display)\n");
    code.push_str("// Same structure as base tables, just with underlined PUA range\n");
    code.push_str("// =============================================================================\n\n");

    for system in systems {
        let system_name = system
            .get("system_name")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        let system_name_upper = system_name.to_uppercase();
        let pua_base = system
            .get("pua_base")
            .and_then(|v| parse_hex(v))
            .unwrap_or(0xE000);

        let characters = system
            .get("characters")
            .and_then(|v| v.as_sequence())
            .expect(&format!("No characters in {} system", system_name));

        // Build character-to-index map for this system
        let mut char_to_index: HashMap<char, usize> = HashMap::new();
        for (idx, char_entry) in characters.iter().enumerate() {
            if let Some(ch) = char_entry.get("char").and_then(|v| v.as_str()) {
                if let Some(c) = ch.chars().next() {
                    char_to_index.insert(c, idx);
                }
            }
        }

        // Get underlined base for this system
        if let Some(&underlined_base) = underlined_bases.get(&pua_base) {
            generate_underlined_lookup_table(
                &mut code,
                &system_name_upper,
                underlined_base,
                &char_to_index,
                &characters,
            );
        }
    }

    // Add underlined glyph lookup function
    code.push_str(r#"
/// Get underlined glyph for a pitch code and octave
/// Returns the glyph from the appropriate underlined system table
pub fn underlined_glyph_for_pitch(
    pitch: PitchCode,
    octave: i8,
    system: crate::models::elements::PitchSystem,
) -> Option<char> {
    let pi = pitch_code_index(pitch);
    let oi = octave_index(octave)?;

    Some(match system {
        crate::models::elements::PitchSystem::Number => NUMBER_UNDERLINED_TABLE[pi][oi],
        crate::models::elements::PitchSystem::Western => WESTERN_UNDERLINED_TABLE[pi][oi],
        crate::models::elements::PitchSystem::Sargam => SARGAM_UNDERLINED_TABLE[pi][oi],
        // Doremi, Bhatkhande, Tabla not yet implemented - use Number as fallback
        _ => NUMBER_UNDERLINED_TABLE[pi][oi],
    })
}

/// Bracket position for underlined note groups
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum BracketPosition {
    Middle,  // Inside group (no arc endpoints)
    Left,    // Start of group (left arc)
    Right,   // End of group (right arc)
}

/// Underlined note bracket system configuration
/// Maps underlined glyph ranges to bracket variant ranges
struct UnderlinedBracketSystem {
    underlined_start: u32,  // Start of underlined range (e.g., 0x16000)
    underlined_end: u32,    // End of underlined range (exclusive)
    bracket_base: u32,      // Base of bracket variants for this system
    count: u32,             // Number of underlined glyphs in this system
}

/// All underlined bracket systems (generated from atoms.yaml)
/// Layout: left = bracket_base + offset, right = bracket_base + count + offset
const UNDERLINED_BRACKET_SYSTEMS: &[UnderlinedBracketSystem] = &[
    UnderlinedBracketSystem { underlined_start: 0x16000, underlined_end: 0x160D1, bracket_base: 0x17000, count: 210 },  // number: 1234567
    UnderlinedBracketSystem { underlined_start: 0x16100, underlined_end: 0x161D1, bracket_base: 0x171A4, count: 210 },  // western: CDEFGAB
    UnderlinedBracketSystem { underlined_start: 0x16300, underlined_end: 0x16467, bracket_base: 0x173AC, count: 360 },  // sargam: SrRgGmMPdDnN
    UnderlinedBracketSystem { underlined_start: 0x16500, underlined_end: 0x165D1, bracket_base: 0x17614, count: 210 },  // doremi: drmfslt
];

/// Get bracket variant for an underlined glyph
///
/// Given an underlined glyph (0x16000+) and bracket position, returns the
/// appropriate bracket variant (0x17000+) with arc endpoints.
///
/// # Arguments
/// * `underlined_glyph` - The underlined glyph character (from underlined_glyph_for_pitch)
/// * `position` - Where this note appears in the beat group
///
/// # Returns
/// * `Some(char)` - The bracket variant glyph
/// * `None` - If position is Middle (use underlined_glyph directly) or glyph not found
pub fn bracket_variant_for_underlined(
    underlined_glyph: char,
    position: BracketPosition,
) -> Option<char> {
    // Middle position = no bracket needed, use underlined glyph as-is
    if position == BracketPosition::Middle {
        return None;
    }

    let cp = underlined_glyph as u32;

    // Find which system this underlined glyph belongs to
    for sys in UNDERLINED_BRACKET_SYSTEMS {
        if cp >= sys.underlined_start && cp < sys.underlined_end {
            let offset = cp - sys.underlined_start;

            // Calculate bracket variant codepoint
            // Layout: left=base+0, right=base+count
            let bracket_cp = match position {
                BracketPosition::Left => sys.bracket_base + offset,
                BracketPosition::Right => sys.bracket_base + sys.count + offset,
                BracketPosition::Middle => return None,  // Already handled above
            };

            return char::from_u32(bracket_cp);
        }
    }

    None  // Glyph not in any known underlined range
}

/// Convenience function: get underlined glyph with bracket position
///
/// Combines underlined_glyph_for_pitch and bracket_variant_for_underlined
pub fn underlined_bracket_glyph_for_pitch(
    pitch: PitchCode,
    octave: i8,
    system: crate::models::elements::PitchSystem,
    position: BracketPosition,
) -> Option<char> {
    let underlined = underlined_glyph_for_pitch(pitch, octave, system)?;

    match position {
        BracketPosition::Middle => Some(underlined),
        _ => bracket_variant_for_underlined(underlined, position),
    }
}
"#);

    let dest_file = out_dir.join("font_lookup_tables.rs");
    fs::write(&dest_file, code).expect("Failed to write font_lookup_tables.rs");
}

/// Generate lookup table for a single notation system
fn generate_system_lookup_table(
    code: &mut String,
    system_name_upper: &str,
    pua_base: u32,
    char_to_index: &HashMap<char, usize>,
    characters: &[serde_yaml::Value],
) {
    let is_sargam = system_name_upper == "SARGAM";
    let num_chars = characters.len() as u32;
    let pitch_codes = vec![
        "N1", "N1s", "N1b", "N1hf", "N1ss", "N1bb",
        "N2", "N2s", "N2b", "N2hf", "N2ss", "N2bb",
        "N3", "N3s", "N3b", "N3hf", "N3ss", "N3bb",
        "N4", "N4s", "N4b", "N4hf", "N4ss", "N4bb",
        "N5", "N5s", "N5b", "N5hf", "N5ss", "N5bb",
        "N6", "N6s", "N6b", "N6hf", "N6ss", "N6bb",
        "N7", "N7s", "N7b", "N7hf", "N7ss", "N7bb",
    ];

    // Generate lookup table
    code.push_str(&format!(
        "/// {} system: [42 pitch codes][5 octaves]\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "/// PUA base: 0x{:X}, Octave order: [0, -2, -1, +1, +2] (matches generate.py line 316)\n",
        pua_base
    ));
    code.push_str(&format!(
        "pub static {}_TABLE: [[char; OCTAVE_COUNT]; PITCH_CODE_COUNT] = [\n",
        system_name_upper
    ));

    for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
        let degree = (pitch_idx / 6) as usize; // 0-6 for 7 degrees (6 accidentals per degree)

        // Get the base character for this degree/pitch code
        // For Sargam, use special mapping based on pitch code (komal/shuddha)
        let base_char = if is_sargam {
            get_sargam_char(pitch_code)
        } else {
            // Other systems: use sequential character order by degree
            if let Some(char_entry) = characters.get(degree) {
                if let Some(ch_str) = char_entry.get("char").and_then(|v| v.as_str()) {
                    ch_str.chars().next().unwrap_or('?')
                } else {
                    '?'
                }
            } else {
                '?'
            }
        };

        code.push_str(&format!("    // {} (degree {}, char '{}')\n", pitch_code, degree, base_char));
        code.push_str("    [");

        // Generate codepoints for each octave, in SAME ORDER as generate.py (line 316)
        // Order: 0, -2, -1, +1, +2 (NOT -2, -1, 0, +1, +2)
        // This must match generate.py's octave_order = [0, -2, -1, 1, 2]
        for octave in [0, -2, -1, 1, 2].iter().copied() {
            let codepoint = calculate_system_codepoint(
                pitch_code,
                base_char,
                octave,
                char_to_index,
                pua_base,
                num_chars,
            );
            code.push_str(&format!("'\\u{{{:04X}}}', ", codepoint));
        }

        code.push_str("],\n");
    }

    code.push_str("];\n\n");

    // Generate reverse lookup function
    code.push_str(&format!(
        "/// Reverse lookup for {} system: char → (PitchCode, i8)\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "pub fn pitch_from_glyph_{}(ch: char) -> Option<(PitchCode, i8)> {{\n",
        system_name_upper.to_lowercase()
    ));
    // Add line variant check before the match
    // Use fully qualified paths since this code is include!ed
    code.push_str("    let cp = ch as u32;\n");
    code.push_str(&format!(
        "    // Check if it's a {} line variant (0x1A000+ range)\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "    if cp >= crate::renderers::line_variants::pua::{}_LINE_BASE && cp < crate::renderers::line_variants::pua::{}_LINE_BASE + {} * 15 {{\n",
        system_name_upper, system_name_upper,
        match system_name_upper { "NUMBER" => 210, "WESTERN" => 210, "SARGAM" => 360, "DOREMI" => 210, _ => 210 }
    ));
    code.push_str(&format!(
        "        let note_offset = (cp - crate::renderers::line_variants::pua::{}_LINE_BASE) / 15;\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "        let base_cp = crate::renderers::line_variants::pua::{}_SOURCE_BASE + note_offset;\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "        return pitch_from_glyph_{}(char::from_u32(base_cp)?);\n",
        system_name_upper.to_lowercase()
    ));
    code.push_str("    }\n");

    // Add superscript check (0xF8000+ range)
    code.push_str("    // Check if it's a superscript (0xF8000+ range)\n");
    code.push_str("    if cp >= 0xF8000 && cp < 0xFE040 {\n");
    code.push_str("        // Convert superscript back to normal and recurse\n");
    code.push_str("        if let Some(normal_cp) = crate::renderers::font_utils::from_superscript(cp) {\n");
    code.push_str(&format!(
        "            return pitch_from_glyph_{}(char::from_u32(normal_cp)?);\n",
        system_name_upper.to_lowercase()
    ));
    code.push_str("        }\n");
    code.push_str("    }\n");

    code.push_str("    match ch {\n");

    for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
        let degree = (pitch_idx / 6) as usize; // 6 accidentals per degree

        // Get the base character for this degree/pitch code
        // For Sargam, use special mapping based on pitch code (komal/shuddha)
        let base_char = if is_sargam {
            get_sargam_char(pitch_code)
        } else {
            // Other systems: use sequential character order by degree
            if let Some(char_entry) = characters.get(degree) {
                if let Some(ch_str) = char_entry.get("char").and_then(|v| v.as_str()) {
                    ch_str.chars().next().unwrap_or('?')
                } else {
                    '?'
                }
            } else {
                '?'
            }
        };

        // CRITICAL: Same octave order as forward lookup
        // Order: 0, -2, -1, +1, +2 (matches generate.py line 316)
        for octave in [0, -2, -1, 1, 2].iter().copied() {
            let codepoint = calculate_system_codepoint(
                pitch_code,
                base_char,
                octave,
                char_to_index,
                pua_base,
                num_chars,
            );

            // All codepoints are valid in new fully-PUA architecture
            // (octave 0 naturals are now in PUA, not ASCII)

            code.push_str(&format!(
                "        '\\u{{{:04X}}}' => Some((PitchCode::{}, {})),\n",
                codepoint, pitch_code, octave
            ));
        }
    }

    // Add ASCII characters for octave 0 (for backward compatibility with test inputs like "1 2 3")
    // Only add naturals (no accidentals) - these are the base input characters
    for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
        // Only process naturals (every 6th pitch code)
        if pitch_idx % 6 == 0 {
            let degree = (pitch_idx / 6) as usize;
            if let Some(char_entry) = characters.get(degree) {
                if let Some(ch_str) = char_entry.get("char").and_then(|v| v.as_str()) {
                    if let Some(base_char) = ch_str.chars().next() {
                        // Map ASCII character to (PitchCode, octave=0)
                        code.push_str(&format!(
                            "        '{}' => Some((PitchCode::{}, 0)),\n",
                            base_char, pitch_code
                        ));
                    }
                }
            }
        }
    }

    code.push_str("        _ => None,\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
}

/// Generate underlined lookup table for a notation system
/// Same structure as base table but with _UNDERLINED_TABLE suffix
fn generate_underlined_lookup_table(
    code: &mut String,
    system_name_upper: &str,
    underlined_pua_base: u32,
    char_to_index: &HashMap<char, usize>,
    characters: &[serde_yaml::Value],
) {
    let is_sargam = system_name_upper == "SARGAM";
    let pitch_codes = vec![
        "N1", "N1s", "N1b", "N1hf", "N1ss", "N1bb",
        "N2", "N2s", "N2b", "N2hf", "N2ss", "N2bb",
        "N3", "N3s", "N3b", "N3hf", "N3ss", "N3bb",
        "N4", "N4s", "N4b", "N4hf", "N4ss", "N4bb",
        "N5", "N5s", "N5b", "N5hf", "N5ss", "N5bb",
        "N6", "N6s", "N6b", "N6hf", "N6ss", "N6bb",
        "N7", "N7s", "N7b", "N7hf", "N7ss", "N7bb",
    ];

    code.push_str(&format!(
        "/// {} UNDERLINED system: [42 pitch codes][5 octaves]\n",
        system_name_upper
    ));
    code.push_str(&format!(
        "/// PUA base: 0x{:X} (underlined variants for beat grouping)\n",
        underlined_pua_base
    ));
    code.push_str(&format!(
        "pub static {}_UNDERLINED_TABLE: [[char; OCTAVE_COUNT]; PITCH_CODE_COUNT] = [\n",
        system_name_upper
    ));

    for (pitch_idx, pitch_code) in pitch_codes.iter().enumerate() {
        let degree = (pitch_idx / 6) as usize;

        let base_char = if is_sargam {
            get_sargam_char(pitch_code)
        } else {
            if let Some(char_entry) = characters.get(degree) {
                if let Some(ch_str) = char_entry.get("char").and_then(|v| v.as_str()) {
                    ch_str.chars().next().unwrap_or('?')
                } else {
                    '?'
                }
            } else {
                '?'
            }
        };

        code.push_str(&format!("    // {} underlined (degree {}, char '{}')\n", pitch_code, degree, base_char));
        code.push_str("    [");

        // Same octave order: 0, -2, -1, +1, +2
        for octave in [0, -2, -1, 1, 2].iter().copied() {
            let codepoint = calculate_system_codepoint(
                pitch_code,
                base_char,
                octave,
                char_to_index,
                underlined_pua_base,
                characters.len() as u32,
            );
            // Use 5 digits for supplementary plane codepoints
            code.push_str(&format!("'\\u{{{:05X}}}', ", codepoint));
        }

        code.push_str("],\n");
    }

    code.push_str("];\n\n");
}

/// Map PitchCode to Sargam character (case-sensitive for komal/shuddha)
/// Sargam uses uppercase for shuddha (natural) and lowercase for komal (flat)
fn get_sargam_char(pitch_code: &str) -> char {
    match pitch_code {
        // N1 (Sa) - always uppercase, no komal
        "N1" | "N1s" | "N1b" | "N1hf" | "N1ss" | "N1bb" => 'S',

        // N2 (Re) - uppercase for shuddha, lowercase for komal
        "N2" | "N2s" | "N2hf" | "N2ss" | "N2bb" => 'R',
        "N2b" => 'r', // komal Re

        // N3 (Ga) - uppercase for shuddha, lowercase for komal
        "N3" | "N3s" | "N3hf" | "N3ss" | "N3bb" => 'G',
        "N3b" => 'g', // komal Ga

        // N4 (ma) - lowercase for shuddha, uppercase for tivra
        "N4" | "N4b" | "N4hf" | "N4bb" => 'm',
        "N4s" | "N4ss" => 'M', // tivra Ma

        // N5 (Pa) - always uppercase, no komal
        "N5" | "N5s" | "N5b" | "N5hf" | "N5ss" | "N5bb" => 'P',

        // N6 (Dha) - uppercase for shuddha, lowercase for komal
        "N6" | "N6s" | "N6hf" | "N6ss" | "N6bb" => 'D',
        "N6b" => 'd', // komal Dha

        // N7 (Ni) - uppercase for shuddha, lowercase for komal
        "N7" | "N7s" | "N7hf" | "N7ss" | "N7bb" => 'N',
        "N7b" => 'n', // komal Ni

        _ => '?',
    }
}

/// Calculate codepoint for (PitchCode, base_char, octave) in a specific notation system
///
/// NEW ARCHITECTURE: 30 variants per character
/// Each character gets 30 consecutive codepoints for all accidental+octave combinations
/// - Variants 0-4: Natural (octave 0, -2, -1, +1, +2)
/// - Variants 5-9: Flat (octave 0, -2, -1, +1, +2)
/// - Variants 10-14: Half-flat (octave 0, -2, -1, +1, +2)
/// - Variants 15-19: Double-flat (octave 0, -2, -1, +1, +2)
/// - Variants 20-24: Double-sharp (octave 0, -2, -1, +1, +2)
/// - Variants 25-29: Sharp (octave 0, -2, -1, +1, +2)
///
/// Formula: pua_base + (char_idx × 30) + variant_index
///   where variant_index = (accidental_type × 5) + octave_idx
fn calculate_system_codepoint(
    pitch_code: &str,
    base_char: char,
    octave: i8,
    char_to_index: &HashMap<char, usize>,
    pua_base: u32,
    _num_chars: u32,
) -> u32 {
    let char_idx = char_to_index.get(&base_char).copied().unwrap_or(0) as u32;

    // Determine accidental type from PitchCode suffix
    let accidental_type = if pitch_code.ends_with("ss") {
        4 // Double sharp
    } else if pitch_code.ends_with("bb") {
        3 // Double flat
    } else if pitch_code.ends_with("hf") {
        2 // Half flat
    } else if pitch_code.ends_with('s') {
        5 // Sharp
    } else if pitch_code.ends_with('b') {
        1 // Flat
    } else {
        0 // Natural
    };

    // Map octave to index: 0->0, -2->1, -1->2, +1->3, +2->4
    let octave_idx = match octave {
        0 => 0,
        -2 => 1,
        -1 => 2,
        1 => 3,
        2 => 4,
        _ => return base_char as u32, // Out of range
    };

    // NEW ARCHITECTURE: 30 variants per character
    // Formula: pua_base + (char_idx × 30) + variant_index
    // where variant_index = (accidental_type × 5) + octave_idx

    const VARIANTS_PER_CHARACTER: u32 = 30; // 6 accidentals × 5 octaves
    let variant_index = (accidental_type * 5) + octave_idx as u32;

    pua_base + (char_idx * VARIANTS_PER_CHARACTER) + variant_index
}

/// Parse hex value from YAML (handles both numbers and "0x..." strings)
fn parse_hex(v: &serde_yaml::Value) -> Option<u32> {
    if let serde_yaml::Value::Number(n) = v {
        n.as_u64().map(|u| u as u32)
    } else if let serde_yaml::Value::String(s) = v {
        u32::from_str_radix(s.trim_start_matches("0x"), 16).ok()
    } else {
        None
    }
}

/// Generate fontspec.json for Python font generator
///
/// This creates the canonical FontSpec in JSON format that Python
/// will consume to generate the actual font files.
fn generate_fontspec_json(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    // Extract notation systems
    let mut notation_systems = Vec::new();

    // Calculate PUA bases for each system (30 variants per character)
    const VARIANTS_PER_CHAR: u32 = 30;  // 6 accidentals × 5 octaves
    let mut current_pua_base = 0xE000u32;

    if let Some(systems) = atoms.get("notation_systems")
        .and_then(|v| v.as_sequence()) {
        for system in systems {
            let system_name = system
                .get("system_name")
                .and_then(|v| v.as_str())
                .unwrap_or("unknown")
                .to_string();

            let characters = system
                .get("characters")
                .and_then(|v| v.as_sequence())
                .map(|seq| {
                    seq.iter()
                        .filter_map(|char_value| {
                            char_value
                                .get("char")
                                .and_then(|v| v.as_str())
                                .and_then(|s| s.chars().next())
                        })
                        .collect::<Vec<_>>()
                })
                .unwrap_or_default();

            // Use per-system PUA base if specified, otherwise use calculated sequential base
            let pua_base = system
                .get("pua_base")
                .and_then(|v| parse_hex(v))
                .unwrap_or(current_pua_base);

            notation_systems.push(serde_json::json!({
                "name": system_name,
                "characters": characters,
                "pua_base": pua_base,
                "variants_per_char": VARIANTS_PER_CHAR
            }));

            // Calculate next PUA base (current + num_chars * variants_per_char)
            current_pua_base += (characters.len() as u32) * VARIANTS_PER_CHAR;
        }
    }

    // Extract glyph variants (30-variant system with accidentals)
    let mut accidental_types = 6;  // natural, flat, half-flat, double-flat, sharp, double-sharp
    let mut octave_variants = 5;   // 5 octave patterns (0, -2, -1, +1, +2)

    if let Some(glyph_variants) = atoms.get("glyph_variants") {
        if let Some(acc_types) = glyph_variants.get("accidental_types")
            .and_then(|v| v.as_u64()) {
            accidental_types = acc_types as usize;
        }
        if let Some(oct_variants) = glyph_variants.get("octave_variants")
            .and_then(|v| v.as_u64()) {
            octave_variants = oct_variants as usize;
        }
    }

    // Build FontSpec JSON
    let fontspec = serde_json::json!({
        "notation_systems": notation_systems,
        "glyph_variants": {
            "accidental_types": accidental_types,
            "octave_variants": octave_variants
        }
    });

    // Write fontspec.json to OUT_DIR (for Rust to consume during tests/builds)
    let fontspec_path = out_dir.join("fontspec.json");
    let json_str = serde_json::to_string_pretty(&fontspec)
        .expect("Failed to serialize FontSpec to JSON");

    fs::write(&fontspec_path, &json_str)
        .expect("Failed to write fontspec.json");

    // NOTE: We no longer write to tools/fontgen/fontspec.json from build.rs
    // The Python font generator should read atoms.yaml directly (single source of truth)
    // or use: cargo build && cp $OUT_DIR/fontspec.json tools/fontgen/
}

/// Generate measurement system configurations from atoms.yaml
/// This creates the data that getFontConfig() returns to JavaScript for glyph measurement
fn generate_measurement_systems(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    let mut systems = Vec::new();

    // 1. Add pitch systems from notation_systems
    if let Some(notation_systems) = atoms.get("notation_systems").and_then(|v| v.as_sequence()) {
        for system in notation_systems {
            let name = system.get("system_name").and_then(|v| v.as_str()).unwrap_or("unknown");
            let pua_base = system.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0);
            let char_count = system.get("characters").and_then(|v| v.as_sequence()).map(|s| s.len()).unwrap_or(0);
            let variants_per_char = 30; // 6 accidentals × 5 octaves
            systems.push((name.to_string(), pua_base, char_count, variants_per_char));
        }
    }

    // 2. Add line_variants from pua_allocation
    if let Some(pua_alloc) = atoms.get("pua_allocation") {
        if let Some(line_variants) = pua_alloc.get("line_variants") {
            let line_capable = line_variants.get("line_capable_chars").and_then(|v| v.as_u64()).unwrap_or(37) as usize;

            if let Some(underline) = line_variants.get("underline_only") {
                let pua_base = underline.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0xE800);
                let variants = underline.get("variants").and_then(|v| v.as_u64()).unwrap_or(4) as usize;
                systems.push(("underline".to_string(), pua_base, line_capable, variants));
            }
            if let Some(overline) = line_variants.get("overline_only") {
                let pua_base = overline.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0xE900);
                let variants = overline.get("variants").and_then(|v| v.as_u64()).unwrap_or(3) as usize;
                systems.push(("overline".to_string(), pua_base, line_capable, variants));
            }
            if let Some(combined) = line_variants.get("combined") {
                let pua_base = combined.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0xEA00);
                let variants = combined.get("variants").and_then(|v| v.as_u64()).unwrap_or(12) as usize;
                systems.push(("combined".to_string(), pua_base, line_capable, variants));
            }
        }

        // 3. Add underlined_notes
        if let Some(underlined) = pua_alloc.get("underlined_notes") {
            for (key, value) in [
                ("number_underlined", underlined.get("number_underlined")),
                ("western_underlined", underlined.get("western_underlined")),
                ("sargam_underlined", underlined.get("sargam_underlined")),
                ("doremi_underlined", underlined.get("doremi_underlined")),
            ] {
                if let Some(sys) = value {
                    let pua_base = sys.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0);
                    let char_count = sys.get("chars_count").and_then(|v| v.as_u64()).unwrap_or(0) as usize;
                    let variants = sys.get("variants_per_char").and_then(|v| v.as_u64()).unwrap_or(30) as usize;
                    systems.push((key.to_string(), pua_base, char_count, variants));
                }
            }
        }

        // 4. Add bracket_variants
        if let Some(brackets) = pua_alloc.get("bracket_variants") {
            if let Some(underline_brackets) = brackets.get("underline_brackets") {
                let pua_base = underline_brackets.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0xF700);
                // 95 ASCII printable chars × 2 variants (left, right)
                systems.push(("underline_brackets".to_string(), pua_base, 95, 2));
            }
            if let Some(overline_brackets) = brackets.get("overline_brackets") {
                let pua_base = overline_brackets.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0xFA00);
                systems.push(("overline_brackets".to_string(), pua_base, 95, 3));
            }
            // 5. Add underlined_note_brackets (bracket endpoints for underlined note variants)
            if let Some(underlined_note_brackets) = brackets.get("underlined_note_brackets") {
                let pua_base = underlined_note_brackets.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0x17000);
                // 1410 underlined notes × 2 variants (left, right)
                systems.push(("underlined_note_brackets".to_string(), pua_base, 1410, 2));
            }
        }
    }

    // Generate Rust code
    let mut code = String::from(r#"/// Auto-generated measurement system configurations from atoms.yaml
/// DO NOT EDIT - This file is generated by build.rs
///
/// These configurations are used by getFontConfig() to tell JavaScript
/// which glyph ranges to measure at startup.

/// A measurement system configuration
#[derive(Debug, Clone)]
pub struct MeasurementSystem {
    pub name: &'static str,
    pub pua_base: u32,
    pub char_count: usize,
    pub variants_per_char: usize,
}

/// All measurement systems from atoms.yaml
pub static MEASUREMENT_SYSTEMS: &[MeasurementSystem] = &[
"#);

    for (name, pua_base, char_count, variants) in &systems {
        code.push_str(&format!(
            r#"    MeasurementSystem {{ name: "{}", pua_base: 0x{:X}, char_count: {}, variants_per_char: {} }},
"#,
            name, pua_base, char_count, variants
        ));
    }

    code.push_str("];\n");

    let dest_file = out_dir.join("font_measurement_systems.rs");
    fs::write(&dest_file, code).expect("Failed to write font_measurement_systems.rs");
}

/// Generate superscript lookup tables for ornament rendering
///
/// Creates tables for 75% scaled superscript glyphs with overline variants.
/// Formula: superscript_cp = system_base + (source_offset × 4) + overline_variant
///
/// Where:
///   system_base     = PUA base for that pitch system (e.g., 0xF0200 for Number)
///   source_offset   = source_codepoint - source_system_base
///   overline_variant = 0 (none), 1 (left-cap), 2 (middle), 3 (right-cap)
fn generate_superscript_tables(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    let mut code = String::from(r#"/// Auto-generated superscript lookup tables from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// These tables provide 75% scaled superscript glyphs for ornament rendering.
/// Each source glyph has 4 variants: none, left-cap overline, middle overline, right-cap overline.
///
/// Formula: superscript_cp = system_base + (source_offset × 4) + overline_variant
///
/// Location: Supplementary Private Use Area-A (0xF0000-0xFFFFD)

/// Overline variant for superscript glyphs
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum SuperscriptLineVariant {
    /// No lines
    None = 0,
    /// Underline only - left cap
    UnderlineLeft = 1,
    /// Underline only - middle
    UnderlineMiddle = 2,
    /// Underline only - right cap
    UnderlineRight = 3,
    /// Overline only - left cap
    OverlineLeft = 4,
    /// Overline only - middle
    OverlineMiddle = 5,
    /// Overline only - right cap
    OverlineRight = 6,
    /// Combined: underline left + overline left
    CombinedLeftLeft = 7,
    /// Combined: underline left + overline middle
    CombinedLeftMiddle = 8,
    /// Combined: underline left + overline right
    CombinedLeftRight = 9,
    /// Combined: underline middle + overline left
    CombinedMiddleLeft = 10,
    /// Combined: underline middle + overline middle
    CombinedMiddleMiddle = 11,
    /// Combined: underline middle + overline right
    CombinedMiddleRight = 12,
    /// Combined: underline right + overline left
    CombinedRightLeft = 13,
    /// Combined: underline right + overline middle
    CombinedRightMiddle = 14,
    /// Combined: underline right + overline right
    CombinedRightRight = 15,
}

impl SuperscriptLineVariant {
    /// Convert to variant index (0-15)
    pub fn as_index(self) -> u32 {
        self as u32
    }

    /// Create from variant index (0-15)
    pub fn from_index(idx: u8) -> Option<Self> {
        match idx {
            0 => Some(Self::None),
            1 => Some(Self::UnderlineLeft),
            2 => Some(Self::UnderlineMiddle),
            3 => Some(Self::UnderlineRight),
            4 => Some(Self::OverlineLeft),
            5 => Some(Self::OverlineMiddle),
            6 => Some(Self::OverlineRight),
            7 => Some(Self::CombinedLeftLeft),
            8 => Some(Self::CombinedLeftMiddle),
            9 => Some(Self::CombinedLeftRight),
            10 => Some(Self::CombinedMiddleLeft),
            11 => Some(Self::CombinedMiddleMiddle),
            12 => Some(Self::CombinedMiddleRight),
            13 => Some(Self::CombinedRightLeft),
            14 => Some(Self::CombinedRightMiddle),
            15 => Some(Self::CombinedRightRight),
            _ => None,
        }
    }
}

/// Legacy alias for backwards compatibility
pub type SuperscriptOverline = SuperscriptLineVariant;

// =============================================================================
// SUPERSCRIPT PUA BASES (Supplementary PUA-A: 0xF8000+)
// =============================================================================
// Each source glyph has 16 line variants (see SuperscriptLineVariant enum)

/// ASCII superscripts PUA base (95 chars × 16 variants = 1,520 codepoints)
pub const SUPERSCRIPT_ASCII_BASE: u32 = 0xF8000;

/// Number system superscripts PUA base (7 chars (1234567) × 30 variants × 16 = 3,360 codepoints)
pub const SUPERSCRIPT_NUMBER_BASE: u32 = 0xF8600;

/// Western system superscripts PUA base (7 chars (CDEFGAB) × 30 variants × 16 = 3,360 codepoints)
pub const SUPERSCRIPT_WESTERN_BASE: u32 = 0xF9400;

/// Sargam system superscripts PUA base (12 chars (SrRgGmMPdDnN) × 30 variants × 16 = 5,760 codepoints)
pub const SUPERSCRIPT_SARGAM_BASE: u32 = 0xFAF00;

/// Doremi system superscripts PUA base (7 chars (drmfslt) × 30 variants × 16 = 3,360 codepoints)
pub const SUPERSCRIPT_DOREMI_BASE: u32 = 0xFC600;

/// Number of line variants per superscript glyph
pub const SUPERSCRIPT_LINE_VARIANTS: u32 = 16;

// =============================================================================
// SUPERSCRIPT LOOKUP FUNCTIONS
// =============================================================================

/// Get superscript ASCII glyph
///
/// # Arguments
/// * `ascii_char` - ASCII character (0x20-0x7E)
/// * `line_variant` - Line variant (underline/overline/combined)
///
/// # Returns
/// * `Some(char)` - Superscript glyph in Supplementary PUA-A
/// * `None` - If character is outside ASCII printable range
pub fn superscript_ascii(ascii_char: char, line_variant: SuperscriptLineVariant) -> Option<char> {
    let cp = ascii_char as u32;
    if cp < 0x20 || cp > 0x7E {
        return None;
    }
    let source_offset = cp - 0x20;
    let superscript_cp = SUPERSCRIPT_ASCII_BASE + (source_offset * SUPERSCRIPT_LINE_VARIANTS) + line_variant.as_index();
    char::from_u32(superscript_cp)
}

/// Get superscript Number system glyph
///
/// # Arguments
/// * `source_cp` - Source codepoint in Number PUA range (0xE000+)
/// * `line_variant` - Line variant (underline/overline/combined)
///
/// # Returns
/// * `Some(char)` - Superscript glyph in Supplementary PUA-A
/// * `None` - If codepoint is outside Number system range
pub fn superscript_number(source_cp: u32, line_variant: SuperscriptLineVariant) -> Option<char> {
    const SOURCE_BASE: u32 = 0xE000;
    const MAX_OFFSET: u32 = 7 * 30; // 7 chars × 30 variants = 210

    if source_cp < SOURCE_BASE || source_cp >= SOURCE_BASE + MAX_OFFSET {
        return None;
    }
    let source_offset = source_cp - SOURCE_BASE;
    let superscript_cp = SUPERSCRIPT_NUMBER_BASE + (source_offset * SUPERSCRIPT_LINE_VARIANTS) + line_variant.as_index();
    char::from_u32(superscript_cp)
}

/// Get superscript Western system glyph
///
/// # Arguments
/// * `source_cp` - Source codepoint in Western PUA range (0xE100+)
/// * `line_variant` - Line variant (underline/overline/combined)
///
/// # Returns
/// * `Some(char)` - Superscript glyph in Supplementary PUA-A
/// * `None` - If codepoint is outside Western system range
pub fn superscript_western(source_cp: u32, line_variant: SuperscriptLineVariant) -> Option<char> {
    const SOURCE_BASE: u32 = 0xE100;
    const MAX_OFFSET: u32 = 7 * 30; // 7 chars (CDEFGAB) × 30 variants = 210

    if source_cp < SOURCE_BASE || source_cp >= SOURCE_BASE + MAX_OFFSET {
        return None;
    }
    let source_offset = source_cp - SOURCE_BASE;
    let superscript_cp = SUPERSCRIPT_WESTERN_BASE + (source_offset * SUPERSCRIPT_LINE_VARIANTS) + line_variant.as_index();
    char::from_u32(superscript_cp)
}

/// Get superscript Sargam system glyph
///
/// # Arguments
/// * `source_cp` - Source codepoint in Sargam PUA range (0xE300+)
/// * `line_variant` - Line variant (underline/overline/combined)
///
/// # Returns
/// * `Some(char)` - Superscript glyph in Supplementary PUA-A
/// * `None` - If codepoint is outside Sargam system range
pub fn superscript_sargam(source_cp: u32, line_variant: SuperscriptLineVariant) -> Option<char> {
    const SOURCE_BASE: u32 = 0xE300;
    const MAX_OFFSET: u32 = 12 * 30; // 12 chars × 30 variants = 360

    if source_cp < SOURCE_BASE || source_cp >= SOURCE_BASE + MAX_OFFSET {
        return None;
    }
    let source_offset = source_cp - SOURCE_BASE;
    let superscript_cp = SUPERSCRIPT_SARGAM_BASE + (source_offset * SUPERSCRIPT_LINE_VARIANTS) + line_variant.as_index();
    char::from_u32(superscript_cp)
}

/// Get superscript Doremi system glyph
///
/// # Arguments
/// * `source_cp` - Source codepoint in Doremi PUA range (0xE500+)
/// * `line_variant` - Line variant (underline/overline/combined)
///
/// # Returns
/// * `Some(char)` - Superscript glyph in Supplementary PUA-A
/// * `None` - If codepoint is outside Doremi system range
pub fn superscript_doremi(source_cp: u32, line_variant: SuperscriptLineVariant) -> Option<char> {
    const SOURCE_BASE: u32 = 0xE500;
    const MAX_OFFSET: u32 = 7 * 30; // 7 chars (drmfslt) × 30 variants = 210

    if source_cp < SOURCE_BASE || source_cp >= SOURCE_BASE + MAX_OFFSET {
        return None;
    }
    let source_offset = source_cp - SOURCE_BASE;
    let superscript_cp = SUPERSCRIPT_DOREMI_BASE + (source_offset * SUPERSCRIPT_LINE_VARIANTS) + line_variant.as_index();
    char::from_u32(superscript_cp)
}

/// Get superscript glyph for any source codepoint
///
/// Automatically detects the source system and returns the appropriate superscript.
///
/// # Arguments
/// * `source_cp` - Source codepoint (ASCII or PUA pitch glyph)
/// * `line_variant` - Line variant (underline/overline/combined)
///
/// # Returns
/// * `Some(char)` - Superscript glyph
/// * `None` - If codepoint is not in a supported range
pub fn superscript_glyph(source_cp: u32, line_variant: SuperscriptLineVariant) -> Option<char> {
    // Try ASCII first (0x20-0x7E)
    if source_cp >= 0x20 && source_cp <= 0x7E {
        if let Some(ch) = char::from_u32(source_cp) {
            return superscript_ascii(ch, line_variant);
        }
    }

    // Try pitch systems in order of PUA base
    if source_cp >= 0xE000 && source_cp < 0xE000 + 7 * 30 {
        return superscript_number(source_cp, line_variant);
    }
    if source_cp >= 0xE100 && source_cp < 0xE100 + 14 * 30 {
        return superscript_western(source_cp, line_variant);
    }
    if source_cp >= 0xE300 && source_cp < 0xE300 + 12 * 30 {
        return superscript_sargam(source_cp, line_variant);
    }
    if source_cp >= 0xE500 && source_cp < 0xE500 + 14 * 30 {
        return superscript_doremi(source_cp, line_variant);
    }

    None
}

/// Check if a codepoint is a superscript glyph
pub fn is_superscript(cp: u32) -> bool {
    // All superscript glyphs are in Supplementary PUA-A (0xF8000+)
    // Range: 0xF8000 (ASCII) to 0xFE03F (end of Doremi)
    cp >= 0xF8000 && cp < 0xFE040
}

/// Get the line variant from a superscript codepoint
pub fn superscript_line_variant(cp: u32) -> Option<SuperscriptLineVariant> {
    if !is_superscript(cp) {
        return None;
    }
    // Line variant is always the last 4 bits (cp % 16)
    SuperscriptLineVariant::from_index((cp % 16) as u8)
}

/// Legacy alias
pub fn superscript_overline(cp: u32) -> Option<SuperscriptOverline> {
    superscript_line_variant(cp)
}
"#);

    // Read superscript config from atoms.yaml to verify our constants match
    if let Some(pua_alloc) = atoms.get("pua_allocation") {
        if let Some(superscript_variants) = pua_alloc.get("superscript_variants") {
            // Log for verification (shows in cargo build output with -vv)
            if let Some(ascii) = superscript_variants.get("ascii_superscripts") {
                if let Some(base) = ascii.get("pua_base").and_then(|v| parse_hex(v)) {
                    if base != 0xF8000 {
                        panic!("SUPERSCRIPT_ASCII_BASE mismatch: expected 0x{:X}, got 0x{:X}", 0xF8000, base);
                    }
                }
            }
            if let Some(number) = superscript_variants.get("number_superscripts") {
                if let Some(base) = number.get("pua_base").and_then(|v| parse_hex(v)) {
                    if base != 0xF8600 {
                        panic!("SUPERSCRIPT_NUMBER_BASE mismatch: expected 0x{:X}, got 0x{:X}", 0xF8600, base);
                    }
                }
            }
        }
    }

    let dest_file = out_dir.join("superscript_tables.rs");
    fs::write(&dest_file, code).expect("Failed to write superscript_tables.rs");
}

/// Generate beat element predicates from atoms.yaml
///
/// Creates functions to check if a codepoint is a beat element:
/// - is_pitched_note(cp) - checks all pitched note ranges (base + line variants)
/// - is_dash(cp) - checks dash (base + line variants)
/// - is_breath_mark(cp) - checks breath mark (base + line variants)
/// - is_beat_element(cp) - combination of above (pitched notes + dash + breath mark)
fn generate_beat_element_predicates(atoms: &serde_yaml::Value, out_dir: &PathBuf) {
    const VARIANTS_PER_CHAR: u32 = 30;  // 6 accidentals × 5 octaves
    const LINE_VARIANTS_PER_GLYPH: u32 = 15;  // 3 underline × (1 + 3 overline + 3 combined)

    let mut code = String::from(r#"/// Auto-generated beat element predicates from atoms.yaml at compile time
/// DO NOT EDIT - This file is generated by build.rs
///
/// Source: tools/fontgen/atoms.yaml
///
/// Beat elements are characters that participate in beat grouping:
/// - Pitched notes (all notation systems, all accidentals, all octaves)
/// - Dash (rhythmic placeholder)
/// - Breath mark (phrasing separator)
///
/// Each element has:
/// - Base codepoint range (e.g., 0xE000-0xE0D1 for Number notes)
/// - Line variant range (e.g., 0x1A000+ for underlined/overlined variants)

"#);

    // Collect notation system info
    let mut system_ranges: Vec<(String, u32, u32, u32, u32)> = Vec::new();  // (name, base, count, line_base, line_count)

    if let Some(systems) = atoms.get("notation_systems").and_then(|v| v.as_sequence()) {
        let line_bases = atoms.get("pitched_note_line_bases");

        for system in systems {
            let name = system.get("system_name").and_then(|v| v.as_str()).unwrap_or("unknown");
            let pua_base = system.get("pua_base").and_then(|v| parse_hex(v)).unwrap_or(0);
            let char_count = system.get("characters").and_then(|v| v.as_sequence()).map(|s| s.len()).unwrap_or(0) as u32;
            let total_glyphs = char_count * VARIANTS_PER_CHAR;

            // Get line variant base for this system
            let line_base = line_bases
                .and_then(|lb| lb.get(name))
                .and_then(|sys| sys.get("line_base"))
                .and_then(|v| parse_hex(v))
                .unwrap_or(0);

            let line_count = total_glyphs * LINE_VARIANTS_PER_GLYPH;

            system_ranges.push((name.to_uppercase(), pua_base, total_glyphs, line_base, line_count));
        }
    }

    // Collect notation element info (dash, breath_mark, etc.)
    let mut element_info: Vec<(String, u32, u32)> = Vec::new();  // (name, base, line_base)

    if let Some(elements) = atoms.get("notation_elements").as_ref() {
        for (key, value) in [
            ("DASH", elements.get("dash")),
            ("BREATH_MARK", elements.get("breath_mark")),
            ("SPACE", elements.get("space")),
            ("SINGLE_BARLINE", elements.get("single_barline")),
            ("DOUBLE_BARLINE", elements.get("double_barline")),
            ("REPEAT_LEFT", elements.get("repeat_left")),
            ("REPEAT_RIGHT", elements.get("repeat_right")),
        ] {
            if let Some(elem) = value {
                let base = elem.get("base").and_then(|v| parse_hex(v)).unwrap_or(0);
                let line_base = elem.get("line_base").and_then(|v| parse_hex(v)).unwrap_or(0);
                element_info.push((key.to_string(), base, line_base));
            }
        }
    }

    // Generate constants
    code.push_str("// =============================================================================\n");
    code.push_str("// PITCHED NOTE RANGES (from notation_systems)\n");
    code.push_str("// =============================================================================\n\n");

    for (name, base, count, line_base, line_count) in &system_ranges {
        code.push_str(&format!("/// {} base glyphs: 0x{:X} - 0x{:X} ({} codepoints)\n",
            name, base, base + count - 1, count));
        code.push_str(&format!("pub const {}_BASE: u32 = 0x{:X};\n", name, base));
        code.push_str(&format!("pub const {}_COUNT: u32 = {};\n", name, count));
        if *line_base > 0 {
            code.push_str(&format!("/// {} line variants: 0x{:X} - 0x{:X} ({} codepoints)\n",
                name, line_base, line_base + line_count - 1, line_count));
            code.push_str(&format!("pub const {}_LINE_BASE: u32 = 0x{:X};\n", name, line_base));
            code.push_str(&format!("pub const {}_LINE_COUNT: u32 = {};\n", name, line_count));
        }
        code.push_str("\n");
    }

    code.push_str("// =============================================================================\n");
    code.push_str("// NOTATION ELEMENTS (from notation_elements)\n");
    code.push_str("// =============================================================================\n\n");

    code.push_str(&format!("/// Line variants per glyph (uniform system)\n"));
    code.push_str(&format!("pub const LINE_VARIANTS_PER_GLYPH: u32 = {};\n\n", LINE_VARIANTS_PER_GLYPH));

    for (name, base, line_base) in &element_info {
        code.push_str(&format!("/// {} base codepoint\n", name));
        code.push_str(&format!("pub const {}_BASE: u32 = 0x{:X};\n", name, base));
        if *line_base > 0 {
            code.push_str(&format!("/// {} line variants: 0x{:X} - 0x{:X}\n",
                name, line_base, line_base + LINE_VARIANTS_PER_GLYPH - 1));
            code.push_str(&format!("pub const {}_LINE_BASE: u32 = 0x{:X};\n", name, line_base));
        }
        code.push_str("\n");
    }

    // Generate predicate functions
    code.push_str("// =============================================================================\n");
    code.push_str("// PREDICATE FUNCTIONS\n");
    code.push_str("// =============================================================================\n\n");

    // is_pitched_note
    code.push_str(r#"/// Check if codepoint is a pitched note (any system, any variant)
///
/// Includes:
/// - Base glyphs (all notation systems)
/// - Line variant glyphs (underlined/overlined)
#[inline]
pub fn is_pitched_note(cp: u32) -> bool {
"#);

    // Generate range checks for each system
    let mut conditions = Vec::new();
    for (name, _base, _count, line_base, _line_count) in &system_ranges {
        conditions.push(format!("    // {} base glyphs\n    (cp >= {}_BASE && cp < {}_BASE + {}_COUNT)",
            name, name, name, name));
        if *line_base > 0 {
            conditions.push(format!("    // {} line variants\n    (cp >= {}_LINE_BASE && cp < {}_LINE_BASE + {}_LINE_COUNT)",
                name, name, name, name));
        }
    }
    code.push_str(&conditions.join(" ||\n"));
    code.push_str("\n}\n\n");

    // is_dash
    code.push_str(r#"/// Check if codepoint is a dash (rhythmic placeholder)
#[inline]
pub fn is_dash(cp: u32) -> bool {
    cp == DASH_BASE ||
    (cp >= DASH_LINE_BASE && cp < DASH_LINE_BASE + LINE_VARIANTS_PER_GLYPH)
}

"#);

    // is_breath_mark
    code.push_str(r#"/// Check if codepoint is a breath mark
#[inline]
pub fn is_breath_mark(cp: u32) -> bool {
    cp == BREATH_MARK_BASE ||
    (cp >= BREATH_MARK_LINE_BASE && cp < BREATH_MARK_LINE_BASE + LINE_VARIANTS_PER_GLYPH)
}

"#);

    // is_beat_element
    code.push_str(r#"/// Check if codepoint is a beat element (participates in beat grouping)
///
/// Beat elements are:
/// - Pitched notes (any system)
/// - Dash (rhythmic placeholder)
/// - Breath mark (phrasing separator)
///
/// Non-beat elements (spaces, barlines) do NOT participate in beat grouping.
#[inline]
pub fn is_beat_element(cp: u32) -> bool {
    is_pitched_note(cp) || is_dash(cp) || is_breath_mark(cp)
}

"#);

    // is_space
    code.push_str(r#"/// Check if codepoint is a space (beat separator)
#[inline]
pub fn is_space(cp: u32) -> bool {
    cp == SPACE_BASE ||
    (cp >= SPACE_LINE_BASE && cp < SPACE_LINE_BASE + LINE_VARIANTS_PER_GLYPH)
}

"#);

    // is_barline
    code.push_str(r#"/// Check if codepoint is a barline (any type)
#[inline]
pub fn is_barline(cp: u32) -> bool {
    // Base barlines
    (cp >= SINGLE_BARLINE_BASE && cp <= REPEAT_RIGHT_BASE) ||
    // Line variants for barlines
    (cp >= SINGLE_BARLINE_LINE_BASE && cp < REPEAT_RIGHT_LINE_BASE + LINE_VARIANTS_PER_GLYPH)
}

"#);

    // strip_line_variant - get base glyph from line variant
    code.push_str(r#"/// Strip line variant from a codepoint, returning the base glyph
///
/// If the codepoint is a line variant, returns the base glyph.
/// If already a base glyph, returns it unchanged.
/// Returns None if codepoint is not recognized.
pub fn strip_line_variant(cp: u32) -> Option<u32> {
"#);

    // Generate strip logic for pitched notes
    for (name, _base, _count, line_base, _line_count) in &system_ranges {
        if *line_base > 0 {
            code.push_str(&format!(r#"    // {} line variants → base
    if cp >= {}_LINE_BASE && cp < {}_LINE_BASE + {}_LINE_COUNT {{
        let offset = (cp - {}_LINE_BASE) / LINE_VARIANTS_PER_GLYPH;
        return Some({}_BASE + offset);
    }}
"#, name, name, name, name, name, name));
        }
    }

    // Generate strip logic for notation elements
    for (name, _base, line_base) in &element_info {
        if *line_base > 0 {
            code.push_str(&format!(r#"    // {} line variant → base
    if cp >= {}_LINE_BASE && cp < {}_LINE_BASE + LINE_VARIANTS_PER_GLYPH {{
        return Some({}_BASE);
    }}
"#, name, name, name, name));
        }
    }

    code.push_str(r#"
    // Base glyphs pass through unchanged
    if is_pitched_note(cp) || is_dash(cp) || is_breath_mark(cp) || is_space(cp) || is_barline(cp) {
        return Some(cp);
    }

    None
}

"#);

    // get_line_variant - apply line variant to base glyph
    code.push_str(r#"/// Apply line variant to a base glyph
///
/// # Arguments
/// * `base_cp` - The base glyph codepoint
/// * `variant_index` - Line variant index (0-14, see line_variant_config in atoms.yaml)
///
/// # Returns
/// * `Some(char)` - The line variant codepoint
/// * `None` - If base is not recognized or variant_index out of range
pub fn get_line_variant(base_cp: u32, variant_index: u32) -> Option<u32> {
    if variant_index >= LINE_VARIANTS_PER_GLYPH {
        return None;
    }

"#);

    // Generate line variant logic for pitched notes
    for (name, _base, _count, line_base, _line_count) in &system_ranges {
        if *line_base > 0 {
            code.push_str(&format!(r#"    // {} base → line variant
    if base_cp >= {}_BASE && base_cp < {}_BASE + {}_COUNT {{
        let offset = base_cp - {}_BASE;
        return Some({}_LINE_BASE + (offset * LINE_VARIANTS_PER_GLYPH) + variant_index);
    }}
"#, name, name, name, name, name, name));
        }
    }

    // Generate line variant logic for notation elements
    for (name, _base, line_base) in &element_info {
        if *line_base > 0 {
            code.push_str(&format!(r#"    // {} base → line variant
    if base_cp == {}_BASE {{
        return Some({}_LINE_BASE + variant_index);
    }}
"#, name, name, name));
        }
    }

    code.push_str(r#"
    None
}

// =============================================================================
// LINE VARIANT DECODING (for CharInfo)
// =============================================================================
// Uses UnderlineState and OverlineState already imported in font_utils.rs

/// Decoded line variant information
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub struct DecodedLineVariant {
    /// Base codepoint (without line variant)
    pub base_cp: u32,
    /// Underline state
    pub underline: UnderlineState,
    /// Overline state
    pub overline: OverlineState,
    /// Whether this is a superscript (grace note)
    pub is_superscript: bool,
}

/// Line variant encoding scheme (15 variants per glyph):
///
/// Index | Underline | Overline | Description
/// ------|-----------|----------|------------
///   0   | Middle    | None     | Underline only - middle
///   1   | Left      | None     | Underline only - left cap
///   2   | Right     | None     | Underline only - right cap
///   3   | None      | Middle   | Overline only - middle
///   4   | None      | Left     | Overline only - left cap
///   5   | None      | Right    | Overline only - right cap
///   6   | Middle    | Middle   | Combined - middle/middle
///   7   | Middle    | Left     | Combined - middle/left
///   8   | Middle    | Right    | Combined - middle/right
///   9   | Left      | Middle   | Combined - left/middle
///  10   | Left      | Left     | Combined - left/left
///  11   | Left      | Right    | Combined - left/right
///  12   | Right     | Middle   | Combined - right/middle
///  13   | Right     | Left     | Combined - right/left
///  14   | Right     | Right    | Combined - right/right
///
/// Formula: variant_index = encode(underline, overline)
/// Decode: (underline, overline) = decode(variant_index)

/// Decode a line variant index (0-14) into underline and overline states
///
/// This is the inverse of the encoding used in atoms.yaml line_variant_config.
#[inline]
pub fn decode_line_variant_index(idx: u32) -> (UnderlineState, OverlineState) {
    match idx {
        // Underline only (0-2)
        0 => (UnderlineState::Middle, OverlineState::None),
        1 => (UnderlineState::Left, OverlineState::None),
        2 => (UnderlineState::Right, OverlineState::None),
        // Overline only (3-5)
        3 => (UnderlineState::None, OverlineState::Middle),
        4 => (UnderlineState::None, OverlineState::Left),
        5 => (UnderlineState::None, OverlineState::Right),
        // Combined (6-14): underline × overline
        6 => (UnderlineState::Middle, OverlineState::Middle),
        7 => (UnderlineState::Middle, OverlineState::Left),
        8 => (UnderlineState::Middle, OverlineState::Right),
        9 => (UnderlineState::Left, OverlineState::Middle),
        10 => (UnderlineState::Left, OverlineState::Left),
        11 => (UnderlineState::Left, OverlineState::Right),
        12 => (UnderlineState::Right, OverlineState::Middle),
        13 => (UnderlineState::Right, OverlineState::Left),
        14 => (UnderlineState::Right, OverlineState::Right),
        _ => (UnderlineState::None, OverlineState::None),
    }
}

/// Encode underline and overline states into a line variant index (0-14)
///
/// Returns None for (None, None) since that's the base glyph, not a variant.
#[inline]
pub fn encode_line_variant_index(underline: UnderlineState, overline: OverlineState) -> Option<u32> {
    match (underline, overline) {
        (UnderlineState::None, OverlineState::None) => None, // Base glyph
        // Underline only
        (UnderlineState::Middle, OverlineState::None) => Some(0),
        (UnderlineState::Left, OverlineState::None) => Some(1),
        (UnderlineState::Right, OverlineState::None) => Some(2),
        // Overline only
        (UnderlineState::None, OverlineState::Middle) => Some(3),
        (UnderlineState::None, OverlineState::Left) => Some(4),
        (UnderlineState::None, OverlineState::Right) => Some(5),
        // Combined
        (UnderlineState::Middle, OverlineState::Middle) => Some(6),
        (UnderlineState::Middle, OverlineState::Left) => Some(7),
        (UnderlineState::Middle, OverlineState::Right) => Some(8),
        (UnderlineState::Left, OverlineState::Middle) => Some(9),
        (UnderlineState::Left, OverlineState::Left) => Some(10),
        (UnderlineState::Left, OverlineState::Right) => Some(11),
        (UnderlineState::Right, OverlineState::Middle) => Some(12),
        (UnderlineState::Right, OverlineState::Left) => Some(13),
        (UnderlineState::Right, OverlineState::Right) => Some(14),
    }
}

/// Fully decode a codepoint into base glyph + line states + superscript flag
///
/// This is the main entry point for CharInfo decoding.
///
/// # Returns
/// * `Some(DecodedLineVariant)` - Decoded information
/// * `None` - If codepoint is not recognized
pub fn decode_codepoint(cp: u32) -> Option<DecodedLineVariant> {
    // Check if superscript (0xF8000 - 0xFE03F)
    let is_superscript = cp >= 0xF8000 && cp < 0xFE040;

    if is_superscript {
        // Superscripts have 16 line variants per glyph
        let line_variant_idx = cp % 16;
        let (underline, overline) = decode_superscript_line_variant(line_variant_idx);

        // Get base codepoint by reversing superscript encoding
        // This requires knowing which system it came from
        let base_cp = decode_superscript_base(cp)?;

        return Some(DecodedLineVariant {
            base_cp,
            underline,
            overline,
            is_superscript: true,
        });
    }

    // Check if line variant (has base + variant index)
    if let Some(base_cp) = strip_line_variant(cp) {
        if base_cp != cp {
            // It's a line variant - decode the index
            let variant_idx = decode_line_variant_from_cp(cp)?;
            let (underline, overline) = decode_line_variant_index(variant_idx);
            return Some(DecodedLineVariant {
                base_cp,
                underline,
                overline,
                is_superscript: false,
            });
        }
    }

    // Base glyph (no line variant)
    if is_pitched_note(cp) || is_dash(cp) || is_breath_mark(cp) || is_space(cp) || is_barline(cp) {
        return Some(DecodedLineVariant {
            base_cp: cp,
            underline: UnderlineState::None,
            overline: OverlineState::None,
            is_superscript: false,
        });
    }

    // ASCII printable (0x20-0x7E)
    if cp >= 0x20 && cp <= 0x7E {
        return Some(DecodedLineVariant {
            base_cp: cp,
            underline: UnderlineState::None,
            overline: OverlineState::None,
            is_superscript: false,
        });
    }

    None
}

/// Decode superscript line variant (16 variants: 0-15)
///
/// Superscripts use a different encoding than regular line variants:
/// - 0: None
/// - 1-3: Underline only (left, middle, right)
/// - 4-6: Overline only (left, middle, right)
/// - 7-15: Combined (3 underline × 3 overline)
fn decode_superscript_line_variant(idx: u32) -> (UnderlineState, OverlineState) {
    match idx {
        0 => (UnderlineState::None, OverlineState::None),
        1 => (UnderlineState::Left, OverlineState::None),
        2 => (UnderlineState::Middle, OverlineState::None),
        3 => (UnderlineState::Right, OverlineState::None),
        4 => (UnderlineState::None, OverlineState::Left),
        5 => (UnderlineState::None, OverlineState::Middle),
        6 => (UnderlineState::None, OverlineState::Right),
        7 => (UnderlineState::Left, OverlineState::Left),
        8 => (UnderlineState::Left, OverlineState::Middle),
        9 => (UnderlineState::Left, OverlineState::Right),
        10 => (UnderlineState::Middle, OverlineState::Left),
        11 => (UnderlineState::Middle, OverlineState::Middle),
        12 => (UnderlineState::Middle, OverlineState::Right),
        13 => (UnderlineState::Right, OverlineState::Left),
        14 => (UnderlineState::Right, OverlineState::Middle),
        15 => (UnderlineState::Right, OverlineState::Right),
        _ => (UnderlineState::None, OverlineState::None),
    }
}

/// Decode superscript codepoint to get base (non-superscript) codepoint
fn decode_superscript_base(cp: u32) -> Option<u32> {
    const ASCII_BASE: u32 = 0xF8000;
    const ASCII_END: u32 = 0xF8600;
    const NUMBER_BASE: u32 = 0xF8600;
    const NUMBER_END: u32 = 0xF9400;
    const WESTERN_BASE: u32 = 0xF9400;
    const WESTERN_END: u32 = 0xFAF00;
    const SARGAM_BASE: u32 = 0xFAF00;
    const SARGAM_END: u32 = 0xFC600;
    const DOREMI_BASE: u32 = 0xFC600;
    const DOREMI_END: u32 = 0xFE040;

    const LINE_VARIANTS: u32 = 16;

    if cp >= ASCII_BASE && cp < ASCII_END {
        let offset = (cp - ASCII_BASE) / LINE_VARIANTS;
        return Some(0x20 + offset); // ASCII base
    }
    if cp >= NUMBER_BASE && cp < NUMBER_END {
        let offset = (cp - NUMBER_BASE) / LINE_VARIANTS;
        return Some(0xE000 + offset); // Number PUA base
    }
    if cp >= WESTERN_BASE && cp < WESTERN_END {
        let offset = (cp - WESTERN_BASE) / LINE_VARIANTS;
        return Some(0xE100 + offset); // Western PUA base
    }
    if cp >= SARGAM_BASE && cp < SARGAM_END {
        let offset = (cp - SARGAM_BASE) / LINE_VARIANTS;
        return Some(0xE300 + offset); // Sargam PUA base
    }
    if cp >= DOREMI_BASE && cp < DOREMI_END {
        let offset = (cp - DOREMI_BASE) / LINE_VARIANTS;
        return Some(0xE500 + offset); // Doremi PUA base
    }

    None
}

/// Extract line variant index from a line variant codepoint
fn decode_line_variant_from_cp(cp: u32) -> Option<u32> {
"#);

    // Generate extraction logic for pitched notes
    for (name, _base, _count, line_base, _line_count) in &system_ranges {
        if *line_base > 0 {
            code.push_str(&format!(r#"    if cp >= {}_LINE_BASE && cp < {}_LINE_BASE + {}_LINE_COUNT {{
        return Some((cp - {}_LINE_BASE) % LINE_VARIANTS_PER_GLYPH);
    }}
"#, name, name, name, name));
        }
    }

    // Generate extraction logic for notation elements
    for (name, _base, line_base) in &element_info {
        if *line_base > 0 {
            code.push_str(&format!(r#"    if cp >= {}_LINE_BASE && cp < {}_LINE_BASE + LINE_VARIANTS_PER_GLYPH {{
        return Some(cp - {}_LINE_BASE);
    }}
"#, name, name, name));
        }
    }

    code.push_str(r#"    None
}
"#);

    let dest_file = out_dir.join("beat_element_predicates.rs");
    fs::write(&dest_file, code).expect("Failed to write beat_element_predicates.rs");
}
