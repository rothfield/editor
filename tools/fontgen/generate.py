#!/usr/bin/env python3
"""
Notation Font Generator - Noto Music-based

This is the authoritative font generation tool. It reads from:
  1. fontspec.json (generated by Rust build.rs) - notation systems & PUA allocation
  2. atoms.yaml - geometry, symbols, accidental composites

Outputs:
  1. NotationFont.ttf - Noto Music base + custom octave variants (dots above/below)
  2. NotationFont-map.json - JSON mapping for runtime lookup

Architecture:
  Stage 0: load_fontspec_json() - Load notation systems from fontspec.json (Rust source of truth)
  Stage 1: load_atom_spec() - Parse atoms.yaml for geometry/symbols/accidentals
  Stage 2: assign_codepoints() - Allocate codepoints for custom variants
  Stage 3: build_font() - Open Noto Music, add custom note variants
  Stage 4: build_mapping_json() - Generate runtime mapping
  Stage 5: validate_layout() - Sanity checks

Usage:
  python3 generate.py [--noto-music-font PATH] [--output-dir PATH]
  python3 generate.py --validate-only  (no FontForge needed)
  python3 generate.py --debug-html      (visual specimen)
  python3 generate.py --strict          (fail on errors)
"""

import sys
import os
import json
import argparse
from pathlib import Path
from dataclasses import dataclass, asdict

try:
    import yaml
except ImportError:
    print("ERROR: PyYAML not found.")
    print("Install with: pip install PyYAML")
    sys.exit(1)

# Try to import fontforge (optional for --validate-only)
fontforge = None
try:
    import fontforge
except ImportError:
    pass


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class Geometry:
    """Positioning parameters for dots and symbols"""
    dot_above_gap: int
    dot_below_gap: int
    dot_vertical_step: int
    dot_horizontal_center: bool
    dot_base_x_offset_factor: float  # Multiplier for base dot horizontal offset
    dot_char_adjustments: dict  # Character-specific adjustments {char: factor}
    accidental_scale: float
    accidental_x_offset: int
    accidental_y_offset: int
    barline_scale: float
    ornament_scale: float


@dataclass
class SMuFLSymbol:
    """A symbol from SMuFL standard (Noto Music or Bravura)"""
    glyph_name: str
    label: str
    smufl_codepoint: int
    codepoint_offset: int
    source_font: str = "noto_music"  # "noto_music" or "bravura"
    assigned_codepoint: int = None  # Assigned during allocation


@dataclass
class NoteAtom:
    """A note (base character + variant)"""
    system: str
    character: str
    variant_index: int  # 0=+1dot, 1=+2dots, 2=-1dot, 3=-2dots
    assigned_codepoint: int = None  # Assigned during allocation


@dataclass
class AtomSpec:
    """Complete notation specification"""
    notation_systems: dict  # system_name -> list of characters
    smufl_symbols: list  # List of SMuFLSymbol
    geometry: Geometry
    character_order: str
    pua_start: int = 0xE600  # PUA start codepoint from atoms.yaml
    accidental_composites: dict = None  # Accidental composite configuration from atoms.yaml


@dataclass
class CodepointLayout:
    """Result of codepoint allocation"""
    note_atoms: list  # List of NoteAtom with assigned_codepoint set
    symbols: list  # List of BravuraSymbol with assigned_codepoint set
    notes_range: tuple  # (start, end) codepoint
    symbols_range: tuple  # (start, end) codepoint


# ============================================================================
# Lane Constants - Vertical positioning for underlines/overlines
# ============================================================================
# These define the Y positions for continuous underlines and overlines.
# They are positioned to avoid collision with octave dots:
#   - Dots above: ~700-900 range (varies by character)
#   - Dots below: ~-40 to -200 range (varies by character)
#
# Line thickness is 1/10 of base character height (~723 units average).
# Lane positions:
#   - Underline: Below dots, within font descent
#   - Overline: Above dots, within font ascent
#
# IMPORTANT: Update OS/2 metrics if these change to ensure proper rendering.

LINE_THICKNESS = 72        # 1/10 of base char height (~723 units)
UNDERLINE_Y_BOTTOM = -180  # Below baseline, below any dots
UNDERLINE_Y_TOP = UNDERLINE_Y_BOTTOM + LINE_THICKNESS  # -108
OVERLINE_Y_BOTTOM = 880    # Above most characters and dots
OVERLINE_Y_TOP = OVERLINE_Y_BOTTOM + LINE_THICKNESS    # 952

# Width classes for GPOS mark-based underlines/overlines
# Characters are grouped by width so marks can have appropriate sizes
# Mark widths are slightly larger than class max for seamless overlap
WIDTH_CLASS_NARROW_MAX = 400   # Characters < 400 units
WIDTH_CLASS_MEDIUM_MAX = 700   # Characters 400-700 units
# Wide = everything >= 700

MARK_WIDTH_NARROW = 420   # Covers narrow chars with slight overlap
MARK_WIDTH_MEDIUM = 720   # Covers medium chars with slight overlap
MARK_WIDTH_WIDE = 980     # Covers widest chars (W, M, m, @)

# Loop arc size (quarter circle corners for loop marks)
# Arc height = 15% of font height (UPM = 1000)
ARC_RADIUS = 150  # 15% of 1000 UPM
ARC_STROKE = LINE_THICKNESS  # Same stroke width as underlines (72 units)

# ============================================================================
# PUA Allocation - Centralized system-to-PUA mapping
# ============================================================================
# DEPRECATED: Old underlined/overlined/combined bases at 0x16000+ are obsolete.
# New architecture uses PUA_NOTE_LINE_CONFIG with line_base at 0x1A000+.
# Each note now gets 15 pre-composed line variants (underline/overline/combined).
# See: PUA_NOTE_LINE_CONFIG below and atoms.yaml pitched_note_line_bases section.
#
# Kept for reference - these functions are no longer called:
# - create_underlined_note_variants()
# - create_overlined_note_variants()
# - create_combined_line_note_variants()
SYSTEM_PUA_BASES_DEPRECATED = {
    "number": {
        "base": 0xE000,
        "underlined": 0x16000,  # OBSOLETE - use 0x1A000 via PUA_NOTE_LINE_CONFIG
        "overlined": 0x19000,   # OBSOLETE
        "combined": 0xF2000,    # OBSOLETE
    },
    "western": {
        "base": 0xE100,
        "underlined": 0x16100,
        "overlined": 0x19100,
        "combined": 0xF3000,
    },
    "sargam": {
        "base": 0xE300,
        "underlined": 0x16300,
        "overlined": 0x19300,
        "combined": 0xF4000,
    },
    "doremi": {
        "base": 0xE500,
        "underlined": 0x16500,
        "overlined": 0x19500,
        "combined": 0xF5000,
    },
}


# ============================================================================
# Stage 0: Load FontSpec JSON (from Rust build.rs)
# ============================================================================

def load_fontspec_json(json_path: str, atoms_path: str = None) -> dict:
    """
    Load fontspec.json or generate from atoms.yaml as fallback.

    This provides:
    - Notation systems (names, characters, PUA base)
    - Glyph variant configuration (accidental_types, octave_variants)

    If fontspec.json doesn't exist but atoms_path is provided, generates
    the fontspec data directly from atoms.yaml (single source of truth).

    Returns:
        dict with 'notation_systems' and 'glyph_variants' keys

    Raises:
        FileNotFoundError if neither fontspec.json nor atoms.yaml exists
        ValueError if structure is invalid
    """
    print(f"[STAGE 0] Loading fontspec...")

    if os.path.exists(json_path):
        print(f"  Loading from: {json_path}")
        with open(json_path, 'r') as f:
            fontspec = json.load(f)
    elif atoms_path and os.path.exists(atoms_path):
        # Fallback: generate fontspec from atoms.yaml directly
        print(f"  fontspec.json not found, generating from: {atoms_path}")
        fontspec = _generate_fontspec_from_atoms(atoms_path)
    else:
        raise FileNotFoundError(
            f"fontspec.json not found: {json_path}\n"
            f"  Run 'cargo build' first or ensure atoms.yaml exists at {atoms_path}"
        )

    # Validate structure
    if 'notation_systems' not in fontspec:
        raise ValueError("fontspec missing 'notation_systems'")
    if 'glyph_variants' not in fontspec:
        raise ValueError("fontspec missing 'glyph_variants'")

    # Log systems
    for system in fontspec['notation_systems']:
        chars = ''.join(system['characters'])
        print(f"  ✓ {system['name']}: {len(system['characters'])} characters, "
              f"PUA {hex(system['pua_base'])}")

    gv = fontspec['glyph_variants']
    print(f"  ✓ Glyph variants: {gv['accidental_types']} accidentals × "
          f"{gv['octave_variants']} octaves = "
          f"{gv['accidental_types'] * gv['octave_variants']} variants/char")

    return fontspec


def _generate_fontspec_from_atoms(atoms_path: str) -> dict:
    """Generate fontspec data directly from atoms.yaml (fallback when fontspec.json missing)."""
    with open(atoms_path, 'r') as f:
        atoms = yaml.safe_load(f)

    notation_systems = []
    variants_per_char = 30  # Default: 6 accidentals × 5 octaves

    if 'glyph_variants' in atoms:
        gv = atoms['glyph_variants']
        accidental_types = gv.get('accidental_types', 6)
        octave_variants = gv.get('octave_variants', 5)
        variants_per_char = accidental_types * octave_variants

    for system in atoms.get('notation_systems', []):
        system_name = system.get('system_name', 'unknown')
        pua_base = system.get('pua_base', 0xE000)
        # Handle hex string or int
        if isinstance(pua_base, str):
            pua_base = int(pua_base, 16) if pua_base.startswith('0x') else int(pua_base)

        characters = [
            char_entry.get('char', '?')
            for char_entry in system.get('characters', [])
        ]

        notation_systems.append({
            'name': system_name,
            'characters': characters,
            'pua_base': pua_base,
            'variants_per_char': variants_per_char
        })

    glyph_variants = atoms.get('glyph_variants', {})
    return {
        'notation_systems': notation_systems,
        'glyph_variants': {
            'accidental_types': glyph_variants.get('accidental_types', 6),
            'octave_variants': glyph_variants.get('octave_variants', 5)
        }
    }


# ============================================================================
# Stage 1: Load Atom Specification
# ============================================================================

def load_atom_spec(yaml_path: str, fontspec: dict, selected_system: str = "all") -> AtomSpec:
    """
    Parse atoms.yaml and validate structure.

    Args:
        yaml_path: Path to atoms.yaml
        fontspec: Loaded fontspec.json data
        selected_system: Notation system to generate ("number", "western", "sargam", "doremi", or "all")

    Returns:
        AtomSpec with notation systems, symbols, and geometry

    Raises:
        ValueError if validation fails
    """
    print(f"[STAGE 1] Loading atom specification: {yaml_path}")
    if selected_system != "all":
        print(f"  → Filtering for system: {selected_system}")

    if not os.path.exists(yaml_path):
        raise FileNotFoundError(f"atoms.yaml not found: {yaml_path}")

    with open(yaml_path, 'r') as f:
        config = yaml.safe_load(f)

    # Extract notation systems AND PUA bases from fontspec (Rust source of truth)
    notation_systems = {}
    notation_system_pua_blocks = {}  # Store PUA bases from fontspec
    for system in fontspec['notation_systems']:
        system_name = system['name']

        # Filter by selected system if not "all"
        if selected_system != "all" and system_name != selected_system:
            continue

        characters = system['characters']
        pua_base = system.get('pua_base')  # Extract pua_base
        notation_systems[system_name] = characters
        if pua_base is not None:
            notation_system_pua_blocks[system_name] = pua_base
        # Characters are already loaded from fontspec, no need to print again

    # Reconstruct expected character order from notation systems
    character_order = ''.join(
        ''.join(chars) for chars in notation_systems.values()
    )
    if selected_system == "all":
        print(f"  ✓ Notation systems loaded from fontspec.json")
    else:
        print(f"  ✓ Notation system loaded: {selected_system} ({len(notation_systems[selected_system])} characters)")

    # Extract geometry
    geometry_config = config.get('geometry', {})
    dots_config = geometry_config.get('dots', {})
    symbols_config = geometry_config.get('symbols', {})
    geometry = Geometry(
        dot_above_gap=dots_config.get('above_gap', 50),
        dot_below_gap=dots_config.get('below_gap', 50),
        dot_vertical_step=dots_config.get('vertical_step', 100),
        dot_horizontal_center=dots_config.get('horizontal_center', True),
        dot_base_x_offset_factor=dots_config.get('base_x_offset_factor', 0.8),
        dot_char_adjustments=dots_config.get('char_adjustments', {}),
        accidental_scale=symbols_config.get('accidental_scale', 1.0),
        accidental_x_offset=symbols_config.get('accidental_x_offset', 0),
        accidental_y_offset=symbols_config.get('accidental_y_offset', 0),
        barline_scale=symbols_config.get('barline_scale', 1.0),
        ornament_scale=symbols_config.get('ornament_scale', 1.0),
    )
    print(f"  ✓ Geometry loaded: dot_above_gap={geometry.dot_above_gap}, "
          f"dot_vertical_step={geometry.dot_vertical_step}, "
          f"char_adjustments={len(geometry.dot_char_adjustments)} chars")

    # Extract SMuFL symbols from Noto Music or Bravura
    smufl_symbols = []
    for symbol_def in config.get('smufl_symbols', []):
        smufl_symbols.append(SMuFLSymbol(
            glyph_name=symbol_def['glyph_name'],
            label=symbol_def['label'],
            smufl_codepoint=symbol_def.get('smufl_codepoint', 0),
            codepoint_offset=symbol_def.get('codepoint_offset', 0),
            source_font=symbol_def.get('source_font', 'noto_music'),  # default to noto_music
        ))

    print(f"  ✓ SMuFL symbols: {len(smufl_symbols)}")

    # Extract PUA configuration (supports both old single-block and new per-system)
    pua_config = config.get('pua', {})
    pua_start = pua_config.get('start', 0xE600)
    print(f"  ✓ PUA start (fallback): {hex(pua_start)}")

    # Extract per-system PUA blocks (NEW architecture)
    # Merge atoms.yaml PUA blocks with fontspec (fontspec takes precedence)
    atoms_pua_blocks = config.get('notation_system_pua_blocks', {})
    if atoms_pua_blocks:
        # Merge atoms.yaml into fontspec blocks (fontspec wins on conflicts)
        for sys_name, sys_config in atoms_pua_blocks.items():
            if sys_name not in notation_system_pua_blocks:
                notation_system_pua_blocks[sys_name] = sys_config
    if notation_system_pua_blocks:
        print(f"  ✓ Per-system PUA blocks detected:")
        for sys_name, sys_config in notation_system_pua_blocks.items():
            if isinstance(sys_config, dict) and 'base' in sys_config:
                print(f"    - {sys_name}: {hex(sys_config['base'])} ({sys_config.get('chars', '?')} chars)")

    # Extract accidental composites configuration
    accidental_composites = config.get('accidental_composites', {})
    if accidental_composites:
        print(f"  ✓ Accidental composites configuration loaded")

    # Extract glyph variants configuration (NEW layout: 25 variants per character)
    glyph_variants = config.get('glyph_variants', {})
    variants_per_char = glyph_variants.get('count_per_character', 25)  # Default: 25
    if glyph_variants:
        print(f"  ✓ Glyph variants configuration loaded ({variants_per_char} variants per character)")

    spec = AtomSpec(
        notation_systems=notation_systems,
        smufl_symbols=smufl_symbols,
        geometry=geometry,
        character_order=character_order,
        pua_start=pua_start,
        accidental_composites=accidental_composites,
    )

    # Attach per-system PUA blocks to spec for use in assign_codepoints()
    spec.pua_blocks = notation_system_pua_blocks  # type: ignore
    spec.glyph_variants = glyph_variants  # type: ignore

    return spec


# ============================================================================
# Stage 2: Assign Codepoints
# ============================================================================

def assign_codepoints(spec: AtomSpec) -> CodepointLayout:
    """
    Assign PUA codepoints using per-system architecture.

    Algorithm (NEW - Per-system blocks, group-by-accidental-then-octave, 25 variants):
        1. Read notation_system_pua_blocks from atoms.yaml
        2. For each system, use formula: codepoint = system_base + (accidental_block × N) + (octave_group × N) + char_index
           Where N = number of characters in system (7, 14, 12, 14 for Number, Western, Sargam, Doremi)
        3. Octave order: [0, -2, -1, +1, +2] (MUST match build.rs octave_index mapping)
        4. Accidental order: [natural, flat, double-flat, sharp, double-sharp]
        5. Each character gets 25 codepoints: 5 accidental types × 5 octave variants
        6. Assign symbol codepoints at SMuFL standard codepoints
        7. Return layout with all assignments

    Returns:
        CodepointLayout with all atoms assigned
    """
    print(f"\n[STAGE 2] Assigning PUA codepoints (per-system architecture)")

    note_atoms = []
    all_codepoints_used = []

    # Extract per-system PUA blocks from atoms.yaml
    pua_blocks = {}
    if hasattr(spec, 'pua_blocks'):
        pua_blocks = spec.pua_blocks  # type: ignore

    # Process notation systems in order they appear in atoms.yaml
    for system_name, characters in spec.notation_systems.items():
        # Get PUA base for this system
        # atoms.yaml uses keys like 'number_system', but notation_systems uses 'number'
        system_key_variants = [
            system_name,  # Try 'number' first
            f"{system_name}_system",  # Try 'number_system'
        ]

        system_pua_base = None
        system_pua_config = None

        # Try each variant of the system key
        for key_variant in system_key_variants:
            if key_variant in pua_blocks:
                system_pua_config = pua_blocks[key_variant]
                break

        if system_pua_config:
            if isinstance(system_pua_config, dict) and 'base' in system_pua_config:
                system_pua_base = system_pua_config['base']
            elif isinstance(system_pua_config, int):
                system_pua_base = system_pua_config

        # Fallback: use old sequential architecture if no per-system config found
        if system_pua_base is None:
            print(f"  ⚠ {system_name}: No per-system PUA base found, falling back to sequential")
            system_pua_base = spec.pua_start

        print(f"  Processing {system_name}: PUA base = {hex(system_pua_base)}, {len(characters)} characters")

        num_chars = len(characters)

        # NEW LAYOUT: Group-by-accidental-then-octave (25-variant system)
        # For N characters with 5 accidentals × 5 octave variants:
        # - Naturals (5 octaves): 5N codepoints (0 to 5N-1)
        # - Flats (5 octaves): 5N codepoints (5N to 10N-1)
        # - Double-flats (5 octaves): 5N codepoints (10N to 15N-1)
        # - Sharps (5 octaves): 5N codepoints (15N to 20N-1)
        # - Double-sharps (5 octaves): 5N codepoints (20N to 25N-1)

        # Octave order: 0, -2, -1, +1, +2 (MUST match build.rs octave_idx mapping)
        octave_order = [0, -2, -1, 1, 2]

        # Allocate glyphs for each accidental block
        # CRITICAL: Order MUST match build.rs accidental_offset mapping (lines 434-442 in build.rs)
        # build.rs mapping:
        #   0 => 0 * 5N (Natural)
        #   1 => 1 * 5N (Flat at 5N)
        #   2 => 2 * 5N (Half-flat at 10N)
        #   3 => 3 * 5N (Double-flat at 15N)
        #   4 => 5 * 5N (Double-sharp at 25N)
        #   5 => 4 * 5N (Sharp at 20N)
        acc_blocks = [
            ('natural', 0),       # acc_type_idx 0 → variants 0-4
            ('flat', 1),          # acc_type_idx 1 → variants 5-9
            ('halfflat', 2),      # acc_type_idx 2 → variants 10-14
            ('doubleflat', 3),    # acc_type_idx 3 → variants 15-19
            ('doublesharp', 4),   # acc_type_idx 4 → variants 20-24 (FIXED: was after sharp)
            ('sharp', 5),         # acc_type_idx 5 → variants 25-29 (FIXED: was before doublesharp)
        ]

        for acc_type_idx, (acc_name, block_num) in enumerate(acc_blocks):
            for octave_idx, octave in enumerate(octave_order):
                for char_index, char_entry in enumerate(characters):
                    char = char_entry.get("char", str(char_index)) if isinstance(char_entry, dict) else char_entry

                    # NEW ARCHITECTURE: 30 variants per character
                    # Formula: pua_base + (char_idx × 30) + variant_index
                    # MUST match build.rs formula exactly!
                    variant_index = (acc_type_idx * 5) + octave_idx
                    codepoint = system_pua_base + (char_index * 30) + variant_index

                    # Create atoms for 30 variants (6 accidentals × 5 octaves)
                    # variant_index encodes: (accidental_type × 5) + octave_idx

                    atom = NoteAtom(
                        system=system_name,
                        character=char,
                        variant_index=variant_index,  # 0-24: encodes accidental + octave
                        assigned_codepoint=codepoint
                    )
                    note_atoms.append(atom)

                    all_codepoints_used.append(codepoint)

    notes_start = min(all_codepoints_used) if all_codepoints_used else spec.pua_start
    notes_end = max(all_codepoints_used) if all_codepoints_used else spec.pua_start
    notes_range = (notes_start, notes_end)

    print(f"  ✓ Assigned {len(note_atoms)} note atoms: {hex(notes_start)} - {hex(notes_end)}")

    # Assign symbol codepoints - use SMuFL standard codepoints directly (NOT sequential PUA)
    # SMuFL symbols use their official codepoints from W3C SMuFL specification
    # This ensures barlines render at U+E030, U+E031, U+E040, U+E041, etc.
    symbols_assigned = 0
    for symbol in spec.smufl_symbols:
        # Use the standard SMuFL codepoint directly (from W3C SMuFL spec)
        symbol.assigned_codepoint = symbol.smufl_codepoint
        symbols_assigned += 1

    # Find range for informational purposes only
    if spec.smufl_symbols:
        symbol_cps = [s.smufl_codepoint for s in spec.smufl_symbols]
        symbols_start = min(symbol_cps)
        symbols_end = max(symbol_cps)
        symbols_range = (symbols_start, symbols_end)
    else:
        symbols_range = (None, None)

    print(f"  ✓ Assigned {len(spec.smufl_symbols)} SMuFL symbols at standard codepoints: {hex(symbols_start) if symbols_start else 'none'} - {hex(symbols_end) if symbols_end else 'none'}")

    # Check for PUA overflow
    max_codepoint = max(all_codepoints_used) if all_codepoints_used else 0xE000
    if max_codepoint > 0xF8FF:
        raise OverflowError(
            f"PUA overflow! Used {max_codepoint - 0xE000} codepoints, max is {0xF8FF - 0xE000}"
        )

    return CodepointLayout(
        note_atoms=note_atoms,
        symbols=spec.smufl_symbols,
        notes_range=notes_range,
        symbols_range=symbols_range,
    )


# ============================================================================
# Helper: Create Accidental Composites
# ============================================================================

def add_centered_anchors(font):
    """
    Add centered anchor points for combining mark positioning.

    This enables proper positioning of combining diacritical marks (U+0307, U+0308,
    U+0323, U+0324) which are used in the Text tab for octave indicators.

    TWO PARTS:
    1. Add 'base' anchors to ALL ASCII characters (centered) so combining marks attach
    2. Add 'mark' anchors to combining dots so they match the base anchor names

    CRITICAL: For GPOS mark positioning to work:
    - Base character needs 'base' anchor with name X
    - Combining mark needs 'mark' anchor with SAME name X
    If names don't match, the combining mark won't attach correctly!

    Anchor classes used:
    - Anchor-3: marks above (like combining dot above U+0307)
    - Anchor-0: marks below (like combining dot below U+0323)
    """
    # ALL ASCII printable characters (0x21-0x7E) should support combining marks
    # This includes digits 0-9, letters A-Za-z, and punctuation
    ascii_chars = [chr(c) for c in range(0x21, 0x7F)]  # ! to ~

    anchors_added = 0
    anchors_replaced = 0

    # PART 1: Add centered 'base' anchors to all ASCII characters
    for char in ascii_chars:
        try:
            glyph = font[ord(char)]
            if not glyph:
                continue
            bbox = glyph.boundingBox()
            if not bbox:
                continue

            center_x = (bbox[0] + bbox[2]) / 2
            top_y = bbox[3] + 50      # Above character
            bottom_y = bbox[1] - 50   # Below character

            # Check if glyph already has anchors (letters from Noto Sans do)
            existing_anchors = glyph.anchorPoints if hasattr(glyph, 'anchorPoints') else []
            has_anchor_3 = any(a[0] == 'Anchor-3' for a in existing_anchors) if existing_anchors else False
            has_anchor_0 = any(a[0] == 'Anchor-0' for a in existing_anchors) if existing_anchors else False

            # For characters with existing anchors, we need to remove and re-add
            if has_anchor_3 or has_anchor_0:
                # Remove Anchor-3 and Anchor-0 if they exist
                try:
                    if has_anchor_3:
                        glyph.removeAnchorPoint('Anchor-3')
                except (ValueError, RuntimeError):
                    pass  # Anchor may not exist or already removed
                try:
                    if has_anchor_0:
                        glyph.removeAnchorPoint('Anchor-0')
                except (ValueError, RuntimeError):
                    pass  # Anchor may not exist or already removed

                anchors_replaced += 1

            # Add centered anchors
            # Anchor-3 is used for marks above (like diacritics)
            # Anchor-0 is used for marks below
            try:
                glyph.addAnchorPoint('Anchor-3', 'base', center_x, top_y)
            except Exception as e:
                print(f"    Warning: Could not add top anchor to '{char}': {e}")
            try:
                glyph.addAnchorPoint('Anchor-0', 'base', center_x, bottom_y)
            except Exception as e:
                print(f"    Warning: Could not add bottom anchor to '{char}': {e}")

            anchors_added += 1
        except Exception as e:
            pass  # Skip characters that fail

    # PART 2: Add 'mark' anchors to combining diacritical marks
    # These MUST use the SAME anchor names as the base characters!
    combining_marks = [
        (0x0307, 'Anchor-3', 'above'),  # COMBINING DOT ABOVE
        (0x0308, 'Anchor-3', 'above'),  # COMBINING DIAERESIS (two dots above)
        (0x0323, 'Anchor-0', 'below'),  # COMBINING DOT BELOW
        (0x0324, 'Anchor-0', 'below'),  # COMBINING DIAERESIS BELOW
    ]

    marks_fixed = 0
    for codepoint, anchor_name, position in combining_marks:
        try:
            glyph = font[codepoint]
            if not glyph:
                continue

            bbox = glyph.boundingBox()
            if not bbox:
                continue

            # Combining marks should be centered at x=0 (they position relative to base)
            # The mark anchor Y should be at the attachment point
            center_x = 0  # Marks attach at origin
            if position == 'above':
                # Mark anchor Y = bottom of the mark (where it attaches to base top)
                anchor_y = bbox[1]  # Bottom of combining mark
            else:
                # Mark anchor Y = top of the mark (where it attaches to base bottom)
                anchor_y = bbox[3]  # Top of combining mark

            # Remove existing mark anchor with this name if present
            existing_anchors = glyph.anchorPoints if hasattr(glyph, 'anchorPoints') else []
            has_anchor = any(a[0] == anchor_name and a[1] == 'mark' for a in existing_anchors)
            if has_anchor:
                try:
                    glyph.removeAnchorPoint(anchor_name)
                except (ValueError, RuntimeError):
                    pass  # Anchor may not exist

            # Add the mark anchor with the SAME name as base characters use
            try:
                glyph.addAnchorPoint(anchor_name, 'mark', center_x, anchor_y)
                marks_fixed += 1
            except Exception as e:
                print(f"    Warning: Could not add mark anchor to U+{codepoint:04X}: {e}")

        except Exception as e:
            print(f"    Error processing U+{codepoint:04X}: {e}")

    if anchors_replaced > 0:
        print(f"    Replaced off-center anchors on {anchors_replaced} characters")
    if marks_fixed > 0:
        print(f"    Added matching mark anchors to {marks_fixed} combining characters")

    return anchors_added


def get_width_class(width):
    """
    Classify glyph width into narrow/medium/wide category.

    Returns:
        str: 'narrow', 'medium', or 'wide'
    """
    if width < WIDTH_CLASS_NARROW_MAX:
        return 'narrow'
    elif width < WIDTH_CLASS_MEDIUM_MAX:
        return 'medium'
    else:
        return 'wide'


def add_line_anchors(font):
    """
    Add anchors for underline/overline GPOS mark attachment to ASCII glyphs.

    Adds two anchors to each ASCII printable character:
    - 'Anchor-underline': at (0, UNDERLINE_Y_TOP) for underline marks
    - 'Anchor-overline': at (0, OVERLINE_Y_BOTTOM) for overline marks

    The anchor is at x=0 (left edge) so marks align with glyph start.
    Mark width variants handle the variable character widths.

    Also classifies each glyph by width for later GSUB calt rules.

    Returns:
        dict: Maps width class ('narrow'/'medium'/'wide') to list of glyph names
    """
    print(f"  Adding line anchors for GPOS mark attachment...")

    anchors_added = 0
    width_classes = {'narrow': [], 'medium': [], 'wide': []}

    # Process ASCII printable characters (0x20-0x7E)
    for codepoint in range(0x20, 0x7F):
        try:
            glyph = font[codepoint]
            if not glyph:
                continue

            char = chr(codepoint)
            width = glyph.width

            # Classify by width
            width_class = get_width_class(width)
            width_classes[width_class].append(glyph.glyphname)

            # Add underline anchor at left edge, at top of underline Y position
            try:
                glyph.addAnchorPoint('Anchor-underline', 'base', 0, UNDERLINE_Y_TOP)
            except Exception as e:
                print(f"    Warning: Could not add underline anchor to '{char}': {e}")

            # Add overline anchor at left edge, at bottom of overline Y position
            try:
                glyph.addAnchorPoint('Anchor-overline', 'base', 0, OVERLINE_Y_BOTTOM)
            except Exception as e:
                print(f"    Warning: Could not add overline anchor to '{char}': {e}")

            anchors_added += 1

        except Exception as e:
            pass

    print(f"    ✓ Added line anchors to {anchors_added} ASCII characters")
    print(f"    Width classes: narrow={len(width_classes['narrow'])}, "
          f"medium={len(width_classes['medium'])}, wide={len(width_classes['wide'])}")

    return width_classes


def create_line_mark_variants(font):
    """
    Create width-class variants for underline and overline marks.

    Creates 6 mark glyphs:
    - U+0332 variants: .narrow, .medium, .wide (combining low line)
    - U+0305 variants: .narrow, .medium, .wide (combining overline)

    Each variant is a simple rectangle matching its width class.
    Has zero advance width (combining mark behavior).
    Has 'mark' anchor matching base glyph anchors for GPOS attachment.

    Returns:
        tuple: (underline_variants, overline_variants) - dicts mapping class to codepoint
    """
    print(f"  Creating line mark variants (narrow/medium/wide)...")

    # Codepoints for variants (in PUA, separate from pre-composed glyphs)
    # Using 0xE7F0+ range for mark variants
    UNDERLINE_NARROW = 0xE7F0
    UNDERLINE_MEDIUM = 0xE7F1
    UNDERLINE_WIDE = 0xE7F2
    OVERLINE_NARROW = 0xE7F3
    OVERLINE_MEDIUM = 0xE7F4
    OVERLINE_WIDE = 0xE7F5

    mark_widths = {
        'narrow': MARK_WIDTH_NARROW,
        'medium': MARK_WIDTH_MEDIUM,
        'wide': MARK_WIDTH_WIDE,
    }

    underline_variants = {}
    overline_variants = {}

    # Create underline mark variants
    for i, (width_class, mark_width) in enumerate(mark_widths.items()):
        codepoint = UNDERLINE_NARROW + i
        glyph_name = f"uni0332.{width_class}"

        try:
            glyph = font.createChar(codepoint, glyph_name)
            glyph.clear()

            # Draw rectangle: full mark_width × LINE_THICKNESS
            pen = glyph.glyphPen()
            pen.moveTo((0, UNDERLINE_Y_BOTTOM))
            pen.lineTo((mark_width, UNDERLINE_Y_BOTTOM))
            pen.lineTo((mark_width, UNDERLINE_Y_TOP))
            pen.lineTo((0, UNDERLINE_Y_TOP))
            pen.closePath()
            pen = None

            # Zero advance width (combining mark)
            glyph.width = 0

            # Add mark anchor at left edge, matching base anchor Y
            glyph.addAnchorPoint('Anchor-underline', 'mark', 0, UNDERLINE_Y_TOP)

            glyph.correctDirection()
            underline_variants[width_class] = codepoint

        except Exception as e:
            print(f"    Warning: Could not create {glyph_name}: {e}")

    # Create overline mark variants
    for i, (width_class, mark_width) in enumerate(mark_widths.items()):
        codepoint = OVERLINE_NARROW + i
        glyph_name = f"uni0305.{width_class}"

        try:
            glyph = font.createChar(codepoint, glyph_name)
            glyph.clear()

            # Draw rectangle: full mark_width × LINE_THICKNESS
            pen = glyph.glyphPen()
            pen.moveTo((0, OVERLINE_Y_BOTTOM))
            pen.lineTo((mark_width, OVERLINE_Y_BOTTOM))
            pen.lineTo((mark_width, OVERLINE_Y_TOP))
            pen.lineTo((0, OVERLINE_Y_TOP))
            pen.closePath()
            pen = None

            # Zero advance width (combining mark)
            glyph.width = 0

            # Add mark anchor at left edge, matching base anchor Y
            glyph.addAnchorPoint('Anchor-overline', 'mark', 0, OVERLINE_Y_BOTTOM)

            glyph.correctDirection()
            overline_variants[width_class] = codepoint

        except Exception as e:
            print(f"    Warning: Could not create {glyph_name}: {e}")

    print(f"    ✓ Created {len(underline_variants)} underline + {len(overline_variants)} overline mark variants")

    return underline_variants, overline_variants


def add_line_mark_calt_rules(font, width_classes, underline_variants, overline_variants):
    """
    Add GSUB calt (contextual alternates) rules to select mark variant by width class.

    NOTE: This is currently a stub. FontForge's contextual substitution API requires
    complex rule syntax. For now, we rely on the legacy GSUB ligature approach which
    creates pre-composed underlined/overlined glyphs (char + U+0332 → PUA variant).

    The width-class mark variants (U+E7F0-E7F5) are available for future use when
    we implement proper GPOS mark attachment or more sophisticated OpenType features.

    Args:
        font: FontForge font object
        width_classes: dict mapping 'narrow'/'medium'/'wide' to list of glyph names
        underline_variants: dict mapping width class to underline variant codepoint
        overline_variants: dict mapping width class to overline variant codepoint
    """
    # Log the width class distribution for reference
    narrow_count = len(width_classes.get('narrow', []))
    medium_count = len(width_classes.get('medium', []))
    wide_count = len(width_classes.get('wide', []))

    print(f"  Width-class mark variants ready (narrow={narrow_count}, medium={medium_count}, wide={wide_count})")
    print(f"    Using legacy GSUB ligatures for now (pre-composed underlined glyphs)")

    # Future: Implement GPOS mark-to-base positioning or contextual chain substitution
    # For now, the legacy approach works well and the mark variants are available

    return 0


def create_loop_arc_marks(font):
    """
    Create 4 loop arc mark glyphs for rounded corners of underline/overline loops.

    These are quarter-ring arcs (outer + inner circle) with stroke thickness
    equal to LINE_THICKNESS, designed to attach to our underline/overline lanes.

    Codepoints:
        U+E704: loop_bottom_left   – bottom-left "smiley" cap  (╰)
        U+E705: loop_bottom_right  – bottom-right "smiley" cap (╯)
        U+E706: loop_top_left      – top-left "frown" cap      (╭)
        U+E707: loop_top_right     – top-right "frown" cap     (╮)
    """
    import math

    if font is None:
        return 0

    print("  Creating loop arc mark glyphs...")

    outer_r = ARC_RADIUS
    inner_r = max(outer_r - ARC_STROKE, 1)
    STEPS = 8

    def draw_ring_segment(pen, cx, cy, start_deg, end_deg, clockwise=True):
        start_rad = math.radians(start_deg)
        end_rad = math.radians(end_deg)

        if clockwise:
            if end_rad > start_rad:
                end_rad -= 2 * math.pi
        else:
            if end_rad < start_rad:
                end_rad += 2 * math.pi

        # Outer arc
        pen.moveTo((
            cx + outer_r * math.cos(start_rad),
            cy + outer_r * math.sin(start_rad),
        ))
        for i in range(1, STEPS + 1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((
                cx + outer_r * math.cos(a),
                cy + outer_r * math.sin(a),
            ))

        # Inner arc back
        for i in range(STEPS, -1, -1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((
                cx + inner_r * math.cos(a),
                cy + inner_r * math.sin(a),
            ))

        pen.closePath()

    # -------------------------
    # Bottom-left (works today)
    # -------------------------
    try:
        g_bl = font.createChar(0xE704, "loop_bottom_left")
        g_bl.clear()
        pen = g_bl.glyphPen()

        cx = int(outer_r * 0.5)
        cy = UNDERLINE_Y_BOTTOM + outer_r  # center above underline bottom
        # Quarter from down (270°) to left (180°)
        draw_ring_segment(pen, cx, cy, 270, 180, clockwise=True)

        g_bl.width = 0
        # Base glyph uses Anchor-underline at UNDERLINE_Y_TOP,
        # but we want the cap to attach at the bottom of the lane so it "hangs" below.
        g_bl.addAnchorPoint("Anchor-underline", "mark", 0, UNDERLINE_Y_BOTTOM)
        g_bl.correctDirection()
    except Exception as e:
        print(f"    Warning: could not create loop_bottom_left: {e}")

    # Bottom-right: horizontal mirror of bottom-left
    try:
        g_br = font.createChar(0xE705, "loop_bottom_right")
        g_br.clear()
        if font[0xE704]:
            g_br.addReference(font[0xE704].glyphname, (-1, 0, 0, 1, 0, 0))
        g_br.width = 0
        g_br.addAnchorPoint("Anchor-underline", "mark", 0, UNDERLINE_Y_BOTTOM)
        g_br.correctDirection()
    except Exception as e:
        print(f"    Warning: could not create loop_bottom_right: {e}")

    # -------------------------
    # Top-left: ╭ shape - mirror of bottom-left ╰
    # -------------------------
    try:
        g_tl = font.createChar(0xE706, "loop_top_left")
        g_tl.clear()
        pen = g_tl.glyphPen()

        cx = int(outer_r * 0.5)
        cy = OVERLINE_Y_TOP - outer_r  # center BELOW overline top (inside the bracket)
        # Arc from 90° (up) to 180° (left), counter-clockwise
        # At 90°: Y = cy + outer_r = OVERLINE_Y_TOP (join point at top)
        # At 180°: X = cx - outer_r (extends left)
        # This creates a ╭ shape
        draw_ring_segment(pen, cx, cy, 90, 180, clockwise=False)

        g_tl.width = 0
        g_tl.addAnchorPoint("Anchor-overline", "mark", 0, OVERLINE_Y_TOP)
        g_tl.correctDirection()
    except Exception as e:
        print(f"    Warning: could not create loop_top_left: {e}")

    # Top-right: horizontal mirror of top-left
    try:
        g_tr = font.createChar(0xE707, "loop_top_right")
        g_tr.clear()
        if font[0xE706]:
            g_tr.addReference(font[0xE706].glyphname, (-1, 0, 0, 1, 0, 0))
        g_tr.width = 0
        g_tr.addAnchorPoint("Anchor-overline", "mark", 0, OVERLINE_Y_TOP)
        g_tr.correctDirection()
    except Exception as e:
        print(f"    Warning: could not create loop_top_right: {e}")

    print("    ✓ Loop arc mark glyphs created (U+E704–U+E707)")
    return 0


def create_lined_variants(font, pua_start, y_bottom, y_top, line_name):
    """
    Create pre-composed variants with a horizontal line (underline or overline).

    For ASCII printable characters, create a variant with a line matching the
    character's bounding box width (not full advance width).

    Only processes ASCII printable characters (0x20-0x7E) to avoid PUA overflow.

    Args:
        font: FontForge font object
        pua_start: Starting codepoint in PUA for variants
        y_bottom: Y coordinate for bottom of line
        y_top: Y coordinate for top of line
        line_name: "underline" or "overline" for logging

    Returns:
        dict: Mapping of original codepoint → variant codepoint
    """
    # Only process ASCII printable characters
    # This keeps the range small enough to not overlap with other PUA allocations
    glyphs_to_process = []
    for glyph in font.glyphs():
        if glyph.unicode < 0x20:
            continue
        if glyph.unicode > 0x7E:  # Only ASCII printable
            continue
        glyphs_to_process.append(glyph)

    print(f"    Processing {len(glyphs_to_process)} glyphs for {line_name}d variants...")

    variant_map = {}
    created_count = 0

    for i, base_glyph in enumerate(glyphs_to_process):
        try:
            bbox = base_glyph.boundingBox()
            if not bbox:
                continue

            variant_codepoint = pua_start + i
            glyph_name = f"uni{variant_codepoint:04X}"

            try:
                existing = font[variant_codepoint]
                if existing and existing.glyphname and existing.glyphname != glyph_name:
                    continue
            except (KeyError, TypeError):
                pass  # Glyph doesn't exist yet, which is fine

            variant_glyph = font.createChar(variant_codepoint, glyph_name)
            variant_glyph.clear()
            variant_glyph.addReference(base_glyph.glyphname)
            variant_glyph.unlinkRef()

            pen = variant_glyph.glyphPen(replace=False)
            # Line matches character's visual extent (bbox)
            x_start = int(bbox[0])
            x_end = int(bbox[2])

            pen.moveTo((x_start, y_bottom))
            pen.lineTo((x_end, y_bottom))
            pen.lineTo((x_end, y_top))
            pen.lineTo((x_start, y_top))
            pen.closePath()
            pen = None

            variant_glyph.width = base_glyph.width
            variant_glyph.correctDirection()

            variant_map[base_glyph.unicode] = variant_codepoint
            created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} {line_name}d variants (PUA 0x{pua_start:04X}+)")
    return variant_map


def create_lined_variants_fullwidth(font, pua_start, y_bottom, y_top, line_name):
    """
    Create pre-composed variants with a FULL-WIDTH horizontal line.

    Unlike create_lined_variants (which uses bbox), this creates lines that span
    the full advance width (0 to glyph.width) for seamless joining in brackets.

    Only processes ASCII printable characters (0x20-0x7E) to avoid PUA overflow.

    Args:
        font: FontForge font object
        pua_start: Starting codepoint in PUA for variants
        y_bottom: Y coordinate for bottom of line
        y_top: Y coordinate for top of line
        line_name: "underline" or "overline" for logging

    Returns:
        dict: Mapping of original codepoint → variant codepoint
    """
    # Only process ASCII printable characters for fullwidth variants
    # This keeps the range small enough to not overlap with other PUA allocations
    glyphs_to_process = []
    for glyph in font.glyphs():
        if glyph.unicode < 0x20:
            continue
        if glyph.unicode > 0x7E:  # Only ASCII printable
            continue
        glyphs_to_process.append(glyph)

    print(f"    Processing {len(glyphs_to_process)} glyphs for fullwidth {line_name}d variants...")

    variant_map = {}
    created_count = 0

    for i, base_glyph in enumerate(glyphs_to_process):
        try:
            bbox = base_glyph.boundingBox()
            if not bbox:
                continue

            variant_codepoint = pua_start + i
            glyph_name = f"uni{variant_codepoint:04X}"

            try:
                existing = font[variant_codepoint]
                if existing and existing.glyphname and existing.glyphname != glyph_name:
                    continue
            except (KeyError, TypeError):
                pass  # Glyph doesn't exist yet, which is fine

            variant_glyph = font.createChar(variant_codepoint, glyph_name)
            variant_glyph.clear()
            variant_glyph.addReference(base_glyph.glyphname)
            variant_glyph.unlinkRef()

            pen = variant_glyph.glyphPen(replace=False)
            # Line spans FULL advance width for seamless joining in brackets
            x_start = 0
            x_end = base_glyph.width

            pen.moveTo((x_start, y_bottom))
            pen.lineTo((x_end, y_bottom))
            pen.lineTo((x_end, y_top))
            pen.lineTo((x_start, y_top))
            pen.closePath()
            pen = None

            variant_glyph.width = base_glyph.width
            variant_glyph.correctDirection()

            variant_map[base_glyph.unicode] = variant_codepoint
            created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} fullwidth {line_name}d variants (PUA 0x{pua_start:04X}+)")
    return variant_map


def create_underlined_variants(font):
    """Create pre-composed underlined glyphs (bbox width). PUA 0xE800+."""
    return create_lined_variants(font, 0xE800, UNDERLINE_Y_BOTTOM, UNDERLINE_Y_TOP, "underline")


def create_underlined_variants_fullwidth(font):
    """Create pre-composed fullwidth underlined glyphs. PUA 0xE900+."""
    return create_lined_variants_fullwidth(font, 0xE900, UNDERLINE_Y_BOTTOM, UNDERLINE_Y_TOP, "underline")


def create_underlined_note_variants(font, layout):
    """
    Create underlined variants for ALL note glyphs (naturals with octaves + accidentals).

    Uses explicit PUA allocation from atoms.yaml (not offset formula).
    Each system has a parallel underlined range:
      - Number: 0xE000 → 0x16000
      - Western: 0xE100 → 0x16100
      - Sargam: 0xE300 → 0x16300
      - Doremi: 0xE500 → 0x16500

    Args:
        font: FontForge font object
        layout: CodepointLayout with note_atoms

    Returns:
        dict: Mapping of original PUA codepoint → underlined variant codepoint
    """
    variant_map = {}
    created_count = 0

    for atom in layout.note_atoms:
        try:
            orig_glyph = font[atom.assigned_codepoint]
            if not orig_glyph:
                continue

            bbox = orig_glyph.boundingBox()
            if not bbox:
                continue

            # Find the PUA bases for this system (DEPRECATED - not called anymore)
            if atom.system not in SYSTEM_PUA_BASES_DEPRECATED:
                continue

            system_base = SYSTEM_PUA_BASES_DEPRECATED[atom.system]["base"]
            underlined_base = SYSTEM_PUA_BASES_DEPRECATED[atom.system]["underlined"]

            # Compute underlined codepoint using same formula as base
            # original = system_base + (char_idx × 30) + variant_idx
            # underlined = underlined_base + (char_idx × 30) + variant_idx
            offset_from_base = atom.assigned_codepoint - system_base
            variant_cp = underlined_base + offset_from_base

            glyph_name = f"uni{variant_cp:05X}"

            variant_glyph = font.createChar(variant_cp, glyph_name)
            variant_glyph.clear()

            # Copy the original glyph
            variant_glyph.addReference(orig_glyph.glyphname)
            variant_glyph.unlinkRef()

            # Add underline spanning full advance width (0 to width) for seamless joining
            x_start = 0
            x_end = orig_glyph.width

            pen = variant_glyph.glyphPen(replace=False)
            pen.moveTo((x_start, UNDERLINE_Y_BOTTOM))
            pen.lineTo((x_end, UNDERLINE_Y_BOTTOM))
            pen.lineTo((x_end, UNDERLINE_Y_TOP))
            pen.lineTo((x_start, UNDERLINE_Y_TOP))
            pen.closePath()
            pen = None

            variant_glyph.width = orig_glyph.width
            variant_glyph.correctDirection()

            variant_map[atom.assigned_codepoint] = variant_cp
            created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} underlined note variants (explicit PUA allocation)")
    return variant_map


def create_overlined_note_variants(font, layout):
    """
    Create overlined variants for ALL note glyphs (naturals with octaves + accidentals).

    Parallel to create_underlined_note_variants but for overlines (slurs on superscripts).
    Uses explicit PUA allocation from atoms.yaml (not offset formula).
    Each system has a parallel overlined range:
      - Number: 0xE000 → 0x19000
      - Western: 0xE100 → 0x19100
      - Sargam: 0xE300 → 0x19300
      - Doremi: 0xE500 → 0x19500

    Args:
        font: FontForge font object
        layout: CodepointLayout with note_atoms

    Returns:
        dict: Mapping of original PUA codepoint → overlined variant codepoint
    """
    variant_map = {}
    created_count = 0

    for atom in layout.note_atoms:
        try:
            orig_glyph = font[atom.assigned_codepoint]
            if not orig_glyph:
                continue

            bbox = orig_glyph.boundingBox()
            if not bbox:
                continue

            # Find the PUA bases for this system (DEPRECATED - not called anymore)
            if atom.system not in SYSTEM_PUA_BASES_DEPRECATED:
                continue

            system_base = SYSTEM_PUA_BASES_DEPRECATED[atom.system]["base"]
            overlined_base = SYSTEM_PUA_BASES_DEPRECATED[atom.system]["overlined"]

            # Compute overlined codepoint using same formula as base
            # original = system_base + (char_idx × 30) + variant_idx
            # overlined = overlined_base + (char_idx × 30) + variant_idx
            offset_from_base = atom.assigned_codepoint - system_base
            variant_cp = overlined_base + offset_from_base

            glyph_name = f"uni{variant_cp:05X}"

            variant_glyph = font.createChar(variant_cp, glyph_name)
            variant_glyph.clear()

            # Copy the original glyph
            variant_glyph.addReference(orig_glyph.glyphname)
            variant_glyph.unlinkRef()

            # Add overline spanning full advance width (0 to width) for seamless joining
            x_start = 0
            x_end = orig_glyph.width

            pen = variant_glyph.glyphPen(replace=False)
            pen.moveTo((x_start, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_TOP))
            pen.lineTo((x_start, OVERLINE_Y_TOP))
            pen.closePath()
            pen = None

            variant_glyph.width = orig_glyph.width
            variant_glyph.correctDirection()

            variant_map[atom.assigned_codepoint] = variant_cp
            created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} overlined note variants (explicit PUA allocation)")
    return variant_map


def create_combined_line_note_variants(font, layout):
    """
    DEPRECATED: This function is not called - combined variants are now created by
    create_pua_note_line_variants() which uses the unified 15-variant system at 0x1A000+.

    Create combined underline+overline variants for ALL note glyphs.

    For notes that are both in a beat group (underlined) AND under a slur (overlined).
    Creates 9 variants per note atom: 3 underline states × 3 overline states.

    Line states:
        underline: 0=middle, 1=left, 2=right
        overline:  0=middle, 1=left, 2=right
        combined = (underline_state × 3) + overline_state

    PUA allocation (from atoms.yaml):
        Number:  0xF2000+ (7 × 30 × 9 = 1890 glyphs)
        Western: 0xF3000+ (14 × 30 × 9 = 3780 glyphs)
        Sargam:  0xF4000+ (12 × 30 × 9 = 3240 glyphs)
        Doremi:  0xF5000+ (14 × 30 × 9 = 3780 glyphs)

    Args:
        font: FontForge font object
        layout: CodepointLayout with note_atoms

    Returns:
        dict: Mapping of (original_codepoint, line_variant) → combined variant codepoint
    """
    LINE_STATES = 9  # 3 underline × 3 overline

    variant_map = {}
    created_count = 0

    for atom in layout.note_atoms:
        try:
            orig_glyph = font[atom.assigned_codepoint]
            if not orig_glyph:
                continue

            bbox = orig_glyph.boundingBox()
            if not bbox:
                continue

            # Find the PUA bases for this system (DEPRECATED - not called anymore)
            if atom.system not in SYSTEM_PUA_BASES_DEPRECATED:
                continue

            system_base = SYSTEM_PUA_BASES_DEPRECATED[atom.system]["base"]
            combined_base = SYSTEM_PUA_BASES_DEPRECATED[atom.system]["combined"]

            # Compute offset from system base
            offset_from_base = atom.assigned_codepoint - system_base

            # Create 9 variants for each note atom
            for line_variant in range(LINE_STATES):
                underline_state = line_variant // 3  # 0=middle, 1=left, 2=right
                overline_state = line_variant % 3    # 0=middle, 1=left, 2=right

                # Compute combined codepoint
                # combined_cp = combined_base + (offset × 9) + line_variant
                variant_cp = combined_base + (offset_from_base * LINE_STATES) + line_variant

                glyph_name = f"uni{variant_cp:05X}"

                variant_glyph = font.createChar(variant_cp, glyph_name)
                variant_glyph.clear()

                # Copy the original glyph
                variant_glyph.addReference(orig_glyph.glyphname)
                variant_glyph.unlinkRef()

                # Add underline spanning full advance width
                x_start = 0
                x_end = orig_glyph.width

                pen = variant_glyph.glyphPen(replace=False)

                # Draw underline
                pen.moveTo((x_start, UNDERLINE_Y_BOTTOM))
                pen.lineTo((x_end, UNDERLINE_Y_BOTTOM))
                pen.lineTo((x_end, UNDERLINE_Y_TOP))
                pen.lineTo((x_start, UNDERLINE_Y_TOP))
                pen.closePath()

                # Draw overline
                pen.moveTo((x_start, OVERLINE_Y_BOTTOM))
                pen.lineTo((x_end, OVERLINE_Y_BOTTOM))
                pen.lineTo((x_end, OVERLINE_Y_TOP))
                pen.lineTo((x_start, OVERLINE_Y_TOP))
                pen.closePath()

                pen = None

                variant_glyph.width = orig_glyph.width
                variant_glyph.correctDirection()

                variant_map[(atom.assigned_codepoint, line_variant)] = variant_cp
                created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} combined line note variants (9 per atom)")
    return variant_map


def create_bracketed_variants(font, pua_base, y_bottom, y_top, line_name, is_overline=False):
    """
    Create pre-composed bracket variants with arcs sized to character width.

    Creates 2 variant types for ASCII printable characters:
        pua_base + 0x00: Left arc + line (char starts bracket)
        pua_base + 0x60: Line + right arc (char ends bracket)

    Args:
        font: FontForge font object
        pua_base: Starting codepoint (0xEA00 for underline, 0xEE00 for overline)
        y_bottom: Y coordinate for bottom of line
        y_top: Y coordinate for top of line
        line_name: "underline" or "overline" for logging
        is_overline: True for overline (arcs curve up), False for underline (arcs curve down)

    Returns:
        dict: Mapping of (variant_type, base_codepoint) → variant_codepoint
    """
    import math

    # Line geometry
    line_y_center = (y_bottom + y_top) / 2
    line_thickness = y_top - y_bottom

    def draw_quarter_arc(pen, cx, cy, radius, start_deg, end_deg, clockwise=True):
        """Draw a quarter-circle arc (ring segment with stroke thickness)."""
        outer_r = radius
        inner_r = max(radius - line_thickness, 1)
        STEPS = 8

        start_rad = math.radians(start_deg)
        end_rad = math.radians(end_deg)

        if clockwise:
            if end_rad > start_rad:
                end_rad -= 2 * math.pi
        else:
            if end_rad < start_rad:
                end_rad += 2 * math.pi

        # Outer arc
        pen.moveTo((
            cx + outer_r * math.cos(start_rad),
            cy + outer_r * math.sin(start_rad),
        ))
        for i in range(1, STEPS + 1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((
                cx + outer_r * math.cos(a),
                cy + outer_r * math.sin(a),
            ))

        # Inner arc back
        for i in range(STEPS, -1, -1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((
                cx + inner_r * math.cos(a),
                cy + inner_r * math.sin(a),
            ))

        pen.closePath()

    variant_map = {}
    created_count = 0

    for base_cp in range(0x20, 0x7F):  # ASCII printable
        try:
            base_glyph = font[base_cp]
            if not base_glyph:
                continue

            offset = base_cp - 0x20
            char_width = base_glyph.width
            # Arc radius should be small (like line thickness) so the line spans most of the char
            # Using line_thickness * 2 gives a visually pleasing small curve at corners
            arc_radius = min(line_thickness * 2, char_width / 4)  # Cap at 1/4 char width for narrow chars

            # Arc centers and angles depend on line type
            if is_overline:
                # Overline: arcs curve upward (like ╭ and ╮)
                # Left arc: center at (arc_radius, y_top - arc_radius), arc from 90° to 180°
                # Right arc: center at (width - arc_radius, y_top - arc_radius), arc from 90° to 0°
                left_cx = arc_radius
                left_cy = y_top - arc_radius
                left_start, left_end, left_cw = 90, 180, False
                right_cx = char_width - arc_radius
                right_cy = y_top - arc_radius
                right_start, right_end, right_cw = 90, 0, True
            else:
                # Underline: arcs curve downward (like ╰ and ╯)
                # Left arc: center at (arc_radius, y_bottom + arc_radius), arc from 270° to 180°
                # Right arc: center at (width - arc_radius, y_bottom + arc_radius), arc from 270° to 360°
                left_cx = arc_radius
                left_cy = y_bottom + arc_radius
                left_start, left_end, left_cw = 270, 180, True
                right_cx = char_width - arc_radius
                right_cy = y_bottom + arc_radius
                right_start, right_end, right_cw = 270, 360, False

            # Create 2 variants for this character (no 'both' - single notes don't get lines)
            variants = [
                (pua_base + offset, 'left'),           # Left arc + line
                (pua_base + 0x60 + offset, 'right'),   # Line + right arc
            ]

            for variant_cp, variant_type in variants:
                glyph_name = f"uni{variant_cp:04X}"

                try:
                    existing = font[variant_cp]
                    if existing and existing.glyphname and existing.glyphname != glyph_name:
                        continue
                except (KeyError, TypeError):
                    pass  # Glyph doesn't exist yet, which is fine

                variant_glyph = font.createChar(variant_cp, glyph_name)
                variant_glyph.clear()

                # Add reference to base character
                variant_glyph.addReference(base_glyph.glyphname)
                variant_glyph.unlinkRef()

                pen = variant_glyph.glyphPen(replace=False)

                # Draw line segment(s) and arc(s) based on variant type
                if variant_type == 'left':
                    # Left arc + line extending to right edge
                    # Arc on left
                    draw_quarter_arc(pen, left_cx, left_cy, arc_radius, left_start, left_end, left_cw)
                    # Line from arc end to right edge
                    line_x_start = arc_radius  # Where arc meets line
                    line_x_end = char_width
                    pen.moveTo((line_x_start, y_bottom))
                    pen.lineTo((line_x_end, y_bottom))
                    pen.lineTo((line_x_end, y_top))
                    pen.lineTo((line_x_start, y_top))
                    pen.closePath()

                elif variant_type == 'right':
                    # Line from left edge + right arc
                    # Line from left edge to arc start
                    line_x_start = 0
                    line_x_end = char_width - arc_radius  # Where line meets arc
                    pen.moveTo((line_x_start, y_bottom))
                    pen.lineTo((line_x_end, y_bottom))
                    pen.lineTo((line_x_end, y_top))
                    pen.lineTo((line_x_start, y_top))
                    pen.closePath()
                    # Arc on right
                    draw_quarter_arc(pen, right_cx, right_cy, arc_radius, right_start, right_end, right_cw)

                pen = None
                variant_glyph.width = char_width
                variant_glyph.correctDirection()

                variant_map[(variant_type, base_cp)] = variant_cp
                created_count += 1

        except Exception as e:
            print(f"    Warning: could not create bracket variant for 0x{base_cp:02X}: {e}")

    print(f"    ✓ Created {created_count} {line_name} bracket variants (PUA 0x{pua_base:04X}+)")
    return variant_map


def create_pua_bracketed_variants(font, pua_base, source_range_start, source_range_end, y_bottom, y_top, line_name, is_overline=False):
    """
    Create pre-composed bracket variants for PUA note atoms (octave variants, etc.).

    Creates 2 variant types for PUA glyphs in the given range:
        pua_base + 0x000: Left arc + line (char starts bracket)
        pua_base + count: Line + right arc (char ends bracket)

    Args:
        font: FontForge font object
        pua_base: Starting codepoint for bracket variants (e.g., 0xF000)
        source_range_start: Start of source PUA range (e.g., 0xE600)
        source_range_end: End of source PUA range (e.g., 0xE6BC)
        y_bottom: Y coordinate for bottom of line
        y_top: Y coordinate for top of line
        line_name: "underline" or "overline" for logging
        is_overline: True for overline (arcs curve up), False for underline (arcs curve down)

    Returns:
        dict: Mapping of (variant_type, source_codepoint) → variant_codepoint
    """
    import math

    # Line geometry
    line_y_center = (y_bottom + y_top) / 2
    line_thickness = y_top - y_bottom

    def draw_quarter_arc(pen, cx, cy, radius, start_deg, end_deg, clockwise=True):
        """Draw a quarter-circle arc (ring segment with stroke thickness)."""
        outer_r = radius
        inner_r = max(radius - line_thickness, 1)
        STEPS = 8

        start_rad = math.radians(start_deg)
        end_rad = math.radians(end_deg)

        if clockwise:
            if end_rad > start_rad:
                end_rad -= 2 * math.pi
        else:
            if end_rad < start_rad:
                end_rad += 2 * math.pi

        # Outer arc
        pen.moveTo((
            cx + outer_r * math.cos(start_rad),
            cy + outer_r * math.sin(start_rad),
        ))
        for i in range(1, STEPS + 1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((
                cx + outer_r * math.cos(a),
                cy + outer_r * math.sin(a),
            ))

        # Inner arc back
        for i in range(STEPS, -1, -1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((
                cx + inner_r * math.cos(a),
                cy + inner_r * math.sin(a),
            ))

        pen.closePath()

    variant_map = {}
    created_count = 0

    for source_cp in range(source_range_start, source_range_end):
        try:
            source_glyph = font[source_cp]
            if not source_glyph:
                continue

            offset = source_cp - source_range_start
            char_width = source_glyph.width
            if char_width <= 0:
                continue

            # Arc radius should be small (like line thickness) so the line spans most of the char
            arc_radius = min(line_thickness * 2, char_width / 4)

            # Arc centers and angles depend on line type
            if is_overline:
                left_cx = arc_radius
                left_cy = y_top - arc_radius
                left_start, left_end, left_cw = 90, 180, False
                right_cx = char_width - arc_radius
                right_cy = y_top - arc_radius
                right_start, right_end, right_cw = 90, 0, True
            else:
                left_cx = arc_radius
                left_cy = y_bottom + arc_radius
                left_start, left_end, left_cw = 270, 180, True
                right_cx = char_width - arc_radius
                right_cy = y_bottom + arc_radius
                right_start, right_end, right_cw = 270, 360, False

            # Create 2 variants for this character (no 'both' - single notes don't get lines)
            # Right variants start at pua_base + count (passed via source_range)
            count = source_range_end - source_range_start
            variants = [
                (pua_base + offset, 'left'),               # Left arc + line
                (pua_base + count + offset, 'right'),      # Line + right arc
            ]

            for variant_cp, variant_type in variants:
                glyph_name = f"uni{variant_cp:04X}"

                try:
                    existing = font[variant_cp]
                    if existing and existing.glyphname and existing.glyphname != glyph_name:
                        continue
                except (KeyError, TypeError):
                    pass  # Glyph doesn't exist yet, which is fine

                variant_glyph = font.createChar(variant_cp, glyph_name)
                variant_glyph.clear()

                # Get BASE glyph (not underlined) - underlined is base + 0x8000
                base_cp = source_cp - 0x8000
                try:
                    base_glyph = font[base_cp]
                    variant_glyph.addReference(base_glyph.glyphname)
                except (KeyError, TypeError):
                    # Fallback to source if base not found
                    variant_glyph.addReference(source_glyph.glyphname)
                variant_glyph.unlinkRef()

                pen = variant_glyph.glyphPen(replace=False)

                # Draw underline with rounded end(s) - rounded rectangle style
                if variant_type == 'left':
                    # Left rounded, right straight: arc + line to right edge
                    draw_quarter_arc(pen, left_cx, left_cy, arc_radius, left_start, left_end, left_cw)
                    # Line from arc end to right edge
                    pen.moveTo((arc_radius, y_bottom))
                    pen.lineTo((char_width, y_bottom))
                    pen.lineTo((char_width, y_top))
                    pen.lineTo((arc_radius, y_top))
                    pen.closePath()
                elif variant_type == 'right':
                    # Left straight, right rounded: line from left + arc
                    pen.moveTo((0, y_bottom))
                    pen.lineTo((char_width - arc_radius, y_bottom))
                    pen.lineTo((char_width - arc_radius, y_top))
                    pen.lineTo((0, y_top))
                    pen.closePath()
                    draw_quarter_arc(pen, right_cx, right_cy, arc_radius, right_start, right_end, right_cw)

                pen = None
                variant_glyph.width = char_width
                variant_glyph.correctDirection()

                variant_map[(variant_type, source_cp)] = variant_cp
                created_count += 1

        except Exception as e:
            print(f"    Warning: could not create PUA bracket variant for 0x{source_cp:04X}: {e}")

    print(f"    ✓ Created {created_count} {line_name} PUA bracket variants (PUA 0x{pua_base:04X}+)")
    return variant_map


def add_underline_ligatures(font, underline_map):
    """
    Add GSUB ligatures: char + U+0332 → underlined variant.

    When text contains a character followed by COMBINING LOW LINE (U+0332),
    the ligature feature substitutes the pair with a single pre-composed
    underlined glyph.

    Args:
        font: FontForge font object
        underline_map: Dict mapping original codepoint → underlined variant codepoint
    """
    if not underline_map:
        print(f"    No underline mappings to create ligatures for")
        return 0

    COMBINING_LOW_LINE = 0x0332

    # Ensure combining low line exists in font
    try:
        combining_glyph = font[COMBINING_LOW_LINE]
        if not combining_glyph:
            print(f"    Warning: U+0332 COMBINING LOW LINE not found in font")
            return 0
        combining_name = combining_glyph.glyphname
    except (KeyError, TypeError) as e:
        print(f"    Warning: Could not access U+0332 COMBINING LOW LINE: {e}")
        return 0

    # Create ligature lookup table
    lookup_name = "liga_underline"
    subtable_name = "liga_underline_sub"

    try:
        # Add lookup for ligature substitution
        # ('liga', ...) registers this as a standard ligature feature
        font.addLookup(lookup_name, 'gsub_ligature', (),
                       (('liga', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_name, subtable_name)
    except Exception as e:
        print(f"    Warning: Could not create GSUB lookup: {e}")
        return 0

    # Add ligature for each character
    ligatures_added = 0
    for orig_cp, underlined_cp in underline_map.items():
        try:
            base_glyph = font[orig_cp]
            underlined_glyph = font[underlined_cp]

            if not base_glyph or not underlined_glyph:
                continue

            # Add ligature substitution: base + combining → underlined
            # The tuple specifies the input sequence (base glyph name, combining mark name)
            underlined_glyph.addPosSub(subtable_name, (base_glyph.glyphname, combining_name))
            ligatures_added += 1

        except Exception as e:
            # Skip failures silently
            pass

    print(f"    ✓ Added {ligatures_added} GSUB ligatures (char + U+0332 → underlined)")
    return ligatures_added


def create_overlined_variants(font):
    """Create pre-composed overlined glyphs (bbox width). PUA 0xEC00+."""
    return create_lined_variants(font, 0xEC00, OVERLINE_Y_BOTTOM, OVERLINE_Y_TOP, "overline")


def create_combined_lined_variants(font):
    """
    Create pre-composed variants with BOTH underline and overline.

    For ASCII printable characters, create a variant with both lines matching
    the character's bounding box width (not full advance width).

    Only processes ASCII printable characters (0x20-0x7E) to avoid PUA overflow.

    PUA allocation: 0xEA00+ (95 characters)

    Returns:
        dict: Mapping of original codepoint → combined variant codepoint
    """
    PUA_START = 0xEA00

    # Only process ASCII printable characters
    glyphs_to_process = []
    for glyph in font.glyphs():
        if glyph.unicode < 0x20:
            continue
        if glyph.unicode > 0x7E:  # Only ASCII printable
            continue
        glyphs_to_process.append(glyph)

    print(f"    Processing {len(glyphs_to_process)} glyphs for combined underline+overline variants...")

    variant_map = {}
    created_count = 0

    for i, base_glyph in enumerate(glyphs_to_process):
        try:
            bbox = base_glyph.boundingBox()
            if not bbox:
                continue

            variant_codepoint = PUA_START + i
            glyph_name = f"uni{variant_codepoint:04X}"

            try:
                existing = font[variant_codepoint]
                if existing and existing.glyphname and existing.glyphname != glyph_name:
                    continue
            except (KeyError, TypeError):
                pass  # Glyph doesn't exist yet, which is fine

            variant_glyph = font.createChar(variant_codepoint, glyph_name)
            variant_glyph.clear()
            variant_glyph.addReference(base_glyph.glyphname)
            variant_glyph.unlinkRef()

            pen = variant_glyph.glyphPen(replace=False)
            # Line matches character's visual extent (bbox)
            x_start = int(bbox[0])
            x_end = int(bbox[2])

            # Draw underline
            pen.moveTo((x_start, UNDERLINE_Y_BOTTOM))
            pen.lineTo((x_end, UNDERLINE_Y_BOTTOM))
            pen.lineTo((x_end, UNDERLINE_Y_TOP))
            pen.lineTo((x_start, UNDERLINE_Y_TOP))
            pen.closePath()

            # Draw overline
            pen.moveTo((x_start, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_TOP))
            pen.lineTo((x_start, OVERLINE_Y_TOP))
            pen.closePath()

            pen = None

            variant_glyph.width = base_glyph.width
            variant_glyph.correctDirection()

            variant_map[base_glyph.unicode] = variant_codepoint
            created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} combined underline+overline variants (PUA 0x{PUA_START:04X}+)")
    return variant_map


def create_combined_lined_variants_fullwidth(font):
    """
    Create pre-composed variants with BOTH underline and overline (FULL-WIDTH).

    Unlike create_combined_lined_variants (which uses bbox), this creates lines
    that span the full advance width (0 to glyph.width) for seamless joining.

    Only processes ASCII printable characters (0x20-0x7E) to avoid PUA overflow.

    PUA allocation: 0xEB00+ (95 characters)

    Returns:
        dict: Mapping of original codepoint → combined variant codepoint
    """
    PUA_START = 0xEB00

    # Only process ASCII printable characters
    glyphs_to_process = []
    for glyph in font.glyphs():
        if glyph.unicode < 0x20:
            continue
        if glyph.unicode > 0x7E:  # Only ASCII printable
            continue
        glyphs_to_process.append(glyph)

    print(f"    Processing {len(glyphs_to_process)} glyphs for fullwidth combined variants...")

    variant_map = {}
    created_count = 0

    for i, base_glyph in enumerate(glyphs_to_process):
        try:
            bbox = base_glyph.boundingBox()
            if not bbox:
                continue

            variant_codepoint = PUA_START + i
            glyph_name = f"uni{variant_codepoint:04X}"

            try:
                existing = font[variant_codepoint]
                if existing and existing.glyphname and existing.glyphname != glyph_name:
                    continue
            except (KeyError, TypeError):
                pass  # Glyph doesn't exist yet, which is fine

            variant_glyph = font.createChar(variant_codepoint, glyph_name)
            variant_glyph.clear()
            variant_glyph.addReference(base_glyph.glyphname)
            variant_glyph.unlinkRef()

            pen = variant_glyph.glyphPen(replace=False)
            # Line spans FULL advance width for seamless joining
            x_start = 0
            x_end = base_glyph.width

            # Draw underline
            pen.moveTo((x_start, UNDERLINE_Y_BOTTOM))
            pen.lineTo((x_end, UNDERLINE_Y_BOTTOM))
            pen.lineTo((x_end, UNDERLINE_Y_TOP))
            pen.lineTo((x_start, UNDERLINE_Y_TOP))
            pen.closePath()

            # Draw overline
            pen.moveTo((x_start, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_TOP))
            pen.lineTo((x_start, OVERLINE_Y_TOP))
            pen.closePath()

            pen = None

            variant_glyph.width = base_glyph.width
            variant_glyph.correctDirection()

            variant_map[base_glyph.unicode] = variant_codepoint
            created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} fullwidth combined variants (PUA 0x{PUA_START:04X}+)")
    return variant_map


def create_overlined_accidental_variants(font, layout):
    """
    Create overlined variants for accidental note glyphs (sharp, flat, etc.).

    Similar to create_underlined_accidental_variants but for overlines (slurs).

    Args:
        font: FontForge font object
        layout: CodepointLayout with note_atoms

    Returns:
        dict: Mapping of original PUA codepoint → overlined variant codepoint
    """
    # Use 0xEF80+ range for overlined accidental variants
    # (after underlined accidental variants at 0xEF00)
    PUA_BASE = 0xEF80
    SARGAM_NO_ACCIDENTALS = {'r', 'g', 'm', 'd', 'n', 'M'}

    variant_map = {}
    created_count = 0

    for atom in layout.note_atoms:
        # Only process atoms with accidentals
        acc_type = atom.variant_index // 5
        if acc_type == 0:  # Natural (no accidental)
            continue

        # Skip Sargam komal/tivra notes
        if atom.character in SARGAM_NO_ACCIDENTALS:
            continue

        try:
            orig_glyph = font[atom.assigned_codepoint]
            if not orig_glyph:
                continue

            bbox = orig_glyph.boundingBox()
            if not bbox:
                continue

            # Create overlined variant
            variant_cp = PUA_BASE + created_count
            glyph_name = f"uni{variant_cp:04X}"

            variant_glyph = font.createChar(variant_cp, glyph_name)
            variant_glyph.clear()

            # Reference the original accidental composite
            variant_glyph.addReference(orig_glyph.glyphname)
            variant_glyph.unlinkRef()

            # Add overline matching the glyph's bounding box width
            x_start = int(bbox[0])
            x_end = int(bbox[2])

            pen = variant_glyph.glyphPen(replace=False)
            pen.moveTo((x_start, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_BOTTOM))
            pen.lineTo((x_end, OVERLINE_Y_TOP))
            pen.lineTo((x_start, OVERLINE_Y_TOP))
            pen.closePath()
            pen = None

            variant_glyph.width = orig_glyph.width
            variant_glyph.correctDirection()

            variant_map[atom.assigned_codepoint] = variant_cp
            created_count += 1

        except Exception as e:
            pass

    print(f"    ✓ Created {created_count} overlined accidental variants (PUA 0x{PUA_BASE:04X}+)")
    return variant_map


def create_overlined_variants_fullwidth(font):
    """Create pre-composed fullwidth overlined glyphs. PUA 0xED00+."""
    return create_lined_variants_fullwidth(font, 0xED00, OVERLINE_Y_BOTTOM, OVERLINE_Y_TOP, "overline")


def create_fullwidth_combining_marks(font):
    """
    Create custom combining marks for fullwidth lines at U+E7E0 and U+E7E1.

    These are used in brackets where seamless joining is required:
    - U+E7E0: COMBINING FULLWIDTH OVERLINE (triggers advance-width overline)
    - U+E7E1: COMBINING FULLWIDTH UNDERLINE (triggers advance-width underline)

    Unlike standard U+0305/U+0332, these produce lines that span the full
    advance width for seamless joining in brackets.
    """
    FULLWIDTH_OVERLINE = 0xE7E0
    FULLWIDTH_UNDERLINE = 0xE7E1

    # Create zero-width combining mark for fullwidth overline
    glyph = font.createChar(FULLWIDTH_OVERLINE, "combiningFullwidthOverline")
    glyph.width = 0  # Zero-width combining mark
    glyph.glyphclass = "mark"  # Must be 'mark' class for GSUB ligatures to fire
    # The actual overline is drawn by GSUB substitution, not by this glyph
    print(f"    ✓ Created U+E7E0 COMBINING FULLWIDTH OVERLINE (mark class)")

    # Create zero-width combining mark for fullwidth underline
    glyph = font.createChar(FULLWIDTH_UNDERLINE, "combiningFullwidthUnderline")
    glyph.width = 0  # Zero-width combining mark
    glyph.glyphclass = "mark"  # Must be 'mark' class for GSUB ligatures to fire
    print(f"    ✓ Created U+E7E1 COMBINING FULLWIDTH UNDERLINE (mark class)")

    return FULLWIDTH_OVERLINE, FULLWIDTH_UNDERLINE


def add_fullwidth_underline_ligatures(font, fullwidth_underline_map):
    """
    Add GSUB ligatures: char + U+E7E1 → fullwidth underlined variant.

    Similar to add_underline_ligatures but uses custom combining mark U+E7E1
    for fullwidth (advance-width) underlines used in brackets.
    """
    if not fullwidth_underline_map:
        print(f"    No fullwidth underline mappings to create ligatures for")
        return 0

    COMBINING_FULLWIDTH_UNDERLINE = 0xE7E1

    # Ensure combining mark exists
    try:
        combining_glyph = font[COMBINING_FULLWIDTH_UNDERLINE]
        if not combining_glyph:
            print(f"    Warning: U+E7E1 not found in font")
            return 0
        combining_name = combining_glyph.glyphname
    except (KeyError, TypeError) as e:
        print(f"    Warning: Could not access U+E7E1: {e}")
        return 0

    # Create ligature lookup table
    lookup_name = "liga_fullwidth_underline"
    subtable_name = "liga_fullwidth_underline_sub"

    try:
        font.addLookup(lookup_name, 'gsub_ligature', (),
                       (('liga', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_name, subtable_name)
    except Exception as e:
        print(f"    Warning: Could not create GSUB lookup for fullwidth underline: {e}")
        return 0

    ligatures_added = 0
    for orig_cp, underlined_cp in fullwidth_underline_map.items():
        try:
            base_glyph = font[orig_cp]
            underlined_glyph = font[underlined_cp]

            if not base_glyph or not underlined_glyph:
                continue

            underlined_glyph.addPosSub(subtable_name, (base_glyph.glyphname, combining_name))
            ligatures_added += 1
        except Exception as e:
            pass

    print(f"    ✓ Added {ligatures_added} GSUB ligatures (char + U+E7E1 → fullwidth underlined)")
    return ligatures_added


def add_fullwidth_overline_ligatures(font, fullwidth_overline_map):
    """
    Add GSUB ligatures: char + U+E7E0 → fullwidth overlined variant.

    Similar to add_overline_ligatures but uses custom combining mark U+E7E0
    for fullwidth (advance-width) overlines used in brackets.
    """
    if not fullwidth_overline_map:
        print(f"    No fullwidth overline mappings to create ligatures for")
        return 0

    COMBINING_FULLWIDTH_OVERLINE = 0xE7E0

    # Ensure combining mark exists
    try:
        combining_glyph = font[COMBINING_FULLWIDTH_OVERLINE]
        if not combining_glyph:
            print(f"    Warning: U+E7E0 not found in font")
            return 0
        combining_name = combining_glyph.glyphname
    except (KeyError, TypeError) as e:
        print(f"    Warning: Could not access U+E7E0: {e}")
        return 0

    # Create ligature lookup table
    lookup_name = "liga_fullwidth_overline"
    subtable_name = "liga_fullwidth_overline_sub"

    try:
        font.addLookup(lookup_name, 'gsub_ligature', (),
                       (('liga', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_name, subtable_name)
    except Exception as e:
        print(f"    Warning: Could not create GSUB lookup for fullwidth overline: {e}")
        return 0

    ligatures_added = 0
    for orig_cp, overlined_cp in fullwidth_overline_map.items():
        try:
            base_glyph = font[orig_cp]
            overlined_glyph = font[overlined_cp]

            if not base_glyph or not overlined_glyph:
                continue

            overlined_glyph.addPosSub(subtable_name, (base_glyph.glyphname, combining_name))
            ligatures_added += 1
        except Exception as e:
            pass

    print(f"    ✓ Added {ligatures_added} GSUB ligatures (char + U+E7E0 → fullwidth overlined)")
    return ligatures_added


def reposition_combining_marks(font):
    """
    Reposition the combining overline and underline glyphs to match our lane system.

    This ensures that even when GSUB ligatures don't fire (in some renderers),
    the fallback combining mark positioning will still be at the correct height.

    Uses global lane constants defined at module level:
      OVERLINE_Y_BOTTOM, OVERLINE_Y_TOP
      UNDERLINE_Y_BOTTOM, UNDERLINE_Y_TOP
    """
    COMBINING_OVERLINE = 0x0305
    COMBINING_UNDERLINE = 0x0332

    # Uses global lane constants defined at module level

    modified = 0

    # Reposition combining overline
    try:
        g = font[COMBINING_OVERLINE]
        if g:
            bbox = g.boundingBox()
            old_y_min, old_y_max = bbox[1], bbox[3]

            # Clear and redraw at new position
            g.clear()
            pen = g.glyphPen()

            # Draw a horizontal bar centered at x=0 (combining marks have 0 width)
            # Use a width that will look good when combined with typical characters
            half_width = 300  # Will extend from -300 to +300

            pen.moveTo((-half_width, OVERLINE_Y_BOTTOM))
            pen.lineTo((half_width, OVERLINE_Y_BOTTOM))
            pen.lineTo((half_width, OVERLINE_Y_TOP))
            pen.lineTo((-half_width, OVERLINE_Y_TOP))
            pen.closePath()
            pen = None

            g.width = 0  # Combining marks have zero advance width
            g.correctDirection()

            print(f"    Repositioned U+0305 COMBINING OVERLINE: Y {old_y_min:.0f}-{old_y_max:.0f} → {OVERLINE_Y_BOTTOM}-{OVERLINE_Y_TOP}")
            modified += 1
    except Exception as e:
        print(f"    Warning: Could not reposition combining overline: {e}")

    # Reposition combining underline
    try:
        g = font[COMBINING_UNDERLINE]
        if g:
            bbox = g.boundingBox()
            old_y_min, old_y_max = bbox[1], bbox[3]

            # Clear and redraw at new position
            g.clear()
            pen = g.glyphPen()

            half_width = 300

            pen.moveTo((-half_width, UNDERLINE_Y_BOTTOM))
            pen.lineTo((half_width, UNDERLINE_Y_BOTTOM))
            pen.lineTo((half_width, UNDERLINE_Y_TOP))
            pen.lineTo((-half_width, UNDERLINE_Y_TOP))
            pen.closePath()
            pen = None

            g.width = 0
            g.correctDirection()

            print(f"    Repositioned U+0332 COMBINING UNDERLINE: Y {old_y_min:.0f}-{old_y_max:.0f} → {UNDERLINE_Y_BOTTOM}-{UNDERLINE_Y_TOP}")
            modified += 1
    except Exception as e:
        print(f"    Warning: Could not reposition combining underline: {e}")

    return modified


def create_line_endpoint_caps(font):
    """
    Create rounded cap glyphs for the start and end of continuous lines.

    These are small semicircle shapes that cap the ends of underlines/overlines.

    Design:
      - Left caps: Semicircle on the left, drawn at negative X (before the glyph origin)
                   with zero advance width. This prepends a rounded end.
      - Right caps: Semicircle on the right, drawn at positive X with the semicircle
                    as advance width. This appends a rounded end.

    Creates 4 glyphs:
      U+E700: underline_left_cap  (rounded left end for underline)
      U+E701: underline_right_cap (rounded right end for underline)
      U+E702: overline_left_cap   (rounded left end for overline)
      U+E703: overline_right_cap  (rounded right end for overline)

    Uses global lane constants defined at module level.
    """
    import math

    # Cap geometry - uses global LINE_THICKNESS constant
    CAP_RADIUS = LINE_THICKNESS // 2  # Half the thickness for semicircle

    # Codepoint allocation
    CAPS = [
        (0xE700, 'underline_left_cap', UNDERLINE_Y_BOTTOM, UNDERLINE_Y_TOP, 'left'),
        (0xE701, 'underline_right_cap', UNDERLINE_Y_BOTTOM, UNDERLINE_Y_TOP, 'right'),
        (0xE702, 'overline_left_cap', OVERLINE_Y_BOTTOM, OVERLINE_Y_TOP, 'left'),
        (0xE703, 'overline_right_cap', OVERLINE_Y_BOTTOM, OVERLINE_Y_TOP, 'right'),
    ]

    created = 0

    def semicircle_points(cx, cy, r, start_angle, end_angle, num_points=8):
        """Generate points along a semicircle arc."""
        points = []
        for i in range(num_points + 1):
            t = i / num_points
            angle = start_angle + t * (end_angle - start_angle)
            x = cx + r * math.cos(angle)
            y = cy + r * math.sin(angle)
            points.append((x, y))
        return points

    for codepoint, name, y_bottom, y_top, side in CAPS:
        try:
            glyph = font.createChar(codepoint, name)
            glyph.clear()

            pen = glyph.glyphPen()

            y_center = (y_bottom + y_top) / 2

            if side == 'left':
                # Left cap: semicircle bulging LEFT from the straight edge at X=0
                # Zero advance width - this prepends a rounded end
                #
                # Shape: Start at top-right (0, y_top), go down the straight edge,
                # then arc around to the left and back up to close.

                pen.moveTo((0, y_top))
                pen.lineTo((0, y_bottom))  # Straight edge down

                # Arc from bottom to top, curving left (270° down to 90° up)
                # This goes: bottom -> left side -> top
                arc_points = semicircle_points(0, y_center, CAP_RADIUS,
                                               -math.pi/2, math.pi/2, 8)
                # Reverse direction: we want to go counterclockwise (left side)
                # Actually we need 270° to 90° going through 180° (the left side)
                arc_points = semicircle_points(0, y_center, CAP_RADIUS,
                                               3*math.pi/2, math.pi/2 + 2*math.pi, 8)
                # Simpler: just go from -90° to 90° but negate X to flip to left
                arc_points = []
                for i in range(9):
                    t = i / 8
                    angle = -math.pi/2 + t * math.pi  # -90° to +90°
                    x = -CAP_RADIUS * math.cos(angle)  # Negate X to go left
                    y = y_center + CAP_RADIUS * math.sin(angle)
                    arc_points.append((x, y))

                for px, py in arc_points:
                    pen.lineTo((px, py))

                pen.closePath()
                pen = None
                glyph.width = 0

            else:  # right
                # Right cap: semicircle bulging RIGHT from the straight edge at X=0
                # Advance width = CAP_RADIUS
                #
                # Shape: Start at bottom-left (0, y_bottom), go up the straight edge,
                # then arc around to the right and back down to close.

                pen.moveTo((0, y_bottom))
                pen.lineTo((0, y_top))  # Straight edge up

                # Arc from top to bottom, curving right
                arc_points = []
                for i in range(9):
                    t = i / 8
                    angle = math.pi/2 - t * math.pi  # +90° to -90°
                    x = CAP_RADIUS * math.cos(angle)
                    y = y_center + CAP_RADIUS * math.sin(angle)
                    arc_points.append((x, y))

                for px, py in arc_points:
                    pen.lineTo((px, py))

                pen.closePath()
                pen = None
                glyph.width = CAP_RADIUS

            glyph.correctDirection()
            created += 1

        except Exception as e:
            print(f"    Warning: Could not create {name}: {e}")

    print(f"    ✓ Created {created} line endpoint caps (U+E700-U+E703)")
    return created


def add_overline_ligatures(font, overline_map):
    """
    Add GSUB ligatures: char + U+0305 → overlined variant.

    When text contains a character followed by COMBINING OVERLINE (U+0305),
    the ligature feature substitutes the pair with a single pre-composed
    overlined glyph.

    Args:
        font: FontForge font object
        overline_map: Dict mapping original codepoint → overlined variant codepoint
    """
    if not overline_map:
        print(f"    No overline mappings to create ligatures for")
        return 0

    COMBINING_OVERLINE = 0x0305

    # Ensure combining overline exists in font
    try:
        combining_glyph = font[COMBINING_OVERLINE]
        if not combining_glyph:
            print(f"    Warning: U+0305 COMBINING OVERLINE not found in font")
            return 0
        combining_name = combining_glyph.glyphname
    except (KeyError, TypeError) as e:
        print(f"    Warning: Could not access U+0305 COMBINING OVERLINE: {e}")
        return 0

    # Create ligature lookup table
    lookup_name = "liga_overline"
    subtable_name = "liga_overline_sub"

    try:
        # Add lookup for ligature substitution
        # ('liga', ...) registers this as a standard ligature feature
        font.addLookup(lookup_name, 'gsub_ligature', (),
                       (('liga', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_name, subtable_name)
    except Exception as e:
        print(f"    Warning: Could not create GSUB lookup: {e}")
        return 0

    # Add ligature for each character
    ligatures_added = 0
    for orig_cp, overlined_cp in overline_map.items():
        try:
            base_glyph = font[orig_cp]
            overlined_glyph = font[overlined_cp]

            if not base_glyph or not overlined_glyph:
                continue

            # Add ligature substitution: base + combining → overlined
            # The tuple specifies the input sequence (base glyph name, combining mark name)
            overlined_glyph.addPosSub(subtable_name, (base_glyph.glyphname, combining_name))
            ligatures_added += 1

        except Exception as e:
            # Skip failures silently
            pass

    print(f"    ✓ Added {ligatures_added} GSUB ligatures (char + U+0305 → overlined)")
    return ligatures_added


def add_octave_dot_ligatures(font, layout: 'CodepointLayout'):
    """
    Add GSUB ligatures for combining octave dots using 'ccmp' feature.

    ccmp (Glyph Composition/Decomposition) is applied BY DEFAULT in browsers,
    unlike 'mark' which requires explicit CSS font-feature-settings.

    This substitutes:
    - char + U+0307 (dot above) → precomposed PUA glyph with octave +1
    - char + U+0308 (diaeresis above) → precomposed PUA glyph with octave +2
    - char + U+0323 (dot below) → precomposed PUA glyph with octave -1
    - char + U+0324 (diaeresis below) → precomposed PUA glyph with octave -2

    Args:
        font: FontForge font object
        layout: CodepointLayout with note_atoms containing variant info
    """
    # Combining marks for octave indicators
    COMBINING_DOT_ABOVE = 0x0307      # octave +1
    COMBINING_DIAERESIS_ABOVE = 0x0308  # octave +2
    COMBINING_DOT_BELOW = 0x0323      # octave -1
    COMBINING_DIAERESIS_BELOW = 0x0324  # octave -2

    # Map octave_idx to combining character
    # Layout: variant_index = (accidental_type × 5) + octave_idx
    # octave_idx: 0=base, 1=-2oct, 2=-1oct, 3=+1oct, 4=+2oct
    octave_to_combining = {
        3: COMBINING_DOT_ABOVE,       # +1 octave
        4: COMBINING_DIAERESIS_ABOVE, # +2 octave
        2: COMBINING_DOT_BELOW,       # -1 octave
        1: COMBINING_DIAERESIS_BELOW, # -2 octave
    }

    # Get combining mark glyph names
    combining_names = {}
    for octave_idx, cp in octave_to_combining.items():
        try:
            g = font[cp]
            if g and g.glyphname:
                combining_names[octave_idx] = g.glyphname
        except (KeyError, TypeError):
            pass  # Glyph not in font

    if not combining_names:
        print(f"    Warning: No combining mark glyphs found")
        return 0

    # Create ccmp lookup for octave dot substitution
    lookup_name = "ccmp_octave_dots"
    subtable_name = "ccmp_octave_dots_sub"

    try:
        # Add to existing ccmp feature (applied by default!)
        font.addLookup(lookup_name, 'gsub_ligature', (),
                       (('ccmp', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_name, subtable_name)
    except Exception as e:
        print(f"    Warning: Could not create ccmp lookup: {e}")
        return 0

    # Build mapping: (base_char, octave_idx) → PUA codepoint
    # From note_atoms which have character, accidental_type, octave info encoded in variant_index
    ligatures_added = 0

    # Group atoms by base character and accidental type
    # We only want natural (accidental_type=0) variants for combining char substitution
    # because the combining char approach is for plain text (base char + combining mark)
    for atom in layout.note_atoms:
        # variant_index = (accidental_type × 5) + octave_idx
        accidental_type = atom.variant_index // 5
        octave_idx = atom.variant_index % 5

        # Only process natural (no accidental) variants with octave shifts
        if accidental_type != 0:
            continue
        if octave_idx not in combining_names:
            continue  # Skip base octave (0)

        base_char = atom.character
        pua_codepoint = atom.assigned_codepoint
        combining_name = combining_names[octave_idx]

        try:
            base_glyph = font[ord(base_char)]
            pua_glyph = font[pua_codepoint]

            if not base_glyph or not pua_glyph:
                continue

            # Add ligature: base_char + combining_mark → PUA_glyph
            pua_glyph.addPosSub(subtable_name, (base_glyph.glyphname, combining_name))
            ligatures_added += 1

        except Exception as e:
            pass  # Skip failures silently

    print(f"    ✓ Added {ligatures_added} ccmp ligatures (char + combining dot → precomposed)")
    return ligatures_added


def create_combined_line_variants(font, underline_map, overline_map):
    """
    Create pre-composed glyphs combining octave dots with underlines/overlines.

    When text has char + octave_dot + underline (e.g., 1 U+0307 U+0332),
    we need a single glyph that shows all three: the character, the dot above,
    AND the underline.

    This creates variants at PUA 0xF000+ for combinations of:
    - Existing underlined glyphs (0xE800+) + octave dots
    - Existing overlined glyphs (0xEC00+) + octave dots

    Returns:
        tuple: (underline_octave_map, overline_octave_map)
            Maps: (original_codepoint, octave_combining) → combined PUA codepoint
    """
    # Uses global lane constants defined at module level

    # Octave combining characters
    OCTAVE_COMBINING = {
        0x0307: 'dot_above',       # +1 octave
        0x0308: 'diaeresis_above', # +2 octave
        0x0323: 'dot_below',       # -1 octave
        0x0324: 'diaeresis_below', # -2 octave
    }

    # Start allocating combined variants at 0xF000
    PUA_COMBINED_START = 0xF000
    current_pua = PUA_COMBINED_START

    underline_octave_map = {}  # (orig_cp, octave_cp) → combined_pua
    overline_octave_map = {}   # (orig_cp, octave_cp) → combined_pua

    # Only create combined variants for pitch characters (to avoid table overflow)
    # Number: 1-7, Western: A-G a-g, Sargam: S R G M P D N r g m d n, dash
    PITCH_CHARS = set('1234567ABCDEFGabcdefgSRGMPDNrgmdn-')

    # For each base character that has both underlined variant AND octave variants,
    # create combined glyphs
    print(f"    Creating combined underline+octave variants...")
    combined_underline_count = 0

    for orig_cp, underlined_cp in underline_map.items():
        # Only process pitch characters
        if orig_cp > 127 or chr(orig_cp) not in PITCH_CHARS:
            continue

        # For each octave combining character
        for octave_cp, octave_name in OCTAVE_COMBINING.items():
            try:
                # Get the underlined glyph as base
                underlined_glyph = font[underlined_cp]
                if not underlined_glyph:
                    continue

                # We need to find the PUA glyph that has this base char + octave
                # Search note_atoms for matching variant
                # For now, use simpler approach: copy underlined glyph and add dot

                # Get base char to find its octave variant
                base_glyph = font[orig_cp]
                if not base_glyph:
                    continue

                # Create combined glyph
                glyph_name = f"uni{current_pua:04X}"

                # Check if exists
                try:
                    existing = font[current_pua]
                    if existing and existing.glyphname and existing.glyphname != glyph_name:
                        current_pua += 1
                        continue
                except (KeyError, TypeError):
                    pass  # Glyph doesn't exist yet, which is fine

                combined_glyph = font.createChar(current_pua, glyph_name)
                combined_glyph.clear()

                # Build combined glyph from scratch:
                # 1. Add base character
                combined_glyph.addReference(base_glyph.glyphname)
                combined_glyph.unlinkRef()

                # 2. Draw underline
                bbox = base_glyph.boundingBox()
                if bbox:
                    bx_min, by_min, bx_max, by_max = bbox
                    center_x = (bx_min + bx_max) / 2

                    pen = combined_glyph.glyphPen(replace=False)

                    # Draw underline - matches character's visual extent (bbox)
                    x_start = int(bx_min)
                    x_end = int(bx_max)
                    pen.moveTo((x_start, UNDERLINE_Y_BOTTOM))
                    pen.lineTo((x_end, UNDERLINE_Y_BOTTOM))
                    pen.lineTo((x_end, UNDERLINE_Y_TOP))
                    pen.lineTo((x_start, UNDERLINE_Y_TOP))
                    pen.closePath()

                    # 3. Draw octave dot
                    dot_radius = 40

                    if octave_name == 'dot_above':
                        dot_y = by_max + 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                    elif octave_name == 'diaeresis_above':
                        dot_y = by_max + 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                        _draw_circle(pen, center_x, dot_y + 80, dot_radius)
                    elif octave_name == 'dot_below':
                        dot_y = by_min - 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                    elif octave_name == 'diaeresis_below':
                        dot_y = by_min - 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                        _draw_circle(pen, center_x, dot_y - 80, dot_radius)

                    pen = None

                combined_glyph.width = base_glyph.width
                combined_glyph.correctDirection()

                underline_octave_map[(orig_cp, octave_cp)] = current_pua
                combined_underline_count += 1
                current_pua += 1

            except Exception as e:
                pass

    print(f"    ✓ Created {combined_underline_count} underline+octave variants")

    # Same for overlines
    print(f"    Creating combined overline+octave variants...")
    combined_overline_count = 0

    for orig_cp, overlined_cp in overline_map.items():
        # Only process pitch characters
        if orig_cp > 127 or chr(orig_cp) not in PITCH_CHARS:
            continue

        for octave_cp, octave_name in OCTAVE_COMBINING.items():
            try:
                overlined_glyph = font[overlined_cp]
                if not overlined_glyph:
                    continue

                base_glyph = font[orig_cp]
                if not base_glyph:
                    continue

                glyph_name = f"uni{current_pua:04X}"

                try:
                    existing = font[current_pua]
                    if existing and existing.glyphname and existing.glyphname != glyph_name:
                        current_pua += 1
                        continue
                except (KeyError, TypeError):
                    pass  # Glyph doesn't exist yet, which is fine

                combined_glyph = font.createChar(current_pua, glyph_name)
                combined_glyph.clear()

                # Build combined glyph from scratch:
                # 1. Add base character
                combined_glyph.addReference(base_glyph.glyphname)
                combined_glyph.unlinkRef()

                # 2. Draw overline and octave dot
                bbox = base_glyph.boundingBox()
                if bbox:
                    bx_min, by_min, bx_max, by_max = bbox
                    center_x = (bx_min + bx_max) / 2

                    pen = combined_glyph.glyphPen(replace=False)

                    # Draw overline - matches character's visual extent (bbox)
                    x_start = int(bx_min)
                    x_end = int(bx_max)
                    pen.moveTo((x_start, OVERLINE_Y_BOTTOM))
                    pen.lineTo((x_end, OVERLINE_Y_BOTTOM))
                    pen.lineTo((x_end, OVERLINE_Y_TOP))
                    pen.lineTo((x_start, OVERLINE_Y_TOP))
                    pen.closePath()

                    # 3. Draw octave dot
                    dot_radius = 40

                    if octave_name == 'dot_above':
                        # Dot needs to be BELOW the overline
                        dot_y = by_max + 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                    elif octave_name == 'diaeresis_above':
                        dot_y = by_max + 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                        _draw_circle(pen, center_x, dot_y + 80, dot_radius)
                    elif octave_name == 'dot_below':
                        dot_y = by_min - 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                    elif octave_name == 'diaeresis_below':
                        dot_y = by_min - 80
                        _draw_circle(pen, center_x, dot_y, dot_radius)
                        _draw_circle(pen, center_x, dot_y - 80, dot_radius)

                    pen = None

                combined_glyph.width = base_glyph.width
                combined_glyph.correctDirection()

                overline_octave_map[(orig_cp, octave_cp)] = current_pua
                combined_overline_count += 1
                current_pua += 1

            except Exception as e:
                pass

    print(f"    ✓ Created {combined_overline_count} overline+octave variants")

    return underline_octave_map, overline_octave_map


def _draw_circle(pen, cx, cy, radius):
    """Draw a filled dot as an octagon (approximates circle without complex bezier)."""
    import math
    # Use octagon to approximate circle
    points = []
    for i in range(8):
        angle = math.pi * 2 * i / 8
        x = cx + radius * math.cos(angle)
        y = cy + radius * math.sin(angle)
        points.append((x, y))

    pen.moveTo(points[0])
    for p in points[1:]:
        pen.lineTo(p)
    pen.closePath()


def add_combined_line_ligatures(font, underline_octave_map, overline_octave_map):
    """
    Add GSUB ligatures for triple combinations: char + underline + octave (or char + octave + overline).

    Order matches Rust export: char → underline → octave → overline

    These ligatures substitute:
    - char + U+0332 + U+0307 → combined glyph with underline + dot above
    - char + U+0307 + U+0305 → combined glyph with dot above + overline
    - etc. for all octave/line combinations
    """
    # Get combining mark glyph names
    COMBINING_MARKS = {
        0x0307: None,  # dot above
        0x0308: None,  # diaeresis above
        0x0323: None,  # dot below
        0x0324: None,  # diaeresis below
        0x0332: None,  # underline
        0x0305: None,  # overline
    }

    for cp in COMBINING_MARKS:
        try:
            g = font[cp]
            if g and g.glyphname:
                COMBINING_MARKS[cp] = g.glyphname
        except (KeyError, TypeError):
            pass  # Glyph not in font

    # Create ligature lookup for combined underline+octave
    lookup_name = "liga_combined_underline_octave"
    subtable_name = "liga_combined_underline_octave_sub"

    try:
        font.addLookup(lookup_name, 'gsub_ligature', (),
                       (('liga', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_name, subtable_name)
    except Exception as e:
        print(f"    Warning: Could not create combined underline ligature lookup: {e}")
        return 0

    ligatures_added = 0
    underline_name = COMBINING_MARKS.get(0x0332)

    if underline_name:
        for (orig_cp, octave_cp), combined_cp in underline_octave_map.items():
            try:
                base_glyph = font[orig_cp]
                combined_glyph = font[combined_cp]
                octave_name = COMBINING_MARKS.get(octave_cp)

                if not base_glyph or not combined_glyph or not octave_name:
                    continue

                # Add ligature: base + underline + octave → combined
                # Order: char → U+0332 → U+0307/0308/0323/0324
                combined_glyph.addPosSub(subtable_name,
                    (base_glyph.glyphname, underline_name, octave_name))
                ligatures_added += 1

            except Exception as e:
                pass

    print(f"    ✓ Added {ligatures_added} ligatures for underline+octave combinations")

    # Create ligature lookup for combined overline+octave
    lookup_name2 = "liga_combined_overline_octave"
    subtable_name2 = "liga_combined_overline_octave_sub"

    try:
        font.addLookup(lookup_name2, 'gsub_ligature', (),
                       (('liga', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_name2, subtable_name2)
    except Exception as e:
        print(f"    Warning: Could not create combined overline ligature lookup: {e}")
        return ligatures_added

    overline_ligatures = 0
    overline_name = COMBINING_MARKS.get(0x0305)

    if overline_name:
        for (orig_cp, octave_cp), combined_cp in overline_octave_map.items():
            try:
                base_glyph = font[orig_cp]
                combined_glyph = font[combined_cp]
                octave_name = COMBINING_MARKS.get(octave_cp)

                if not base_glyph or not combined_glyph or not octave_name:
                    continue

                # Add ligature: base + octave + overline → combined
                combined_glyph.addPosSub(subtable_name2,
                    (base_glyph.glyphname, octave_name, overline_name))
                overline_ligatures += 1

            except Exception as e:
                pass

    print(f"    ✓ Added {overline_ligatures} ligatures for overline+octave combinations")

    return ligatures_added + overline_ligatures


# ============================================================================
# NEW ARCHITECTURE: GPOS Marks + 15 Line Variants
# ============================================================================
# This section implements the new font architecture as defined in the plan:
# - GPOS marks for octave dots and accidentals (point attachments)
# - 15 pre-composed line variants per character (3 underline × 3 overline + 6 single)
# - Anchor points for GPOS mark attachment
#
# Key insight: Lines must be pre-composed because they need to span exact
# character width edge-to-edge. GPOS marks work for dots/accidentals because
# they attach at single points.

# PUA allocation for new architecture:
# 0xE7A0-0xE7A3: Octave dot marks (1-dot-above, 2-dots-above, 1-dot-below, 2-dots-below)
# 0xE7B0-0xE7B5: Accidental marks (sharp, flat, natural, double-sharp, double-flat, half-flat)
# PUA allocation for 15-variant line system:
# ASCII (95 chars):
#   0xE800-0xE91C: Underline-only (95 × 3 = 285)
#   0xE920-0xEA3B: Overline-only (95 × 3 = 285)
#   0xEA40-0xEDB3: Combined (95 × 9 = 855)
# PUA Notes (1410 base notes × 15 variants = 21,150):
#   0x1A000+: Number (210 × 15 = 3,150)
#   0x1B000+: Western (420 × 15 = 6,300)
#   0x1D000+: Sargam (360 × 15 = 5,400)
#   0x1F000+: Doremi (420 × 15 = 6,300)

# Line-capable glyphs: ALL ASCII printable characters (0x20-0x7E)
# This covers all characters that might appear in notation and need underline/overline
LINE_CAPABLE_CHARS = tuple(chr(c) for c in range(0x20, 0x7F))  # 95 chars

# 15 line variant types (unified system for ASCII and PUA notes)
# Format: (variant_index, underline_state, overline_state)
# underline_state: None, 'middle', 'left', 'right'
# overline_state: None, 'middle', 'left', 'right'
LINE_VARIANT_TYPES = [
    # Underline-only (3 variants) - indices 0-2
    (0, 'middle', None),      # Inside beat group, no slur
    (1, 'left', None),        # Start of beat group
    (2, 'right', None),       # End of beat group

    # Overline-only (3 variants) - indices 3-5
    (3, None, 'middle'),      # Inside slur, no beat group
    (4, None, 'left'),        # Start of slur
    (5, None, 'right'),       # End of slur

    # Combined (9 variants) - indices 6-14
    (6, 'middle', 'middle'),  # Inside both
    (7, 'middle', 'left'),    # Inside beat, start of slur
    (8, 'middle', 'right'),   # Inside beat, end of slur
    (9, 'left', 'middle'),    # Start of beat, inside slur
    (10, 'left', 'left'),     # Start of both
    (11, 'left', 'right'),    # Start of beat, end of slur
    (12, 'right', 'middle'),  # End of beat, inside slur
    (13, 'right', 'left'),    # End of beat, start of slur
    (14, 'right', 'right'),   # End of both
]

# GPOS mark codepoints
GPOS_MARK_CODEPOINTS = {
    '1_dot_above': 0xE7A0,
    '2_dots_above': 0xE7A1,
    '1_dot_below': 0xE7A2,
    '2_dots_below': 0xE7A3,
    'sharp': 0xE7B0,
    'flat': 0xE7B1,
    'natural': 0xE7B2,
    'double_sharp': 0xE7B3,
    'double_flat': 0xE7B4,
    'half_flat': 0xE7B5,
}


def create_gpos_mark_glyphs(font, dot_glyph, spec):
    """
    Create GPOS mark glyphs for octave dots and accidentals.

    These are zero-width marks with anchor points that attach to base glyphs
    via GPOS 'mark' feature. Custom styled to match NotationFont.

    Args:
        font: FontForge font object
        dot_glyph: Reference to the period glyph for dot creation
        spec: AtomSpec with geometry settings

    Returns:
        dict: Mapping of mark_name -> codepoint
    """
    print(f"\n  [GPOS] Creating mark glyphs for octave dots and accidentals...")

    created_marks = {}

    # Get dot dimensions
    dot_bbox = dot_glyph.boundingBox()
    dx_min, dy_min, dx_max, dy_max = dot_bbox
    dot_width = dx_max - dx_min
    dot_height = dy_max - dy_min
    dot_name = dot_glyph.glyphname

    # Create octave dot marks
    # These are zero-width glyphs with the dot positioned at origin
    # The mark anchor will be placed at the visual center

    # 1-dot-above mark
    cp = GPOS_MARK_CODEPOINTS['1_dot_above']
    g = font.createChar(cp, "mark_1dot_above")
    g.clear()
    g.addReference(dot_name, (1, 0, 0, 1, -dx_min, 0))
    g.width = 0  # Zero-width mark
    # Add mark anchor at center of dot
    g.addAnchorPoint("mark_above", "mark", dot_width / 2, dot_height / 2)
    created_marks['1_dot_above'] = cp
    print(f"    Created mark_1dot_above at U+{cp:04X}")

    # 2-dots-above mark
    cp = GPOS_MARK_CODEPOINTS['2_dots_above']
    g = font.createChar(cp, "mark_2dots_above")
    g.clear()
    double_dot_scale = 0.6
    double_dot_spacing = 2 * dot_height * double_dot_scale
    g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, -dx_min, 0))
    g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, -dx_min, double_dot_spacing))
    g.width = 0
    g.addAnchorPoint("mark_above", "mark", dot_width * double_dot_scale / 2, dot_height * double_dot_scale)
    created_marks['2_dots_above'] = cp
    print(f"    Created mark_2dots_above at U+{cp:04X}")

    # 1-dot-below mark
    cp = GPOS_MARK_CODEPOINTS['1_dot_below']
    g = font.createChar(cp, "mark_1dot_below")
    g.clear()
    g.addReference(dot_name, (1, 0, 0, 1, -dx_min, -dot_height))
    g.width = 0
    g.addAnchorPoint("mark_below", "mark", dot_width / 2, -dot_height / 2)
    created_marks['1_dot_below'] = cp
    print(f"    Created mark_1dot_below at U+{cp:04X}")

    # 2-dots-below mark
    cp = GPOS_MARK_CODEPOINTS['2_dots_below']
    g = font.createChar(cp, "mark_2dots_below")
    g.clear()
    g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, -dx_min, 0))
    g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, -dx_min, -double_dot_spacing))
    g.width = 0
    g.addAnchorPoint("mark_below", "mark", dot_width * double_dot_scale / 2, -dot_height * double_dot_scale)
    created_marks['2_dots_below'] = cp
    print(f"    Created mark_2dots_below at U+{cp:04X}")

    # Create accidental marks
    # These copy existing accidental glyphs but make them zero-width marks
    accidental_sources = {
        'flat': 0x266D,
        'sharp': 0x266F,
        'double_flat': 0x1D12B,
        'double_sharp': 0x1D12A,
    }

    for acc_name, src_cp in accidental_sources.items():
        try:
            src_glyph = font[src_cp]
            if src_glyph and src_glyph.glyphname:
                cp = GPOS_MARK_CODEPOINTS[acc_name]
                g = font.createChar(cp, f"mark_{acc_name}")
                g.clear()

                # Copy accidental glyph
                pen = g.glyphPen()
                src_glyph.draw(pen)
                pen = None

                # Make zero-width
                g.width = 0

                # Add mark anchor at left edge, vertically centered
                src_bbox = src_glyph.boundingBox()
                sx_min, sy_min, sx_max, sy_max = src_bbox
                g.addAnchorPoint("mark_right", "mark", 0, (sy_min + sy_max) / 2)

                created_marks[acc_name] = cp
                print(f"    Created mark_{acc_name} at U+{cp:04X}")
        except Exception as e:
            print(f"    Warning: Could not create {acc_name} mark: {e}")

    # Create natural mark (♮) - may need to synthesize if not in font
    try:
        natural_cp = 0x266E
        natural_src = font[natural_cp]
        if natural_src and natural_src.glyphname:
            cp = GPOS_MARK_CODEPOINTS['natural']
            g = font.createChar(cp, "mark_natural")
            g.clear()
            pen = g.glyphPen()
            natural_src.draw(pen)
            pen = None
            g.width = 0
            src_bbox = natural_src.boundingBox()
            g.addAnchorPoint("mark_right", "mark", 0, (src_bbox[1] + src_bbox[3]) / 2)
            created_marks['natural'] = cp
            print(f"    Created mark_natural at U+{cp:04X}")
    except Exception as e:
        print(f"    Warning: Could not create natural mark: {e}")

    # Create half-flat mark (use existing half-flat if available)
    try:
        halfflat_src = font[0xF8FF]  # Our custom half-flat
        if halfflat_src and halfflat_src.glyphname:
            cp = GPOS_MARK_CODEPOINTS['half_flat']
            g = font.createChar(cp, "mark_half_flat")
            g.clear()
            pen = g.glyphPen()
            halfflat_src.draw(pen)
            pen = None
            g.width = 0
            src_bbox = halfflat_src.boundingBox()
            g.addAnchorPoint("mark_right", "mark", 0, (src_bbox[1] + src_bbox[3]) / 2)
            created_marks['half_flat'] = cp
            print(f"    Created mark_half_flat at U+{cp:04X}")
    except Exception as e:
        print(f"    Warning: Could not create half-flat mark: {e}")

    print(f"  [GPOS] ✓ Created {len(created_marks)} mark glyphs")
    return created_marks


def add_base_glyph_anchors(font, line_capable_only=False):
    """
    Add anchor points to base glyphs for GPOS mark attachment.

    Each base glyph gets three anchor points:
    - mark_above: (center_x, ascender + gap) for octave dots above
    - mark_below: (center_x, descender - gap) for octave dots below
    - mark_right: (advance_width + gap, center_y) for accidentals

    Args:
        font: FontForge font object
        line_capable_only: If True, only add to LINE_CAPABLE_CHARS

    Returns:
        int: Number of glyphs with anchors added
    """
    print(f"\n  [GPOS] Adding base anchor points for mark attachment...")

    GAP_ABOVE = 80   # Gap between character top and dot anchor
    GAP_BELOW = 80   # Gap between character bottom and dot anchor
    GAP_RIGHT = 20   # Gap between character right edge and accidental anchor

    anchors_added = 0
    chars_to_process = LINE_CAPABLE_CHARS if line_capable_only else None

    for glyph in font.glyphs():
        if glyph.unicode <= 0:
            continue

        # Filter to line-capable chars if specified
        if chars_to_process:
            try:
                char = chr(glyph.unicode)
                if char not in chars_to_process:
                    continue
            except (ValueError, TypeError):
                continue  # Invalid unicode codepoint

        try:
            bbox = glyph.boundingBox()
            if not bbox:
                continue

            x_min, y_min, x_max, y_max = bbox
            center_x = (x_min + x_max) / 2
            center_y = (y_min + y_max) / 2

            # Add anchor points
            glyph.addAnchorPoint("mark_above", "base", center_x, y_max + GAP_ABOVE)
            glyph.addAnchorPoint("mark_below", "base", center_x, y_min - GAP_BELOW)
            glyph.addAnchorPoint("mark_right", "base", glyph.width + GAP_RIGHT, center_y)

            anchors_added += 1
        except Exception as e:
            pass

    print(f"  [GPOS] ✓ Added anchors to {anchors_added} base glyphs")
    return anchors_added


def create_15_line_variants(font, pua_bases):
    """
    Create 15 line variants for each ASCII printable character.

    Uses composite references to keep font size small. Each variant has:
    - Reference to base glyph
    - Underline geometry (if applicable)
    - Overline geometry (if applicable)
    - Anchor points inherited from base (for GPOS mark attachment)

    Variant structure (15 total):
    - 0-2: underline-only (middle, left, right)
    - 3-5: overline-only (middle, left, right)
    - 6-14: combined (3 underline × 3 overline)

    Args:
        font: FontForge font object
        pua_bases: Dict with 'underline', 'overline', 'combined' PUA start addresses

    Returns:
        dict: Mapping of (base_char, variant_index) -> variant_codepoint
    """
    import math

    print(f"\n  [LINE VARIANTS] Creating 15 line variants per character...")

    # Line geometry (same as existing constants)
    line_thickness = LINE_THICKNESS  # 72 units
    underline_y_bottom = UNDERLINE_Y_BOTTOM  # -180
    underline_y_top = UNDERLINE_Y_TOP  # -108
    overline_y_bottom = OVERLINE_Y_BOTTOM  # 880
    overline_y_top = OVERLINE_Y_TOP  # 952

    # Minimum width for line variants - ensures arcs have enough space
    # Characters narrower than this get padded width (character centered)
    # Dash width is ~322, so we use 400 as minimum to ensure good arc rendering
    MIN_LINE_VARIANT_WIDTH = 400

    def draw_quarter_arc(pen, cx, cy, radius, start_deg, end_deg, clockwise=True):
        """Draw a quarter-circle arc (ring segment with stroke thickness)."""
        outer_r = radius
        inner_r = max(radius - line_thickness, 1)
        STEPS = 8

        start_rad = math.radians(start_deg)
        end_rad = math.radians(end_deg)

        if clockwise:
            if end_rad > start_rad:
                end_rad -= 2 * math.pi
        else:
            if end_rad < start_rad:
                end_rad += 2 * math.pi

        # Outer arc
        pen.moveTo((cx + outer_r * math.cos(start_rad), cy + outer_r * math.sin(start_rad)))
        for i in range(1, STEPS + 1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((cx + outer_r * math.cos(a), cy + outer_r * math.sin(a)))

        # Inner arc back
        for i in range(STEPS, -1, -1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((cx + inner_r * math.cos(a), cy + inner_r * math.sin(a)))

        pen.closePath()

    def draw_line_with_arcs(pen, char_width, y_bottom, y_top, left_arc, right_arc, is_overline):
        """Draw a line segment with optional arcs at endpoints."""
        arc_radius = min(line_thickness * 2, char_width / 4)

        # Determine arc geometry based on line type
        if is_overline:
            # Arcs curve upward
            left_cx, left_cy = arc_radius, y_top - arc_radius
            left_start, left_end, left_cw = 90, 180, False
            right_cx, right_cy = char_width - arc_radius, y_top - arc_radius
            right_start, right_end, right_cw = 90, 0, True
        else:
            # Arcs curve downward
            left_cx, left_cy = arc_radius, y_bottom + arc_radius
            left_start, left_end, left_cw = 270, 180, True
            right_cx, right_cy = char_width - arc_radius, y_bottom + arc_radius
            right_start, right_end, right_cw = 270, 360, False

        # Calculate line segment endpoints
        line_x_start = arc_radius if left_arc else 0
        line_x_end = (char_width - arc_radius) if right_arc else char_width

        # Draw arcs if needed
        if left_arc:
            draw_quarter_arc(pen, left_cx, left_cy, arc_radius, left_start, left_end, left_cw)
        if right_arc:
            draw_quarter_arc(pen, right_cx, right_cy, arc_radius, right_start, right_end, right_cw)

        # Draw line segment (if there's space between arcs)
        if line_x_start < line_x_end:
            pen.moveTo((line_x_start, y_bottom))
            pen.lineTo((line_x_end, y_bottom))
            pen.lineTo((line_x_end, y_top))
            pen.lineTo((line_x_start, y_top))
            pen.closePath()

    variant_map = {}
    char_index = 0

    for base_char in LINE_CAPABLE_CHARS:
        try:
            base_cp = ord(base_char)
            base_glyph = font[base_cp]
            if not base_glyph:
                continue

            original_width = base_glyph.width

            # Pad narrow characters to ensure arcs fit properly
            if original_width < MIN_LINE_VARIANT_WIDTH:
                char_width = MIN_LINE_VARIANT_WIDTH
                x_offset = (MIN_LINE_VARIANT_WIDTH - original_width) / 2  # Center the glyph
            else:
                char_width = original_width
                x_offset = 0

            for variant_idx, underline_state, overline_state in LINE_VARIANT_TYPES:
                # Calculate PUA codepoint based on variant type
                if overline_state is None:
                    # Underline-only (indices 0-2)
                    variant_cp = pua_bases['underline'] + (char_index * 3) + variant_idx
                elif underline_state is None:
                    # Overline-only (indices 3-5)
                    variant_cp = pua_bases['overline'] + (char_index * 3) + (variant_idx - 3)
                else:
                    # Combined (indices 6-14)
                    variant_cp = pua_bases['combined'] + (char_index * 9) + (variant_idx - 6)

                glyph_name = f"line_{base_char}_v{variant_idx}"
                variant_glyph = font.createChar(variant_cp, glyph_name)
                variant_glyph.clear()

                # Add reference to base glyph (with offset for narrow chars)
                if x_offset > 0:
                    # Use transform matrix to center narrow glyphs: (1, 0, 0, 1, x_offset, 0)
                    variant_glyph.addReference(base_glyph.glyphname, (1, 0, 0, 1, x_offset, 0))
                else:
                    variant_glyph.addReference(base_glyph.glyphname)

                # Draw line geometry
                pen = variant_glyph.glyphPen(replace=False)

                # Draw underline if specified
                if underline_state:
                    left_arc = underline_state == 'left'
                    right_arc = underline_state == 'right'
                    draw_line_with_arcs(pen, char_width, underline_y_bottom, underline_y_top,
                                       left_arc, right_arc, is_overline=False)

                # Draw overline if specified
                if overline_state:
                    left_arc = overline_state == 'left'
                    right_arc = overline_state == 'right'
                    draw_line_with_arcs(pen, char_width, overline_y_bottom, overline_y_top,
                                       left_arc, right_arc, is_overline=True)

                pen = None

                # Set width to match base
                variant_glyph.width = char_width

                # Copy anchor points from base glyph for GPOS mark attachment
                try:
                    for anchor in base_glyph.anchorPoints:
                        variant_glyph.addAnchorPoint(*anchor)
                except (AttributeError, TypeError):
                    pass  # Base glyph has no anchor points

                variant_glyph.correctDirection()
                variant_map[(base_char, variant_idx)] = variant_cp

            char_index += 1

        except Exception as e:
            print(f"    Warning: Could not create variants for '{base_char}': {e}")

    total_variants = len(variant_map)
    print(f"  [LINE VARIANTS] ✓ Created {total_variants} line variants ({char_index} characters × 15 variants)")
    return variant_map


# PUA note line variant configuration (from atoms.yaml pua_note_line_variants)
# Formula: note_count = pitches × 6 accidentals × 5 octaves = pitches × 30
# Each note gets 15 line variants (3 underline states × 5 overline states)
# Total per system = note_count × 15
PUA_NOTE_LINE_CONFIG = {
    'number': {
        'source_base': 0xE000,
        'line_base': 0x1A000,
        'note_count': 210,   # 7 pitches × 30 (6 acc × 5 oct) = 210
        'breakdown': '7 pitches (1234567) × 6 acc × 5 oct = 210',
    },
    'western': {
        'source_base': 0xE100,
        'line_base': 0x1B000,
        'note_count': 210,   # 7 pitches × 30 = 210
        'breakdown': '7 pitches (CDEFGAB) × 6 acc × 5 oct = 210',
    },
    'sargam': {
        'source_base': 0xE300,
        'line_base': 0x1D000,
        'note_count': 360,   # 12 pitches × 30 = 360
        'breakdown': '12 pitches (SrRgGmMPdDnN) × 6 acc × 5 oct = 360',
    },
    'doremi': {
        'source_base': 0xE500,
        'line_base': 0x1F000,
        'note_count': 210,   # 7 pitches × 30 = 210
        'breakdown': '7 pitches (drmfslt) × 6 acc × 5 oct = 210',
    },
}


def create_pua_note_line_variants(font, layout):
    """
    Create 15 line variants for each PUA note glyph.

    Each note glyph (from number, western, sargam, doremi systems) gets 15 variants:
    - 0-2: underline-only (middle, left, right)
    - 3-5: overline-only (middle, left, right)
    - 6-14: combined (3 underline × 3 overline)

    Args:
        font: FontForge font object
        layout: CodepointLayout with note_atoms

    Returns:
        dict: Mapping of (source_codepoint, variant_index) -> line_variant_codepoint
    """
    import math

    print(f"\n  [PUA NOTE LINES] Creating 15 line variants per PUA note glyph...")

    # Line geometry (same as ASCII line variants)
    line_thickness = LINE_THICKNESS
    underline_y_bottom = UNDERLINE_Y_BOTTOM
    underline_y_top = UNDERLINE_Y_TOP
    overline_y_bottom = OVERLINE_Y_BOTTOM
    overline_y_top = OVERLINE_Y_TOP

    def draw_quarter_arc(pen, cx, cy, radius, start_deg, end_deg, clockwise=True):
        """Draw a quarter-circle arc (ring segment with stroke thickness)."""
        outer_r = radius
        inner_r = max(radius - line_thickness, 1)
        STEPS = 8

        start_rad = math.radians(start_deg)
        end_rad = math.radians(end_deg)

        if clockwise:
            if end_rad > start_rad:
                end_rad -= 2 * math.pi
        else:
            if end_rad < start_rad:
                end_rad += 2 * math.pi

        # Outer arc
        pen.moveTo((cx + outer_r * math.cos(start_rad), cy + outer_r * math.sin(start_rad)))
        for i in range(1, STEPS + 1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((cx + outer_r * math.cos(a), cy + outer_r * math.sin(a)))

        # Inner arc back
        for i in range(STEPS, -1, -1):
            t = i / STEPS
            a = start_rad + (end_rad - start_rad) * t
            pen.lineTo((cx + inner_r * math.cos(a), cy + inner_r * math.sin(a)))

        pen.closePath()

    def draw_line_with_arcs(pen, char_width, y_bottom, y_top, left_arc, right_arc, is_overline):
        """Draw a line segment with optional arcs at endpoints."""
        arc_radius = min(line_thickness * 2, char_width / 4)

        # Determine arc geometry based on line type
        if is_overline:
            # Arcs curve upward
            left_cx, left_cy = arc_radius, y_top - arc_radius
            left_start, left_end, left_cw = 90, 180, False
            right_cx, right_cy = char_width - arc_radius, y_top - arc_radius
            right_start, right_end, right_cw = 90, 0, True
        else:
            # Arcs curve downward
            left_cx, left_cy = arc_radius, y_bottom + arc_radius
            left_start, left_end, left_cw = 270, 180, True
            right_cx, right_cy = char_width - arc_radius, y_bottom + arc_radius
            right_start, right_end, right_cw = 270, 360, False

        # Calculate line segment endpoints
        line_x_start = arc_radius if left_arc else 0
        line_x_end = (char_width - arc_radius) if right_arc else char_width

        # Draw arcs if needed
        if left_arc:
            draw_quarter_arc(pen, left_cx, left_cy, arc_radius, left_start, left_end, left_cw)
        if right_arc:
            draw_quarter_arc(pen, right_cx, right_cy, arc_radius, right_start, right_end, right_cw)

        # Draw line segment (if there's space between arcs)
        if line_x_start < line_x_end:
            pen.moveTo((line_x_start, y_bottom))
            pen.lineTo((line_x_end, y_bottom))
            pen.lineTo((line_x_end, y_top))
            pen.lineTo((line_x_start, y_top))
            pen.closePath()

    variant_map = {}
    created_count = 0
    skipped_count = 0

    for system_name, config in PUA_NOTE_LINE_CONFIG.items():
        source_base = config['source_base']
        line_base = config['line_base']
        note_count = config['note_count']

        breakdown = config.get('breakdown', f'{note_count} notes')
        print(f"    Processing {system_name}: {breakdown} × 15 line variants = {note_count * 15} glyphs")
        import sys

        for note_offset in range(note_count):
            # Progress output every 50 notes
            if note_offset > 0 and note_offset % 50 == 0:
                print(f"      {note_offset}/{note_count} notes processed...", flush=True)

            source_cp = source_base + note_offset

            try:
                source_glyph = font[source_cp]
                if not source_glyph or not source_glyph.glyphname:
                    skipped_count += 1
                    continue

                original_width = source_glyph.width
                if original_width <= 0:
                    skipped_count += 1
                    continue

                # Pad narrow characters to ensure arcs fit properly
                # (same logic as create_15_line_variants)
                MIN_LINE_VARIANT_WIDTH = 400
                if original_width < MIN_LINE_VARIANT_WIDTH:
                    char_width = MIN_LINE_VARIANT_WIDTH
                    x_offset = (MIN_LINE_VARIANT_WIDTH - original_width) / 2
                else:
                    char_width = original_width
                    x_offset = 0

                for variant_idx, underline_state, overline_state in LINE_VARIANT_TYPES:
                    # Calculate target codepoint: line_base + (note_offset × 15) + variant_idx
                    target_cp = line_base + (note_offset * 15) + variant_idx

                    glyph_name = f"note_line_{source_cp:05X}_v{variant_idx}"
                    variant_glyph = font.createChar(target_cp, glyph_name)
                    variant_glyph.clear()

                    # Add reference to source glyph (with offset for narrow chars)
                    if x_offset > 0:
                        variant_glyph.addReference(source_glyph.glyphname, (1, 0, 0, 1, x_offset, 0))
                    else:
                        variant_glyph.addReference(source_glyph.glyphname)

                    # Draw line geometry
                    pen = variant_glyph.glyphPen(replace=False)

                    # Draw underline if specified
                    if underline_state:
                        left_arc = underline_state == 'left'
                        right_arc = underline_state == 'right'
                        draw_line_with_arcs(pen, char_width, underline_y_bottom, underline_y_top,
                                         left_arc, right_arc, is_overline=False)

                    # Draw overline if specified
                    if overline_state:
                        left_arc = overline_state == 'left'
                        right_arc = overline_state == 'right'
                        draw_line_with_arcs(pen, char_width, overline_y_bottom, overline_y_top,
                                         left_arc, right_arc, is_overline=True)

                    pen = None

                    # Set width to match source
                    variant_glyph.width = char_width

                    # Copy anchor points from source glyph
                    try:
                        for anchor in source_glyph.anchorPoints:
                            variant_glyph.addAnchorPoint(*anchor)
                    except (AttributeError, TypeError):
                        pass

                    variant_glyph.correctDirection()
                    variant_map[(source_cp, variant_idx)] = target_cp
                    created_count += 1

            except Exception as e:
                skipped_count += 1
                continue

    print(f"  [PUA NOTE LINES] ✓ Created {created_count} variants, skipped {skipped_count}")
    return variant_map


def add_gpos_mark_feature(font, mark_codepoints):
    """
    Add GPOS 'mark' feature for attaching marks to base glyphs.

    This enables automatic positioning of octave dots and accidentals
    using anchor points defined on base glyphs and marks.

    Args:
        font: FontForge font object
        mark_codepoints: Dict of mark_name -> codepoint from create_gpos_mark_glyphs

    Returns:
        bool: True if feature was added successfully
    """
    print(f"\n  [GPOS] Adding mark attachment feature...")

    try:
        # Create GPOS mark lookup for above marks (octave dots)
        lookup_above = "gpos_mark_above"
        font.addLookup(lookup_above, 'gpos_mark2base', (),
                      (('mark', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_above, "mark_above_subtable")

        # Create GPOS mark lookup for below marks
        lookup_below = "gpos_mark_below"
        font.addLookup(lookup_below, 'gpos_mark2base', (),
                      (('mark', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_below, "mark_below_subtable")

        # Create GPOS mark lookup for right marks (accidentals)
        lookup_right = "gpos_mark_right"
        font.addLookup(lookup_right, 'gpos_mark2base', (),
                      (('mark', (('DFLT', ('dflt',)), ('latn', ('dflt',)))),))
        font.addLookupSubtable(lookup_right, "mark_right_subtable")

        print(f"  [GPOS] ✓ Mark feature lookups created")
        return True

    except Exception as e:
        print(f"  [GPOS] Warning: Could not add mark feature: {e}")
        return False


# ============================================================================
# Superscript Variants (50% scaled for grace notes)
# Uses Supplementary PUA-A (0xF0000+) - see atoms.yaml superscript_variants
# ============================================================================

# Superscript geometry constants
SUPERSCRIPT_SCALE = 0.5  # 50% size for grace notes
# Position: 25% below top of font (ascender ~1000, so top at 750)
# With 50% scale, glyph top ~350, so offset = 750 - 350 = 400
SUPERSCRIPT_Y_OFFSET = 400  # Position 25% below font top
# Underline geometry (matches regular character underlines)
SUPERSCRIPT_UNDERLINE_Y_BOTTOM = -154  # Same as regular underlines
SUPERSCRIPT_UNDERLINE_Y_TOP = -90  # Same as regular underlines (thickness ~64 units)


def create_superscript_variants(font, layout, atoms_config):
    """
    Create 50% scaled superscript variants with 16 line options each.

    Creates superscript variants for:
    - ASCII printable characters (0x20-0x7E)
    - All PUA pitch variants (Number, Western, Sargam, Doremi systems)

    Each source glyph gets 16 variants:
    - variant 0: no lines
    - variants 1-3: underline only (1=left, 2=middle, 3=right)
    - variants 4-6: overline only (4=left, 5=middle, 6=right)
    - variants 7-15: combined underline+overline (9 combinations)

    Formula (MUST match build.rs):
    superscript_cp = system_base + (source_offset × 16) + line_variant

    Args:
        font: FontForge font object
        layout: CodepointLayout with note_atoms
        atoms_config: Parsed atoms.yaml configuration

    Returns:
        dict: Mapping of (source_codepoint, line_variant) → superscript_codepoint
    """
    superscript_config = atoms_config.get('pua_allocation', {}).get('superscript_variants', {})
    if not superscript_config:
        print(f"  WARNING: No superscript_variants config in atoms.yaml")
        return {}

    scale = superscript_config.get('scale_factor', SUPERSCRIPT_SCALE)
    geometry = superscript_config.get('geometry', {})
    y_offset = geometry.get('y_offset', SUPERSCRIPT_Y_OFFSET)
    # Underline positions match regular character underlines
    # (SUPERSCRIPT_UNDERLINE_Y_BOTTOM/TOP are used directly in _add_superscript_underline)

    variant_map = {}
    created_count = 0

    # Part 1: ASCII superscripts
    ascii_config = superscript_config.get('ascii_superscripts', {})
    if ascii_config:
        ascii_base = ascii_config.get('pua_base', 0xF0000)
        source_range = ascii_config.get('source_range', [0x20, 0x7E])

        print(f"    Creating ASCII superscripts (0x{ascii_base:05X}+)...")
        for source_cp in range(source_range[0], source_range[1] + 1):
            try:
                source_glyph = font[source_cp]
                if not source_glyph or source_glyph.width <= 0:
                    continue

                source_offset = source_cp - source_range[0]
                created = _create_superscript_glyph_set(
                    font, source_glyph, ascii_base, source_offset,
                    scale, y_offset)
                created_count += created
                for lv in range(16):
                    variant_map[(source_cp, lv)] = ascii_base + (source_offset * 16) + lv
            except Exception:
                pass

        print(f"    ✓ Created {created_count} ASCII superscript glyphs")

    # Part 2: PUA pitch superscripts (per system)
    system_configs = [
        ('number', 'number_superscripts'),
        ('western', 'western_superscripts'),
        ('sargam', 'sargam_superscripts'),
        ('doremi', 'doremi_superscripts'),
    ]

    for system_name, config_key in system_configs:
        sys_config = superscript_config.get(config_key, {})
        if not sys_config:
            continue

        super_base = sys_config.get('pua_base')
        source_base = sys_config.get('source_base')
        chars = sys_config.get('chars', 0)
        variants_per_char = sys_config.get('variants_per_char', 30)
        total_source = chars * variants_per_char

        if not super_base or not source_base:
            continue

        print(f"    Creating {system_name} superscripts (0x{super_base:05X}+)...")
        system_count = 0

        for source_offset in range(total_source):
            source_cp = source_base + source_offset
            try:
                source_glyph = font[source_cp]
                if not source_glyph or source_glyph.width <= 0:
                    continue

                created = _create_superscript_glyph_set(
                    font, source_glyph, super_base, source_offset,
                    scale, y_offset)
                system_count += created
                created_count += created
                for lv in range(16):
                    variant_map[(source_cp, lv)] = super_base + (source_offset * 16) + lv
            except Exception:
                pass

        print(f"    ✓ Created {system_count} {system_name} superscript glyphs")

    print(f"  ✓ Total superscript variants created: {created_count}")
    return variant_map


def _create_superscript_glyph_set(font, source_glyph, pua_base, source_offset,
                                   scale, y_offset):
    """
    Create 16 superscript variants for a single source glyph.

    Variants:
        0: no lines
        1-3: underline only (1=left, 2=middle, 3=right)
        4-6: overline only (4=left, 5=middle, 6=right)
        7-15: combined underline+overline (9 combinations)
              7 = under_left + over_left
              8 = under_left + over_middle
              9 = under_left + over_right
              10 = under_middle + over_left
              11 = under_middle + over_middle
              12 = under_middle + over_right
              13 = under_right + over_left
              14 = under_right + over_middle
              15 = under_right + over_right

    Formula: variant_cp = pua_base + (source_offset × 16) + line_variant

    Returns number of glyphs created (0-16).
    """
    VARIANTS_PER_GLYPH = 16
    created = 0

    # Get source glyph metrics
    try:
        bbox = source_glyph.boundingBox()
        if not bbox:
            return 0
        bx_min, by_min, bx_max, by_max = bbox
    except (RuntimeError, ValueError) as e:
        print(f"    Warning: Could not get bounding box: {e}")
        return 0

    # Calculate transformation
    # Center the scaled glyph horizontally
    x_offset = bx_min * (1 - scale)

    # Width MUST be scaled to match the glyph size
    scaled_width = int(source_glyph.width * scale)

    for line_variant in range(VARIANTS_PER_GLYPH):
        variant_cp = pua_base + (source_offset * VARIANTS_PER_GLYPH) + line_variant
        glyph_name = f"super_{variant_cp:05X}"

        try:
            variant_glyph = font.createChar(variant_cp, glyph_name)
            variant_glyph.clear()

            # Add scaled reference to source glyph
            # Transformation matrix: (xx, xy, yx, yy, x_offset, y_offset)
            variant_glyph.addReference(
                source_glyph.glyphname,
                (scale, 0, 0, scale, x_offset, y_offset)
            )

            # Determine what lines to add based on variant
            if line_variant == 0:
                # No lines
                pass
            elif 1 <= line_variant <= 3:
                # Underline only (1=left, 2=middle, 3=right)
                _add_superscript_underline(
                    variant_glyph, scaled_width, 0,
                    UNDERLINE_Y_BOTTOM, UNDERLINE_Y_TOP,
                    line_variant)
            elif 4 <= line_variant <= 6:
                # Overline only (4=left, 5=middle, 6=right)
                overline_style = line_variant - 3  # 1=left, 2=middle, 3=right
                _add_superscript_overline(
                    variant_glyph, scaled_width, scale,
                    OVERLINE_Y_BOTTOM, OVERLINE_Y_TOP,
                    overline_style)
            else:
                # Combined (variants 7-15)
                # Draw both underline and overline with single pen to avoid issues
                pen = variant_glyph.glyphPen(replace=False)

                # Draw underline (full width rectangle)
                pen.moveTo((0, UNDERLINE_Y_BOTTOM))
                pen.lineTo((scaled_width, UNDERLINE_Y_BOTTOM))
                pen.lineTo((scaled_width, UNDERLINE_Y_TOP))
                pen.lineTo((0, UNDERLINE_Y_TOP))
                pen.closePath()

                # Draw overline (full width rectangle)
                pen.moveTo((0, OVERLINE_Y_BOTTOM))
                pen.lineTo((scaled_width, OVERLINE_Y_BOTTOM))
                pen.lineTo((scaled_width, OVERLINE_Y_TOP))
                pen.lineTo((0, OVERLINE_Y_TOP))
                pen.closePath()

                pen = None

            variant_glyph.width = scaled_width
            variant_glyph.correctDirection()
            created += 1

        except Exception as e:
            print(f"    ERROR creating superscript U+{variant_cp:05X}: {e}")

    return created


def _add_superscript_overline(glyph, base_width, scale, y_bottom, y_top, variant):
    """
    Add overline to superscript glyph (matches regular character overlines).

    base_width: advance width of the scaled glyph
    scale: scale factor (unused, kept for API compatibility)
    variant: 1=left-cap, 2=middle, 3=right-cap

    Uses simple rectangles (no curves) for reliability.
    """
    x_start = 0
    x_end = base_width

    pen = glyph.glyphPen(replace=False)

    # All variants use a simple rectangle (no curves for reliability)
    # The full overline from x_start to x_end
    pen.moveTo((x_start, y_bottom))
    pen.lineTo((x_end, y_bottom))
    pen.lineTo((x_end, y_top))
    pen.lineTo((x_start, y_top))
    pen.closePath()

    pen = None


def _add_superscript_underline(glyph, width, x_start, y_bottom, y_top, variant):
    """
    Add underline to superscript glyph (matches regular character underlines).

    width: actual bounding box width of the scaled glyph
    x_start: x position where underline starts (left edge of scaled glyph)
    variant: 1=left-cap, 2=middle, 3=right-cap

    Uses simple rectangles (no curves) for reliability.
    """
    x_end = x_start + width

    pen = glyph.glyphPen(replace=False)

    # All variants use a simple rectangle (no curves for reliability)
    # The full underline from x_start to x_end
    pen.moveTo((x_start, y_bottom))
    pen.lineTo((x_end, y_bottom))
    pen.lineTo((x_end, y_top))
    pen.lineTo((x_start, y_top))
    pen.closePath()

    pen = None


# ============================================================================
# Stage 3: Build Font
# ============================================================================

def build_font(
    base_font_path: str,
    bold_font_path: str,
    noto_music_path: str,
    spec: AtomSpec,
    layout: CodepointLayout,
    strict_mode: bool = False,
    bravura_path: str = None
) -> 'fontforge.font':
    """
    Generate NotationFont: Noto Sans base + Noto Music symbols + custom octave variants.

    Steps:
        1. Load Noto Sans as base (has ASCII characters with professional typography)
        2. Load Noto Sans Bold for pitch characters
        3. Import SMuFL symbols from Noto Music
        4. Import missing SMuFL symbols from Bravura (fallback)
        5. Add a synthetic dot glyph for octave variants
        6. Create custom octave variants (dots above/below) - using bold for pitches
        7. Rename font to NotationFont
        8. Return the enhanced font

    Args:
        base_font_path: Path to Noto Sans Regular
        bold_font_path: Path to Noto Sans Bold for pitch characters
        strict_mode: If True, fail on errors
        bravura_path: Path to Bravura font for fallback symbols

    Returns:
        fontforge.font object
    """
    print(f"\n[STAGE 3] Building NotationFont (Noto Sans base + Noto Music symbols + custom variants)")

    if not fontforge:
        raise RuntimeError("FontForge module not available. Cannot build font.")

    # Load Noto Sans as the base font (has ASCII characters with professional typography)
    if not base_font_path or not os.path.exists(base_font_path):
        if strict_mode:
            raise FileNotFoundError(f"Base font not found: {base_font_path}")
        else:
            raise FileNotFoundError(f"Base font not found: {base_font_path}")

    print(f"  Loading base font (Noto Sans): {base_font_path}")
    try:
        font = fontforge.open(base_font_path)
        print(f"  ✓ Base font loaded")
    except Exception as e:
        raise RuntimeError(f"Failed to load base font: {e}")

    # Correct direction and calculate proper sidebearings for ALL base glyphs
    # This fixes the "after" (right sidebearing) for characters like "1", "2", "3"
    print(f"  Correcting base glyphs (fixing sidebearings)...")
    corrected_count = 0
    for glyph in font.glyphs():
        if glyph.unicode > 0:  # Only process encoded glyphs
            try:
                glyph.correctDirection()
                glyph.round()
                corrected_count += 1
            except Exception as e:
                # Some glyphs might fail, that's okay
                pass
    print(f"  ✓ Corrected {corrected_count} base glyphs")

    # Add centered anchor points for combining mark positioning
    print(f"  Adding centered anchor points for combining marks...")
    anchors_added = add_centered_anchors(font)
    print(f"  ✓ Added anchor points to {anchors_added} pitch characters")

    # Load Noto Sans Bold for pitch characters
    bold_font = None
    if bold_font_path and os.path.exists(bold_font_path):
        print(f"  Loading bold font (Noto Sans Bold): {bold_font_path}")
        try:
            bold_font = fontforge.open(bold_font_path)
            print(f"  ✓ Bold font loaded")
            # Correct bold glyphs as well
            bold_corrected = 0
            for glyph in bold_font.glyphs():
                if glyph.unicode > 0:
                    try:
                        glyph.correctDirection()
                        glyph.round()
                        bold_corrected += 1
                    except (RuntimeError, ValueError):
                        pass  # Some glyphs can't be corrected
            print(f"  ✓ Corrected {bold_corrected} bold glyphs")
        except Exception as e:
            if strict_mode:
                raise RuntimeError(f"Failed to load bold font: {e}")
            else:
                print(f"  WARNING: Could not load bold font: {e}")
                bold_font = None
    else:
        print(f"  WARNING: Bold font not found: {bold_font_path}")

    # Build set of pitch characters from all notation systems
    pitch_chars = set()
    for system_name, chars in spec.notation_systems.items():
        for char in chars:
            pitch_chars.add(char)
    print(f"  Pitch characters (will use bold): {sorted(pitch_chars)}")

    # Import SMuFL symbols from Noto Music
    noto_music_font = None
    if noto_music_path and os.path.exists(noto_music_path):
        print(f"  Loading Noto Music for SMuFL symbols: {noto_music_path}")
        try:
            noto_music_font = fontforge.open(noto_music_path)
            print(f"  ✓ Noto Music loaded")
            # Import only the accidental symbols we need for composite glyphs
            # Standard Unicode accidentals (NOT quarter-tone variants):
            # - U+266D: Music Flat Sign (standard flat)
            # - U+266F: Music Sharp Sign (standard sharp)
            # - U+1D12B: Musical Symbol Double Flat
            # - U+1D12A: Musical Symbol Double Sharp
            print(f"  Importing accidental symbols from Noto Music...")
            symbols_imported = 0
            accidental_codepoints = [0x266D, 0x266F, 0x1D12B, 0x1D12A]
            for codepoint in accidental_codepoints:
                try:
                    glyph = noto_music_font[codepoint]
                    if glyph and glyph.glyphname:
                        new_glyph = font.createChar(codepoint, glyph.glyphname)
                        pen = new_glyph.glyphPen()
                        if pen:
                            glyph.draw(pen)
                            pen = None
                        if glyph.width:
                            new_glyph.width = glyph.width
                        symbols_imported += 1
                except (KeyError, RuntimeError):
                    pass  # Symbol not found in source font
            print(f"  ✓ Imported {symbols_imported} accidental symbols from Noto Music")
        except Exception as e:
            if strict_mode:
                raise RuntimeError(f"Failed to import Noto Music symbols: {e}")
            else:
                print(f"  WARNING: Could not import Noto Music: {e}")

    # Import symbols that explicitly specify Bravura as source
    bravura_font = None
    bravura_symbols = [s for s in spec.smufl_symbols if s.source_font == "bravura"]
    if bravura_symbols:
        if not bravura_path or not os.path.exists(bravura_path):
            msg = f"Bravura font required for {len(bravura_symbols)} symbols but not found: {bravura_path}"
            if strict_mode:
                raise RuntimeError(msg)
            else:
                print(f"  WARNING: {msg}")
        else:
            print(f"  Loading Bravura for {len(bravura_symbols)} symbols: {bravura_path}")
            try:
                bravura_font = fontforge.open(bravura_path)
                print(f"  ✓ Bravura loaded")
                bravura_imported = 0
                for symbol in bravura_symbols:
                    try:
                        # Get glyph from Bravura
                        src_glyph = bravura_font[symbol.smufl_codepoint]
                        if src_glyph and src_glyph.glyphname:
                            # Create in target font
                            new_glyph = font.createChar(symbol.smufl_codepoint, src_glyph.glyphname)
                            # Copy the glyph data
                            pen = new_glyph.glyphPen()
                            if pen:
                                src_glyph.draw(pen)
                                pen = None
                            # Copy width
                            if src_glyph.width:
                                new_glyph.width = src_glyph.width
                            bravura_imported += 1
                            print(f"    ✓ Imported {symbol.label} from Bravura")
                    except Exception as e:
                        msg = f"Failed to import {symbol.label} from Bravura: {e}"
                        if strict_mode:
                            raise RuntimeError(msg)
                        else:
                            print(f"    ✗ {msg}")
                print(f"  ✓ Imported {bravura_imported}/{len(bravura_symbols)} glyphs from Bravura")
                bravura_font.close()
            except Exception as e:
                msg = f"Could not load Bravura: {e}"
                if strict_mode:
                    raise RuntimeError(msg)
                else:
                    print(f"  WARNING: {msg}")

    # Rename to NotationFont
    font.fontname = "NotationFont"
    font.fullname = "NotationFont"
    font.familyname = "NotationFont"

    # Get or create dot glyph
    dot_glyph = None
    dot_codepoint = ord('.')
    try:
        dot_glyph = font[dot_codepoint]
    except (KeyError, TypeError):
        pass  # Glyph doesn't exist, will create below

    # If no period glyph exists, create a synthetic one
    if not dot_glyph or not dot_glyph.glyphname:
        print(f"  Creating synthetic dot glyph...")
        try:
            dot_glyph = font.createChar(dot_codepoint, "period")
        except (RuntimeError, ValueError):
            try:
                dot_glyph = font[dot_codepoint]
            except (KeyError, TypeError) as e:
                raise RuntimeError(f"ERROR: Could not create or find dot glyph: {e}")

        # Create a small circle/dot using bezier curves
        pen = dot_glyph.glyphPen()
        if pen:
            # Draw a small circle at origin (100 units radius, typical font units)
            # This is a crude implementation - just a square for simplicity
            size = 100
            pen.moveTo((0, 0))
            pen.lineTo((size, 0))
            pen.lineTo((size, size))
            pen.lineTo((0, size))
            pen.closePath()
            pen = None
        dot_glyph.width = size + 50  # Add some padding
        print(f"    Created synthetic dot")

    else:
        print(f"  Using existing dot glyph from Noto Music")

    dot_bbox = dot_glyph.boundingBox()
    if not dot_bbox:
        raise RuntimeError("ERROR: Could not get bounding box for dot glyph")

    dx_min, dy_min, dx_max, dy_max = dot_bbox
    dot_width = dx_max - dx_min
    dot_height = dy_max - dy_min
    dot_name = dot_glyph.glyphname

    print(f"  Dot glyph: {dot_name}, size: {dot_width}x{dot_height}")

    # Create half-flat accidental glyph (flat + diagonal slash)
    # IMPORTANT: The head must remain HOLLOW (not filled)
    # We copy the base flat symbol AS-IS (preserving its hollow head) and add only a slash
    print(f"\n  Creating half-flat accidental glyph...")
    halfflat_cp = 0xF8FF  # Temporary PUA codepoint for half-flat accidental
    halfflat_glyph = font.createChar(halfflat_cp, "halfflat_accidental")
    halfflat_glyph.clear()

    # Copy flat symbol outlines directly (preserves hollow head from Noto Music)
    try:
        flat_glyph = font[0x266D]
        if flat_glyph and flat_glyph.glyphname:
            # Copy flat glyph's outlines AS-IS using draw() method
            # This preserves BOTH the outer contour AND the inner contour (the hollow)
            # NO head filling occurs - the head remains hollow exactly as in the base flat
            pen = halfflat_glyph.glyphPen()
            flat_glyph.draw(pen)

            # Now add diagonal slash through the STEM ONLY (not the head)
            # This is the ONLY modification - we add a slash contour, nothing else
            # Traditional half-flat: hollow head (unchanged from base flat) + slash through vertical stem
            # From halfflat-accidental.svg: slash at x=110-190 (stem), y=100-600
            flat_bbox = flat_glyph.boundingBox()
            fx_min, fy_min, fx_max, fy_max = flat_bbox

            # The flat symbol structure:
            # - Left side: vertical stem (narrow)
            # - Right side: rounded head (wider, HOLLOW)
            # We position the slash ONLY on the stem (left ~20% of the glyph)
            # The head remains completely untouched

            stem_width = (fx_max - fx_min) * 0.25  # Stem is about 25% of total width

            # Position slash at 2/3 up the stem (like a diagonal crossbar through a "t")
            # The slash cuts through the stem at 2/3 height from bottom
            slash_center_y = fy_min + (fy_max - fy_min) * 0.67  # Center at 67% height (2/3 up)

            # Slash geometry (diagonal crossbar through stem, like "t")
            slash_stroke_width = 60  # Thickness of the slash stroke (thinner)
            slash_length = stem_width * 4.0  # Slash extends wider across the stem

            # Calculate diagonal slash endpoints (goes from left-low to right-high)
            # The slash tilts upward as it crosses the stem
            # IMPORTANT: The stem should be at the HALFWAY POINT of the slash
            slash_angle_rise = (fy_max - fy_min) * 0.15  # Diagonal rise over the slash length

            # Center the slash horizontally so the stem (at fx_min) is at the midpoint
            # Left edge of slash (lower) - extends to the left of stem
            slash_left_x = fx_min - slash_length / 2
            slash_left_y = slash_center_y - slash_angle_rise / 2

            # Right edge of slash (higher) - extends to the right of stem
            slash_right_x = fx_min + slash_length / 2
            slash_right_y = slash_center_y + slash_angle_rise / 2

            # Draw diagonal slash as a NEW closed contour (this is the only addition)
            # The slash cuts through the stem like a diagonal crossbar (like a "t")
            # Draw as a parallelogram with perpendicular thickness
            import math

            # Calculate perpendicular offset for stroke width
            # The slash goes diagonally, so we need perpendicular offset
            slash_dx = slash_right_x - slash_left_x
            slash_dy = slash_right_y - slash_left_y
            slash_dist = math.sqrt(slash_dx**2 + slash_dy**2)

            # Unit perpendicular vector (rotated 90 degrees)
            perp_x = -slash_dy / slash_dist
            perp_y = slash_dx / slash_dist

            # Half stroke width offset
            half_stroke = slash_stroke_width / 2
            offset_x = perp_x * half_stroke
            offset_y = perp_y * half_stroke

            # Four corners of the parallelogram
            # Bottom-left corner
            pen.moveTo((int(slash_left_x - offset_x), int(slash_left_y - offset_y)))
            # Bottom-right corner
            pen.lineTo((int(slash_right_x - offset_x), int(slash_right_y - offset_y)))
            # Top-right corner
            pen.lineTo((int(slash_right_x + offset_x), int(slash_right_y + offset_y)))
            # Top-left corner
            pen.lineTo((int(slash_left_x + offset_x), int(slash_left_y + offset_y)))
            pen.closePath()  # Close the slash contour only (does NOT affect the head)
            pen = None

            # Set width to match flat symbol
            halfflat_glyph.width = flat_glyph.width

            # Correct direction after drawing
            halfflat_glyph.correctDirection()
            print(f"  ✓ Created half-flat accidental glyph at U+{halfflat_cp:04X}")
    except Exception as e:
        print(f"  ✗ Failed to create half-flat accidental: {e}")
        halfflat_glyph = None

    # =========================================================================
    # NEW ARCHITECTURE: GPOS Marks + 15 Line Variants
    # =========================================================================
    # Set USE_NEW_ARCHITECTURE = True to enable the new font architecture
    # with GPOS marks for octave dots/accidentals and 15 line variants.
    # The old pre-composed octave/accidental variants will still be created
    # for backwards compatibility until the Rust export layer is updated.
    USE_NEW_ARCHITECTURE = True

    if USE_NEW_ARCHITECTURE:
        print(f"\n  [NEW ARCH] Enabling GPOS marks + 15 line variants architecture")

        # Step 1: Add base anchor points for GPOS mark attachment
        add_base_glyph_anchors(font, line_capable_only=True)

        # Step 2: Create GPOS mark glyphs (octave dots + accidentals)
        mark_codepoints = create_gpos_mark_glyphs(font, dot_glyph, spec)

        # Step 3: Create 15 line variants per ASCII printable character
        line_variant_pua_bases = {
            'underline': 0xE800,  # 95 chars × 3 variants = 285
            'overline': 0xE920,   # 95 chars × 3 variants = 285
            'combined': 0xEA40,   # 95 chars × 9 variants = 855
        }
        line_variant_map = create_15_line_variants(font, line_variant_pua_bases)

        # Step 4: Add GPOS mark feature for attaching marks to bases
        add_gpos_mark_feature(font, mark_codepoints)

        print(f"  [NEW ARCH] ✓ New architecture setup complete")
        print(f"             - {len(mark_codepoints)} GPOS marks")
        print(f"             - {len(line_variant_map)} line variants")

    # =========================================================================
    # LEGACY: Pre-composed octave/accidental variants
    # =========================================================================
    # This creates the old-style pre-composed glyphs for backwards compatibility.
    # Once the Rust export layer is updated to emit the new encoding, this can
    # be removed.

    # Create note glyphs
    print(f"\n  Creating {len(layout.note_atoms)} note glyphs...")
    # Track target widths for glyphs with accidentals (to be set after unlinkRef())
    target_widths = {}
    for i, atom in enumerate(layout.note_atoms):
        # Choose source font: bold for pitch characters, regular for everything else
        is_pitch = atom.character in pitch_chars
        source_font = bold_font if (is_pitch and bold_font) else font

        try:
            base_glyph = source_font[ord(atom.character)]
        except Exception as e:
            font_type = "bold" if is_pitch else "regular"
            raise RuntimeError(f"Base character '{atom.character}' (U+{ord(atom.character):04X}) not found in {font_type} font: {e}")

        if not base_glyph:
            font_type = "bold" if is_pitch else "regular"
            raise RuntimeError(f"Base character '{atom.character}' (U+{ord(atom.character):04X}) is empty in {font_type} font")

        base_bbox = base_glyph.boundingBox()
        if not base_bbox:
            raise RuntimeError(f"Could not get bbox for '{atom.character}'")

        bx_min, by_min, bx_max, by_max = base_bbox
        base_width = bx_max - bx_min
        base_glyph_name = base_glyph.glyphname

        # Position dot horizontally centered over the character
        dot_x_offset = bx_min + (base_width - dot_width) / 2 - dx_min

        # Create composite glyph
        g = font.createChar(atom.assigned_codepoint, f"{atom.character}_v{atom.variant_index}")
        g.clear()

        # Reference the base glyph instead of copying outlines
        # This keeps font lightweight - browser only parses ~47 base glyphs, not 1175 copies
        g.addReference(base_glyph.glyphname)

        # NEW LAYOUT: variant_index (0-24) encodes (accidental_type × 5) + octave_idx
        # accidental_types: [0=natural, 1=flat, 2=double-flat, 3=sharp, 4=double-sharp]
        # octave_idx: [0=base (octave 0), 1=octave -2, 2=octave -1, 3=octave +1, 4=octave +2]
        acc_type = atom.variant_index // 5
        octave_idx = atom.variant_index % 5

        # Add accidental symbol if not natural
        # CRITICAL: Must match assign_codepoints() acc_blocks ordering (lines 369-376)
        # acc_type from variant_index: 0=natural, 1=flat, 2=half-flat, 3=double-flat, 4=double-sharp, 5=sharp
        # EXCEPTION: Sargam komal/tivra notes (r, g, m, d, n, M) should NEVER get accidentals
        # In Sargam, case itself indicates pitch: r=komal Re, g=komal Ga, m=komal ma, d=komal Dha, n=komal Ni, M=tivra Ma
        SARGAM_NO_ACCIDENTALS = {'r', 'g', 'm', 'd', 'n', 'M'}
        if acc_type > 0 and atom.character not in SARGAM_NO_ACCIDENTALS:
            try:
                acc_glyph = None
                if acc_type == 1:  # Flat
                    acc_glyph = font[0x266D]
                elif acc_type == 2:  # Half-flat (use the half-flat accidental glyph we created)
                    acc_glyph = halfflat_glyph if halfflat_glyph else None
                elif acc_type == 3:  # Double-flat
                    acc_glyph = font[0x1D12B]
                elif acc_type == 4:  # Double-sharp
                    acc_glyph = font[0x1D12A]
                elif acc_type == 5:  # Sharp
                    acc_glyph = font[0x266F]

                if acc_glyph and acc_glyph.glyphname:
                    # Calculate y-offset (raise sharp and double-sharp symbols by 30% of font height)
                    y_offset = 0
                    if acc_type == 5 or acc_type == 4:  # Sharp or Double-sharp
                        char_height = by_max - by_min
                        y_offset = char_height * 0.3

                    # Position accidental to the right of the character (at bx_max where char ends)
                    g.addReference(acc_glyph.glyphname, (1, 0, 0, 1, bx_max, y_offset))

                    # Store the target width for later (will be set after unlinkRef())
                    # Width = where base ends + accidental advance width
                    target_width = int(bx_max + acc_glyph.width)
                    target_widths[atom.assigned_codepoint] = target_width
            except (KeyError, TypeError):
                pass  # Skip if accidental symbol not available

        # Add octave dots based on octave_idx
        # octave_idx maps to: [0→octave 0, 1→octave -2, 2→octave -1, 3→octave +1, 4→octave +2]
        if octave_idx == 0:
            # Base octave 0: no dots
            pass
        elif octave_idx == 1:  # Octave -2 (2 dots below)
            double_dot_scale = 0.6
            double_dot_spacing = 2 * dot_height * double_dot_scale
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos1 = by_min - dy_max - spec.geometry.dot_below_gap - dot_adjustment
            y_pos2 = y_pos1 - double_dot_spacing
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos1))
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos2))

        elif octave_idx == 2:  # Octave -1 (1 dot below)
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos = by_min - dy_max - spec.geometry.dot_below_gap - dot_adjustment
            g.addReference(dot_name, (1, 0, 0, 1, dot_x_offset, y_pos))

        elif octave_idx == 3:  # Octave +1 (1 dot above)
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos = by_max - dy_min + spec.geometry.dot_above_gap + dot_adjustment
            g.addReference(dot_name, (1, 0, 0, 1, dot_x_offset, y_pos))

        elif octave_idx == 4:  # Octave +2 (2 dots above)
            double_dot_scale = 0.6
            double_dot_spacing = 2 * dot_height * double_dot_scale
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos1 = by_max - dy_min + spec.geometry.dot_above_gap + dot_adjustment
            y_pos2 = y_pos1 + double_dot_spacing
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos1))
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos2))

        # Use SAME width as base character (preserve original spacing behavior)
        # Octave variants should have identical horizontal behavior to their base characters
        g.width = base_glyph.width

        if (i + 1) % 50 == 0:
            print(f"    Created {i + 1}/{len(layout.note_atoms)} glyphs")

    # SMuFL symbols are already in Noto Music - no extraction needed!
    # Barlines (U+E030-E042), accidentals (U+E260-E264), ornaments (U+E566-E56E)
    # are all part of the standard font.
    print(f"\n  ✓ SMuFL symbols already present in Noto Music base font")

    # DISABLED: Accidental composites (overlapping with Western system at 0xE200+)
    # The new architecture uses 25 variants per character (5 accidentals × 5 octaves)
    # These legacy composites are not used and cause conflicts
    # else:

    # Correct direction for custom note glyphs
    print(f"\n  Finalizing {len(layout.note_atoms)} custom note glyphs...")

    # Correct direction for note atoms
    for atom in layout.note_atoms:
        g = font[atom.assigned_codepoint]
        if g:
            # CRITICAL: Unlink references first to convert them to actual outlines
            # References (accidentals, dots) won't export properly without this
            g.unlinkRef()
            g.correctDirection()

            # Set width AFTER unlinking (unlinkRef resets width to base glyph width)
            if atom.assigned_codepoint in target_widths:
                g.width = target_widths[atom.assigned_codepoint]

    print(f"  ✓ Finalized {len(layout.note_atoms)} custom note variants")

    # =========================================================================
    # PRE-COMPOSED LINE VARIANTS (GPOS removed for simplicity)
    # =========================================================================
    # Uses direct codepoint lookup in Rust (get_line_variant_codepoint)
    # Each note gets 15 pre-composed variants at 0x1A000+

    # Create unified 15-variant line system for ALL PUA note atoms
    # Replaces legacy separate underlined_notes, overlined_notes, combined_line_notes
    # Uses new PUA allocation at 0x1A000+ (from atoms.yaml pua_note_line_variants)
    print(f"\n  Creating unified 15-variant line system for PUA note atoms...")
    pua_note_line_map = create_pua_note_line_variants(font, layout)

    # NOTE: Old bracket variant code removed.
    # The new unified 15-variant line system already includes left/right arc
    # variants (indices 1, 2 for underline; 4, 5 for overline).

    # Reposition the combining marks to our lane positions
    # This ensures fallback rendering (when ligatures don't fire) is still correct
    print(f"  Repositioning combining marks to lane positions...")
    reposition_combining_marks(font)

    # Create line endpoint caps (rounded ends for underlines/overlines)
    print(f"  Creating line endpoint caps...")
    create_line_endpoint_caps(font)

    # Add ccmp ligatures for combining octave dots → precomposed glyphs
    # This enables octave dots to work WITHOUT CSS font-feature-settings
    print(f"  Adding ccmp ligatures for octave dots...")
    add_octave_dot_ligatures(font, layout)

    # NOTE: Old combined line+octave variants removed.
    # The new 15-variant system handles lines directly on PUA notes.

    # =========================================================================
    # SUPERSCRIPT VARIANTS (50% scaled for grace notes)
    # =========================================================================
    # Load atoms.yaml for superscript config
    atoms_yaml_path = os.path.join(os.path.dirname(__file__), "atoms.yaml")
    with open(atoms_yaml_path, 'r') as f:
        atoms_config = yaml.safe_load(f)

    print(f"\n  Creating superscript variants (50% scale)...")
    superscript_map = create_superscript_variants(font, layout, atoms_config)
    print(f"  ✓ Superscript variant map contains {len(superscript_map)} entries")

    # Close bold font if it was opened (and it's not the same as base font)
    if bold_font and bold_font_path != base_font_path:
        try:
            bold_font.close()
            print(f"  ✓ Closed bold font")
        except (RuntimeError, OSError):
            pass  # Font already closed or file error

    # Update font metrics to accommodate underlines and overlines in separate lanes
    # Lane positions:
    #   Overline: 1050 to 1114 (above dots)
    #   Underline: -350 to -286 (below dots)
    # Add margin for line-height
    NEW_ASCENT = 1200   # Above overline top (1114) with margin
    NEW_DESCENT = 450   # Below underline bottom (350) with margin

    font.hhea_ascent = NEW_ASCENT
    font.hhea_descent = -NEW_DESCENT
    font.os2_typoascent = NEW_ASCENT
    font.os2_typodescent = -NEW_DESCENT
    font.os2_winascent = NEW_ASCENT
    font.os2_windescent = NEW_DESCENT
    print(f"  ✓ Updated font metrics: ascent={NEW_ASCENT}, descent={NEW_DESCENT}")

    return font


# ============================================================================
# Stage 4: Build Mapping JSON
# ============================================================================

def symbol_kind(glyph_name: str) -> str:
    """
    Classify symbol by glyph name prefix.

    Supports both old (uni*) and new (accidental*, barline*, ornament*, bracket*) naming.
    """
    if glyph_name.startswith("accidental") or glyph_name.startswith("uni266"):
        return "accidental"
    if glyph_name.startswith("barline") or glyph_name.startswith("uniE0"):
        return "barline"
    if glyph_name.startswith("bracket") or glyph_name.startswith("reversedBracket"):
        return "bracket"
    return "ornament"


def build_mapping_json(spec: AtomSpec, layout: CodepointLayout) -> dict:
    """
    Generate minimal runtime JSON mapping.

    Only includes what the editor needs:
        - notes: system, character, variants with codepoints
        - symbols: name, kind, label, codepoint

    Returns:
        dict conforming to SPEC.md schema
    """
    print(f"\n[STAGE 4] Building JSON mapping")

    # Build notes map
    notes_map = {}  # (system, char) -> entry
    for atom in layout.note_atoms:
        key = (atom.system, atom.character)
        if key not in notes_map:
            notes_map[key] = {
                "system": atom.system,
                "character": atom.character,
                "variants": {}
            }

        # Map variant index to name and octave shift
        # Variants 0-3: Natural octaves
        # Variants 4-19: Accidentals with octaves (4 variants each for sharp, flat, double-sharp, double-flat)
        # Variant 20: Base octave natural (no dots)
        variant_index = atom.variant_index

        if variant_index == 0:
            variant_name = "1_dot_above"
            octave_shift = 1
        elif variant_index == 1:
            variant_name = "2_dots_above"
            octave_shift = 2
        elif variant_index == 2:
            variant_name = "1_dot_below"
            octave_shift = -1
        elif variant_index == 3:
            variant_name = "2_dots_below"
            octave_shift = -2
        elif variant_index == 20:
            variant_name = "base_octave"
            octave_shift = 0
        else:
            # Variants 4-19: Accidentals with octaves
            # For now, just generate generic names for these
            variant_name = f"variant_{variant_index}"
            octave_shift = 0  # These are handled differently

        notes_map[key]["variants"][variant_name] = {
            "codepoint": hex(atom.assigned_codepoint),
            "octave_shift": octave_shift
        }

    notes_list = list(notes_map.values())

    # Build symbols map (filter out old accidentals E260-E264 - now part of per-system PUA)
    # The new architecture includes accidentals within each system's PUA block
    old_accidental_range = range(0xE260, 0xE265)  # E260-E264
    symbols_list = [
        {
            "name": symbol.glyph_name,
            "kind": symbol_kind(symbol.glyph_name),
            "label": symbol.label,
            "codepoint": hex(symbol.assigned_codepoint),
        }
        for symbol in layout.symbols
        if symbol.assigned_codepoint not in old_accidental_range
    ]

    mapping = {
        "version": "1.0",
        "generated_from": "atoms.yaml",
        "pua_allocation": {
            "notes_start": hex(layout.notes_range[0]),
            "notes_end": hex(layout.notes_range[1]),
            "symbols_start": hex(layout.symbols_range[0]),
            "symbols_end": hex(layout.symbols_range[1]),
        },
        "notes": notes_list,
        "symbols": symbols_list,
        "summary": {
            "total_notes": len(notes_list),
            "total_symbols": len(symbols_list),
            "systems": {
                name: {
                    "count": len(chars),
                    "chars": ''.join(chars)
                }
                for name, chars in spec.notation_systems.items()
            }
        }
    }

    print(f"  ✓ Notes: {len(notes_list)}")
    print(f"  ✓ Symbols: {len(symbols_list)}")

    return mapping


# ============================================================================
# Stage 5: Validate Layout
# ============================================================================

def validate_layout(layout: CodepointLayout):
    """
    Pre-flight checks before font generation.

    Assertions:
        1. All atoms have codepoints assigned
        2. No duplicate codepoints within category (notes or symbols)
        3. All codepoints in valid PUA range
        4. No range overlap between categories
    """
    print(f"\n[STAGE 5] Validating layout")

    # Check all assigned
    all_atoms = layout.note_atoms + layout.symbols
    for i, atom in enumerate(all_atoms):
        if atom.assigned_codepoint is None:
            raise ValueError(f"Atom {i} not assigned a codepoint!")

    # Check no duplicates WITHIN note atoms
    note_codepoints = [atom.assigned_codepoint for atom in layout.note_atoms]
    if len(note_codepoints) != len(set(note_codepoints)):
        duplicates = [cp for cp in note_codepoints if note_codepoints.count(cp) > 1]
        raise ValueError(f"Duplicate codepoints in note atoms: {[hex(cp) for cp in set(duplicates)]}")

    # Check no duplicates WITHIN symbols
    symbol_codepoints = [atom.assigned_codepoint for atom in layout.symbols]
    if len(symbol_codepoints) != len(set(symbol_codepoints)):
        duplicates = [cp for cp in symbol_codepoints if symbol_codepoints.count(cp) > 1]
        raise ValueError(f"Duplicate codepoints in symbols: {[hex(cp) for cp in set(duplicates)]}")

    # Check codepoint ranges
    # Valid ranges:
    # - Note atoms: PUA 0xE100 - 0xE617 (per-system architecture)
    # - Symbols: Unicode Music 0x1D100-0x1D1FF OR SMuFL PUA 0xE000-0xF8FF
    for atom in all_atoms:
        valid = (
            (0xE000 <= atom.assigned_codepoint <= 0xF8FF) or  # PUA (SMuFL + per-system blocks)
            (0x1D100 <= atom.assigned_codepoint <= 0x1D1FF)    # Unicode Music
        )
        if not valid:
            raise ValueError(
                f"Codepoint {hex(atom.assigned_codepoint)} outside valid ranges "
                f"(PUA 0xE000-0xF8FF or Unicode Music 0x1D100-0x1D1FF)!"
            )

    print(f"  ✓ All {len(all_atoms)} atoms have valid, unique codepoints")
    print(f"  ✓ Note atoms: {hex(layout.notes_range[0])} - {hex(layout.notes_range[1])}")
    print(f"  ✓ Symbols: {hex(layout.symbols_range[0])} - {hex(layout.symbols_range[1])}")


# ============================================================================
# Debug Output
# ============================================================================

def write_debug_html(output_path: str, spec: AtomSpec, layout: CodepointLayout):
    """Generate debug specimen HTML"""
    print(f"\n[DEBUG] Writing specimen HTML: {output_path}")

    html_content = """<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>NotationFont Debug Specimen</title>
    <style>
        @font-face {
            font-family: 'NotationFont';
            src: url('./NotationFont.ttf') format('truetype');
        }
        body {
            font-family: 'NotationFont', monospace;
            font-size: 32px;
            line-height: 2;
            background: #fafafa;
            padding: 20px;
        }
        h1 { font-family: sans-serif; }
        h2 { font-family: sans-serif; margin-top: 1em; }
        .system { margin: 2em 0; }
        .char-row { margin: 0.5em 0; padding: 0.5em; background: white; border: 1px solid #ddd; }
        .label { font-family: sans-serif; font-size: 14px; color: #666; }
        .glyph { margin: 0 0.3em; }
    </style>
</head>
<body>
    <h1>NotationFont Debug Specimen</h1>
    <p class="label">Generated: v1.0 | Total glyphs: """ + str(len(layout.note_atoms) + len(layout.symbols)) + """</p>
"""

    # Add systems
    for system_name, characters in spec.notation_systems.items():
        html_content += f"    <div class='system'>\n"
        html_content += f"        <h2>{system_name.capitalize()} System ({len(characters)} chars × 4 variants)</h2>\n"
        for char in characters:
            # Find atoms for this character
            atoms = [a for a in layout.note_atoms if a.character == char and a.system == system_name]
            if atoms:
                atom_0 = atoms[0]
                html_content += f"        <div class='char-row'>\n"
                html_content += f"            <span class='label'>{char}:</span>\n"
                html_content += f"            <span class='glyph'>{char}</span>\n"  # Base
                for i in range(4):
                    atom = [a for a in atoms if a.variant_index == i]
                    if atom:
                        cp = atom[0].assigned_codepoint
                        html_content += f"            <span class='glyph'>{chr(cp)}</span>\n"
                html_content += f"        </div>\n"
        html_content += f"    </div>\n"

    # Add symbols
    html_content += f"""    <div class='system'>
        <h2>Symbols ({len(layout.symbols)} glyphs)</h2>
"""
    for symbol in layout.symbols:
        html_content += f"        <div class='char-row'>\n"
        html_content += f"            <span class='label'>{symbol.label}:</span>\n"
        html_content += f"            <span class='glyph'>{chr(symbol.assigned_codepoint)}</span>\n"
        html_content += f"        </div>\n"

    html_content += """    </div>
</body>
</html>
"""

    with open(output_path, 'w') as f:
        f.write(html_content)

    print(f"  ✓ Specimen HTML written")


# ============================================================================
# Main
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Notation Font Generator v6+ (SPEC.md-compliant)"
    )

    parser.add_argument(
        "--base-font",
        default="tools/fontgen/sources/NotoSans-Regular.ttf",
        help="Path to base text font (default: Noto Sans Regular)"
    )
    parser.add_argument(
        "--bold-font",
        default="tools/fontgen/sources/NotoSans-Bold.ttf",
        help="Path to bold text font for pitch characters (default: Noto Sans Bold)"
    )
    parser.add_argument(
        "--noto-music-font",
        default="tools/fontgen/sources/NotoMusic.ttf",
        help="Path to Noto Music font for SMuFL symbols (default: tools/fontgen/sources/NotoMusic.ttf)"
    )
    parser.add_argument(
        "--bravura-font",
        default="tools/fontgen/base_fonts/Bravura.otf",
        help="Path to Bravura font for fallback SMuFL symbols (default: tools/fontgen/base_fonts/Bravura.otf)"
    )
    parser.add_argument(
        "--atoms",
        default="tools/fontgen/atoms.yaml",
        help="Path to atoms.yaml (default: tools/fontgen/atoms.yaml)"
    )
    parser.add_argument(
        "--fontspec",
        default="tools/fontgen/fontspec.json",
        help="Path to fontspec.json (default: tools/fontgen/fontspec.json)"
    )
    parser.add_argument(
        "--output-dir",
        default="dist/fonts",
        help="Output directory (default: dist/fonts)"
    )
    parser.add_argument(
        "--strict",
        action="store_true",
        help="Fail on any errors (requires Noto Music)"
    )
    parser.add_argument(
        "--validate-only",
        action="store_true",
        help="Validate YAML only (no FontForge needed)"
    )
    parser.add_argument(
        "--debug-html",
        action="store_true",
        help="Generate debug specimen HTML"
    )
    parser.add_argument(
        "--system",
        choices=["number", "western", "sargam", "doremi", "all"],
        default="all",
        help="Generate font for specific notation system (default: all)"
    )

    args = parser.parse_args()

    # Always generate a single font containing all systems
    generate_font_for_system(args)


def generate_font_for_system(args):
    """Generate font for a specific system"""

    # Resolve paths from repo root
    script_dir = os.path.dirname(os.path.abspath(__file__))
    repo_root = os.path.dirname(os.path.dirname(script_dir))  # tools/fontgen -> editor

    atoms_path = os.path.join(repo_root, args.atoms)
    fontspec_path = os.path.join(repo_root, args.fontspec)
    base_font_path = os.path.join(repo_root, args.base_font)
    bold_font_path = os.path.join(repo_root, args.bold_font)
    noto_music_path = os.path.join(repo_root, args.noto_music_font)
    bravura_path = os.path.join(repo_root, args.bravura_font)
    output_dir = os.path.join(repo_root, args.output_dir)

    # Always generate single unified font
    font_basename = "NotationFont"

    output_font = os.path.join(output_dir, f"{font_basename}.ttf")
    output_mapping = os.path.join(output_dir, f"{font_basename}-map.json")
    output_html = os.path.join(output_dir, f"debug-specimen.html")

    print("=" * 70)
    print("NOTATION FONT GENERATOR (Noto Sans + Noto Music + Bravura)")
    print("=" * 70)
    print(f"\nConfiguration:")
    print(f"  fontspec.json:      {fontspec_path}")
    print(f"  atoms.yaml:         {atoms_path}")
    print(f"  base font (Noto Sans): {base_font_path}")
    print(f"  bold font (Noto Sans Bold): {bold_font_path}")
    print(f"  music symbols (Noto Music):  {noto_music_path}")
    print(f"  fallback symbols (Bravura):  {bravura_path}")
    print(f"  output dir:         {output_dir}")
    print(f"  mode:               {'STRICT' if args.strict else 'DEV'}")
    print()

    # Stage 0: Load fontspec (from file or fallback to atoms.yaml)
    try:
        fontspec = load_fontspec_json(fontspec_path, atoms_path)
    except Exception as e:
        print(f"\nERROR: Failed to load fontspec: {e}")
        sys.exit(1)

    # Stage 1: Load atom spec
    try:
        spec = load_atom_spec(atoms_path, fontspec, args.system)
    except Exception as e:
        print(f"\nERROR: Failed to load atoms.yaml: {e}")
        sys.exit(1)

    # Stage 2: Assign codepoints
    try:
        layout = assign_codepoints(spec)
    except Exception as e:
        print(f"\nERROR: Codepoint assignment failed: {e}")
        sys.exit(1)

    # Stage 5: Validate
    try:
        validate_layout(layout)
    except Exception as e:
        print(f"\nERROR: Layout validation failed: {e}")
        sys.exit(1)

    # Early exit for validate-only
    if args.validate_only:
        print("\n" + "=" * 70)
        print("VALIDATION PASSED (no font generated)")
        print("=" * 70)
        return 0

    # Stage 4: Build mapping JSON
    try:
        mapping = build_mapping_json(spec, layout)
    except Exception as e:
        print(f"\nERROR: JSON mapping failed: {e}")
        sys.exit(1)

    # Stage 3: Build font (requires FontForge)
    if not fontforge:
        print("\nERROR: FontForge not available")
        print("Install with: pip install fontforge")
        sys.exit(1)

    try:
        os.makedirs(output_dir, exist_ok=True)
        font = build_font(base_font_path, bold_font_path, noto_music_path, spec, layout, args.strict, bravura_path)
        font.generate(output_font)
        print(f"\n  ✓ Font saved: {output_font}")

        # Generate WOFF2 for web optimization
        output_woff2 = output_font.replace('.ttf', '.woff2')
        import subprocess
        try:
            subprocess.run(['woff2_compress', output_font], check=True, capture_output=True)
            print(f"  ✓ WOFF2 saved: {output_woff2}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"  ⚠ WOFF2 generation skipped (woff2_compress not available)")
    except Exception as e:
        print(f"\nERROR: Font generation failed: {e}")
        sys.exit(1)

    # Write JSON mapping
    try:
        with open(output_mapping, 'w') as f:
            json.dump(mapping, f, indent=2)
        print(f"  ✓ JSON mapping saved: {output_mapping}")
    except Exception as e:
        print(f"\nERROR: Failed to write JSON mapping: {e}")
        sys.exit(1)

    # Write debug HTML
    if args.debug_html:
        try:
            write_debug_html(output_html, spec, layout)
        except Exception as e:
            print(f"\nWARNING: Failed to write debug HTML: {e}")

    print("\n" + "=" * 70)
    print("SUCCESS!")
    print("=" * 70)
    print(f"\nGenerated unified font containing all systems (Number, Western, Sargam, Doremi):")
    print(f"  ✓ {output_font}")
    output_woff2 = output_font.replace('.ttf', '.woff2')
    if os.path.exists(output_woff2):
        print(f"  ✓ {output_woff2}")
    print(f"  ✓ {output_mapping}")
    if args.debug_html:
        print(f"  ✓ {output_html}")

    # Copy to static/fonts for development server
    static_fonts_dir = os.path.join(repo_root, "static", "fonts")
    if os.path.exists(static_fonts_dir):
        import shutil
        static_ttf = os.path.join(static_fonts_dir, f"{font_basename}.ttf")
        static_woff2 = os.path.join(static_fonts_dir, f"{font_basename}.woff2")
        static_json = os.path.join(static_fonts_dir, f"{font_basename}-map.json")

        shutil.copy(output_font, static_ttf)
        print(f"\n  ✓ Copied to static: {static_ttf}")

        if os.path.exists(output_woff2):
            shutil.copy(output_woff2, static_woff2)
            print(f"  ✓ Copied to static: {static_woff2}")

        shutil.copy(output_mapping, static_json)
        print(f"  ✓ Copied to static: {static_json}")

    print(f"\nNext steps:")
    print(f"  1. Hard refresh browser (Ctrl+Shift+R) to reload font")
    print(f"  2. Verify font renders correctly in Text tab")
    print(f"  3. Check all notation systems work correctly")

    return 0


if __name__ == "__main__":
    sys.exit(main())
