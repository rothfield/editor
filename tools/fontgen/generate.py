#!/usr/bin/env python3
"""
Notation Font Generator - Noto Music-based

This is the authoritative font generation tool. It reads from:
  1. fontspec.json (generated by Rust build.rs) - notation systems & PUA allocation
  2. atoms.yaml - geometry, symbols, accidental composites

Outputs:
  1. NotationFont.ttf - Noto Music base + custom octave variants (dots above/below)
  2. NotationFont-map.json - JSON mapping for runtime lookup

Architecture:
  Stage 0: load_fontspec_json() - Load notation systems from fontspec.json (Rust source of truth)
  Stage 1: load_atom_spec() - Parse atoms.yaml for geometry/symbols/accidentals
  Stage 2: assign_codepoints() - Allocate codepoints for custom variants
  Stage 3: build_font() - Open Noto Music, add custom note variants
  Stage 4: build_mapping_json() - Generate runtime mapping
  Stage 5: validate_layout() - Sanity checks

Usage:
  python3 generate.py [--noto-music-font PATH] [--output-dir PATH]
  python3 generate.py --validate-only  (no FontForge needed)
  python3 generate.py --debug-html      (visual specimen)
  python3 generate.py --strict          (fail on errors)
"""

import sys
import os
import json
import argparse
from pathlib import Path
from dataclasses import dataclass, asdict

try:
    import yaml
except ImportError:
    print("ERROR: PyYAML not found.")
    print("Install with: pip install PyYAML")
    sys.exit(1)

# Try to import fontforge (optional for --validate-only)
fontforge = None
try:
    import fontforge
except ImportError:
    pass


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class Geometry:
    """Positioning parameters for dots and symbols"""
    dot_above_gap: int
    dot_below_gap: int
    dot_vertical_step: int
    dot_horizontal_center: bool
    accidental_scale: float
    accidental_x_offset: int
    accidental_y_offset: int
    barline_scale: float
    ornament_scale: float


@dataclass
class SMuFLSymbol:
    """A symbol from SMuFL standard (Noto Music or Bravura)"""
    glyph_name: str
    label: str
    smufl_codepoint: int
    codepoint_offset: int
    source_font: str = "noto_music"  # "noto_music" or "bravura"
    assigned_codepoint: int = None  # Assigned during allocation


@dataclass
class NoteAtom:
    """A note (base character + variant)"""
    system: str
    character: str
    variant_index: int  # 0=+1dot, 1=+2dots, 2=-1dot, 3=-2dots
    assigned_codepoint: int = None  # Assigned during allocation


@dataclass
class AtomSpec:
    """Complete notation specification"""
    notation_systems: dict  # system_name -> list of characters
    smufl_symbols: list  # List of SMuFLSymbol
    geometry: Geometry
    character_order: str
    pua_start: int = 0xE600  # PUA start codepoint from atoms.yaml
    accidental_composites: dict = None  # Accidental composite configuration from atoms.yaml


@dataclass
class CodepointLayout:
    """Result of codepoint allocation"""
    note_atoms: list  # List of NoteAtom with assigned_codepoint set
    symbols: list  # List of BravuraSymbol with assigned_codepoint set
    notes_range: tuple  # (start, end) codepoint
    symbols_range: tuple  # (start, end) codepoint


# ============================================================================
# Stage 0: Load FontSpec JSON (from Rust build.rs)
# ============================================================================

def load_fontspec_json(json_path: str) -> dict:
    """
    Load fontspec.json generated by Rust build.rs.

    This is the canonical source for:
    - Notation systems (names, characters, PUA base)
    - Glyph variant configuration (accidental_types, octave_variants)

    Returns:
        dict with 'notation_systems' and 'glyph_variants' keys

    Raises:
        FileNotFoundError if file doesn't exist
        ValueError if JSON structure is invalid
    """
    print(f"[STAGE 0] Loading fontspec from Rust: {json_path}")

    if not os.path.exists(json_path):
        raise FileNotFoundError(f"fontspec.json not found: {json_path}")

    with open(json_path, 'r') as f:
        fontspec = json.load(f)

    # Validate structure
    if 'notation_systems' not in fontspec:
        raise ValueError("fontspec.json missing 'notation_systems'")
    if 'glyph_variants' not in fontspec:
        raise ValueError("fontspec.json missing 'glyph_variants'")

    # Log systems
    for system in fontspec['notation_systems']:
        chars = ''.join(system['characters'])
        print(f"  âœ“ {system['name']}: {len(system['characters'])} characters, "
              f"PUA {hex(system['pua_base'])}")

    gv = fontspec['glyph_variants']
    print(f"  âœ“ Glyph variants: {gv['accidental_types']} accidentals Ã— "
          f"{gv['octave_variants']} octaves = "
          f"{gv['accidental_types'] * gv['octave_variants']} variants/char")

    return fontspec


# ============================================================================
# Stage 1: Load Atom Specification
# ============================================================================

def load_atom_spec(yaml_path: str, fontspec: dict, selected_system: str = "all") -> AtomSpec:
    """
    Parse atoms.yaml and validate structure.

    Args:
        yaml_path: Path to atoms.yaml
        fontspec: Loaded fontspec.json data
        selected_system: Notation system to generate ("number", "western", "sargam", "doremi", or "all")

    Returns:
        AtomSpec with notation systems, symbols, and geometry

    Raises:
        ValueError if validation fails
    """
    print(f"[STAGE 1] Loading atom specification: {yaml_path}")
    if selected_system != "all":
        print(f"  â†’ Filtering for system: {selected_system}")

    if not os.path.exists(yaml_path):
        raise FileNotFoundError(f"atoms.yaml not found: {yaml_path}")

    with open(yaml_path, 'r') as f:
        config = yaml.safe_load(f)

    # Extract notation systems AND PUA bases from fontspec (Rust source of truth)
    notation_systems = {}
    notation_system_pua_blocks = {}  # Store PUA bases from fontspec
    for system in fontspec['notation_systems']:
        system_name = system['name']

        # Filter by selected system if not "all"
        if selected_system != "all" and system_name != selected_system:
            continue

        characters = system['characters']
        pua_base = system.get('pua_base')  # Extract pua_base
        notation_systems[system_name] = characters
        if pua_base is not None:
            notation_system_pua_blocks[system_name] = pua_base
        # Characters are already loaded from fontspec, no need to print again

    # Reconstruct expected character order from notation systems
    character_order = ''.join(
        ''.join(chars) for chars in notation_systems.values()
    )
    if selected_system == "all":
        print(f"  âœ“ Notation systems loaded from fontspec.json")
    else:
        print(f"  âœ“ Notation system loaded: {selected_system} ({len(notation_systems[selected_system])} characters)")

    # Extract geometry
    geometry_config = config.get('geometry', {})
    geometry = Geometry(
        dot_above_gap=geometry_config.get('dots', {}).get('above_gap', 50),
        dot_below_gap=geometry_config.get('dots', {}).get('below_gap', 50),
        dot_vertical_step=geometry_config.get('dots', {}).get('vertical_step', 100),
        dot_horizontal_center=geometry_config.get('dots', {}).get('horizontal_center', True),
        accidental_scale=geometry_config.get('symbols', {}).get('accidental_scale', 1.0),
        accidental_x_offset=geometry_config.get('symbols', {}).get('accidental_x_offset', 0),
        accidental_y_offset=geometry_config.get('symbols', {}).get('accidental_y_offset', 0),
        barline_scale=geometry_config.get('symbols', {}).get('barline_scale', 1.0),
        ornament_scale=geometry_config.get('symbols', {}).get('ornament_scale', 1.0),
    )
    print(f"  âœ“ Geometry loaded: dot_above_gap={geometry.dot_above_gap}, "
          f"dot_vertical_step={geometry.dot_vertical_step}")

    # Extract SMuFL symbols from Noto Music or Bravura
    smufl_symbols = []
    for symbol_def in config.get('smufl_symbols', []):
        smufl_symbols.append(SMuFLSymbol(
            glyph_name=symbol_def['glyph_name'],
            label=symbol_def['label'],
            smufl_codepoint=symbol_def.get('smufl_codepoint', 0),
            codepoint_offset=symbol_def.get('codepoint_offset', 0),
            source_font=symbol_def.get('source_font', 'noto_music'),  # default to noto_music
        ))

    print(f"  âœ“ SMuFL symbols: {len(smufl_symbols)}")

    # Extract PUA configuration (supports both old single-block and new per-system)
    pua_config = config.get('pua', {})
    pua_start = pua_config.get('start', 0xE600)
    print(f"  âœ“ PUA start (fallback): {hex(pua_start)}")

    # Extract per-system PUA blocks (NEW architecture)
    # Merge atoms.yaml PUA blocks with fontspec (fontspec takes precedence)
    atoms_pua_blocks = config.get('notation_system_pua_blocks', {})
    if atoms_pua_blocks:
        # Merge atoms.yaml into fontspec blocks (fontspec wins on conflicts)
        for sys_name, sys_config in atoms_pua_blocks.items():
            if sys_name not in notation_system_pua_blocks:
                notation_system_pua_blocks[sys_name] = sys_config
    if notation_system_pua_blocks:
        print(f"  âœ“ Per-system PUA blocks detected:")
        for sys_name, sys_config in notation_system_pua_blocks.items():
            if isinstance(sys_config, dict) and 'base' in sys_config:
                print(f"    - {sys_name}: {hex(sys_config['base'])} ({sys_config.get('chars', '?')} chars)")

    # Extract accidental composites configuration
    accidental_composites = config.get('accidental_composites', {})
    if accidental_composites:
        print(f"  âœ“ Accidental composites configuration loaded")

    # Extract glyph variants configuration (NEW layout: 25 variants per character)
    glyph_variants = config.get('glyph_variants', {})
    variants_per_char = glyph_variants.get('count_per_character', 25)  # Default: 25
    if glyph_variants:
        print(f"  âœ“ Glyph variants configuration loaded ({variants_per_char} variants per character)")

    spec = AtomSpec(
        notation_systems=notation_systems,
        smufl_symbols=smufl_symbols,
        geometry=geometry,
        character_order=character_order,
        pua_start=pua_start,
        accidental_composites=accidental_composites,
    )

    # Attach per-system PUA blocks to spec for use in assign_codepoints()
    spec.pua_blocks = notation_system_pua_blocks  # type: ignore
    spec.glyph_variants = glyph_variants  # type: ignore

    return spec


# ============================================================================
# Stage 2: Assign Codepoints
# ============================================================================

def assign_codepoints(spec: AtomSpec) -> CodepointLayout:
    """
    Assign PUA codepoints using per-system architecture.

    Algorithm (NEW - Per-system blocks, group-by-accidental-then-octave, 25 variants):
        1. Read notation_system_pua_blocks from atoms.yaml
        2. For each system, use formula: codepoint = system_base + (accidental_block Ã— N) + (octave_group Ã— N) + char_index
           Where N = number of characters in system (7, 14, 12, 14 for Number, Western, Sargam, Doremi)
        3. Octave order: [0, -2, -1, +1, +2] (MUST match build.rs octave_index mapping)
        4. Accidental order: [natural, flat, double-flat, sharp, double-sharp]
        5. Each character gets 25 codepoints: 5 accidental types Ã— 5 octave variants
        6. Assign symbol codepoints at SMuFL standard codepoints
        7. Return layout with all assignments

    Returns:
        CodepointLayout with all atoms assigned
    """
    print(f"\n[STAGE 2] Assigning PUA codepoints (per-system architecture)")

    note_atoms = []
    all_codepoints_used = []

    # Extract per-system PUA blocks from atoms.yaml
    pua_blocks = {}
    if hasattr(spec, 'pua_blocks'):
        pua_blocks = spec.pua_blocks  # type: ignore

    # Process notation systems in order they appear in atoms.yaml
    for system_name, characters in spec.notation_systems.items():
        # Get PUA base for this system
        # atoms.yaml uses keys like 'number_system', but notation_systems uses 'number'
        system_key_variants = [
            system_name,  # Try 'number' first
            f"{system_name}_system",  # Try 'number_system'
        ]

        system_pua_base = None
        system_pua_config = None

        # Try each variant of the system key
        for key_variant in system_key_variants:
            if key_variant in pua_blocks:
                system_pua_config = pua_blocks[key_variant]
                break

        if system_pua_config:
            if isinstance(system_pua_config, dict) and 'base' in system_pua_config:
                system_pua_base = system_pua_config['base']
            elif isinstance(system_pua_config, int):
                system_pua_base = system_pua_config

        # Fallback: use old sequential architecture if no per-system config found
        if system_pua_base is None:
            print(f"  âš  {system_name}: No per-system PUA base found, falling back to sequential")
            system_pua_base = spec.pua_start

        print(f"  Processing {system_name}: PUA base = {hex(system_pua_base)}, {len(characters)} characters")

        num_chars = len(characters)

        # NEW LAYOUT: Group-by-accidental-then-octave (25-variant system)
        # For N characters with 5 accidentals Ã— 5 octave variants:
        # - Naturals (5 octaves): 5N codepoints (0 to 5N-1)
        # - Flats (5 octaves): 5N codepoints (5N to 10N-1)
        # - Double-flats (5 octaves): 5N codepoints (10N to 15N-1)
        # - Sharps (5 octaves): 5N codepoints (15N to 20N-1)
        # - Double-sharps (5 octaves): 5N codepoints (20N to 25N-1)

        # Octave order: 0, -2, -1, +1, +2 (MUST match build.rs octave_idx mapping)
        octave_order = [0, -2, -1, 1, 2]

        # Allocate glyphs for each accidental block
        # CRITICAL: Order MUST match build.rs accidental_offset mapping (lines 434-442 in build.rs)
        # build.rs mapping:
        #   0 => 0 * 5N (Natural)
        #   1 => 1 * 5N (Flat at 5N)
        #   2 => 2 * 5N (Half-flat at 10N)
        #   3 => 3 * 5N (Double-flat at 15N)
        #   4 => 5 * 5N (Double-sharp at 25N)
        #   5 => 4 * 5N (Sharp at 20N)
        acc_blocks = [
            ('natural', 0),       # acc_type_idx 0 â†’ variants 0-4
            ('flat', 1),          # acc_type_idx 1 â†’ variants 5-9
            ('halfflat', 2),      # acc_type_idx 2 â†’ variants 10-14
            ('doubleflat', 3),    # acc_type_idx 3 â†’ variants 15-19
            ('doublesharp', 4),   # acc_type_idx 4 â†’ variants 20-24 (FIXED: was after sharp)
            ('sharp', 5),         # acc_type_idx 5 â†’ variants 25-29 (FIXED: was before doublesharp)
        ]

        for acc_type_idx, (acc_name, block_num) in enumerate(acc_blocks):
            for octave_idx, octave in enumerate(octave_order):
                for char_index, char_entry in enumerate(characters):
                    char = char_entry.get("char", str(char_index)) if isinstance(char_entry, dict) else char_entry

                    # NEW ARCHITECTURE: 30 variants per character
                    # Formula: pua_base + (char_idx Ã— 30) + variant_index
                    # MUST match build.rs formula exactly!
                    variant_index = (acc_type_idx * 5) + octave_idx
                    codepoint = system_pua_base + (char_index * 30) + variant_index

                    # Create atoms for 30 variants (6 accidentals Ã— 5 octaves)
                    # variant_index encodes: (accidental_type Ã— 5) + octave_idx

                    atom = NoteAtom(
                        system=system_name,
                        character=char,
                        variant_index=variant_index,  # 0-24: encodes accidental + octave
                        assigned_codepoint=codepoint
                    )
                    note_atoms.append(atom)

                    all_codepoints_used.append(codepoint)

    notes_start = min(all_codepoints_used) if all_codepoints_used else spec.pua_start
    notes_end = max(all_codepoints_used) if all_codepoints_used else spec.pua_start
    notes_range = (notes_start, notes_end)

    print(f"  âœ“ Assigned {len(note_atoms)} note atoms: {hex(notes_start)} - {hex(notes_end)}")

    # Assign symbol codepoints - use SMuFL standard codepoints directly (NOT sequential PUA)
    # SMuFL symbols use their official codepoints from W3C SMuFL specification
    # This ensures barlines render at U+E030, U+E031, U+E040, U+E041, etc.
    symbols_assigned = 0
    for symbol in spec.smufl_symbols:
        # Use the standard SMuFL codepoint directly (from W3C SMuFL spec)
        symbol.assigned_codepoint = symbol.smufl_codepoint
        symbols_assigned += 1

    # Find range for informational purposes only
    if spec.smufl_symbols:
        symbol_cps = [s.smufl_codepoint for s in spec.smufl_symbols]
        symbols_start = min(symbol_cps)
        symbols_end = max(symbol_cps)
        symbols_range = (symbols_start, symbols_end)
    else:
        symbols_range = (None, None)

    print(f"  âœ“ Assigned {len(spec.smufl_symbols)} SMuFL symbols at standard codepoints: {hex(symbols_start) if symbols_start else 'none'} - {hex(symbols_end) if symbols_end else 'none'}")

    # Check for PUA overflow
    max_codepoint = max(all_codepoints_used) if all_codepoints_used else 0xE000
    if max_codepoint > 0xF8FF:
        raise OverflowError(
            f"PUA overflow! Used {max_codepoint - 0xE000} codepoints, max is {0xF8FF - 0xE000}"
        )

    return CodepointLayout(
        note_atoms=note_atoms,
        symbols=spec.smufl_symbols,
        notes_range=notes_range,
        symbols_range=symbols_range,
    )


# ============================================================================
# Helper: Create Accidental Composites
# ============================================================================

def create_accidental_composites(
    font: 'fontforge.font',
    spec: AtomSpec,
    layout: CodepointLayout,
    bold_font: 'fontforge.font' = None,
    pitch_chars: set = None
):
    """
    Create pre-composed accidental glyphs by combining base characters with accidental symbols.

    Algorithm:
        1. Get all 47 base characters from character_order string (preserves duplicates across systems)
        2. Extract accidental symbol glyphs from font (imported from Noto Music)
        3. For each character + accidental type, create composite glyph at allocated PUA codepoint
        4. Position accidental symbol to the right of base character
        5. Use bold font for pitch characters if available

    Accidental Symbol Codepoints (Unicode Musical Symbols from Noto Music):
        - Flat (â™­): U+1D12D (Musical Symbol Flat)
        - Sharp (â™¯): U+1D130 (Musical Symbol Sharp Up)
        - Double-sharp (ð„ª): U+1D12A (Musical Symbol Double Sharp)
        - Double-flat (ð„«): U+1D12B (Musical Symbol Double Flat)

    PUA Allocations (Private Use Area for composite glyphs):
        - Sharp composites: 0xE1F0-0xE21E (47 glyphs, base + â™¯)
        - Flat composites: 0xE220-0xE24E (47 glyphs, base + â™­)
        - Double-sharp composites: 0xE250-0xE27E (47 glyphs, base + ð„ª)
        - Double-flat composites: 0xE280-0xE2AE (47 glyphs, base + ð„«)

    Args:
        font: FontForge font object with base characters and musical symbols from Noto Music
        spec: AtomSpec with notation systems and accidental configuration
        layout: CodepointLayout (unused but passed for compatibility)
        bold_font: Optional bold font for pitch characters
        pitch_chars: Optional set of pitch characters that should use bold font
    """
    # Get all 47 base characters from character_order string
    # This preserves the allocation order and includes characters that appear in multiple systems
    all_chars = list(spec.character_order)

    if len(all_chars) != 47:
        print(f"    WARNING: Expected 47 characters, got {len(all_chars)}")

    # Load accidental symbol codepoints from atoms.yaml configuration
    # These reference the proper Unicode musical symbols (U+1D12F sharp, U+1D12D flat, etc.)
    accidental_types = spec.accidental_composites.get('types', {})

    ACCIDENTAL_SYMBOLS = {}
    ACCIDENTAL_RANGES = {}

    for acc_name, acc_config in accidental_types.items():
        smufl_code = acc_config.get('smufl_symbol')
        if smufl_code:
            ACCIDENTAL_SYMBOLS[acc_name] = smufl_code
        else:
            ACCIDENTAL_SYMBOLS[acc_name] = None  # Will use paired glyphs

        # Parse range string "0xE1F0 - 0xE21E"
        range_str = acc_config.get('range', '')
        if range_str and '-' in range_str:
            parts = range_str.split('-')
            start = int(parts[0].strip(), 16)
            end = int(parts[1].strip(), 16)
            ACCIDENTAL_RANGES[acc_name] = (start, end)

    # Get accidental symbol glyphs from font (imported from Noto Music)
    accidental_glyphs = {}
    print(f"    Loading accidental symbols from font...")

    for accidental_type, char_code in ACCIDENTAL_SYMBOLS.items():
        if char_code is None:
            print(f"    WARNING: No codepoint specified for {accidental_type}")
            accidental_glyphs[accidental_type] = None
            continue

        try:
            glyph = font[char_code]
            if glyph and glyph.glyphname:
                accidental_glyphs[accidental_type] = glyph
                print(f"    âœ“ Found {accidental_type} at U+{char_code:04X} (glyphname: {glyph.glyphname})")
            else:
                print(f"    WARNING: Glyph not found at U+{char_code:04X}")
                accidental_glyphs[accidental_type] = None
        except Exception as e:
            print(f"    WARNING: Could not access U+{char_code:04X}: {e}")
            accidental_glyphs[accidental_type] = None

    # Sargam notes that should NOT get accidentals (case indicates komal/tivra)
    # r = komal Re (not Râ™­), g = komal Ga (not Gâ™­), m = komal ma (not Mâ™­â™­), d = komal Dha (not Dâ™­), n = komal Ni (not Nâ™­)
    # M = tivra Ma (not m#)
    # In Sargam, the case itself IS the pitch - these are not accidental modifications
    SARGAM_NO_ACCIDENTALS = {'r', 'g', 'm', 'd', 'n', 'M'}

    # Create composites for each accidental type
    composites_created = 0
    for accidental_type, (pua_start, pua_end) in ACCIDENTAL_RANGES.items():
        # Get the symbol glyph for this accidental type
        accidental_glyph = accidental_glyphs.get(accidental_type)
        if not accidental_glyph:
            print(f"    Skipping {accidental_type} composites (symbol not found)")
            continue

        accidental_bbox = accidental_glyph.boundingBox()
        if not accidental_bbox:
            print(f"    WARNING: No bounding box for accidental {accidental_type}")
            continue

        acc_min_x, acc_min_y, acc_max_x, acc_max_y = accidental_bbox
        acc_width = acc_max_x - acc_min_x

        # Check if this accidental type needs slash drawing (half-flat, half-sharp)
        acc_config = accidental_types.get(accidental_type, {})
        draw_slash = acc_config.get('draw_slash', False)

        # Create composite for each character
        for i, base_char in enumerate(all_chars):
            # SKIP: Sargam komal/tivra notes should NOT get accidentals
            if base_char in SARGAM_NO_ACCIDENTALS:
                continue
            # Choose source font: bold for pitch characters, regular for everything else
            is_pitch = pitch_chars and base_char in pitch_chars
            source_font = bold_font if (is_pitch and bold_font) else font

            try:
                base_glyph = source_font[ord(base_char)]
            except:
                font_type = "bold" if is_pitch else "regular"
                print(f"    ERROR: Base character '{base_char}' not found in {font_type} font")
                continue

            if not base_glyph:
                continue

            base_bbox = base_glyph.boundingBox()
            if not base_bbox:
                continue

            base_min_x, base_min_y, base_max_x, base_max_y = base_bbox
            base_width = base_glyph.width  # Use advance width, not bounding box width

            # Composite codepoint: sequential in allocated range
            composite_cp = pua_start + i

            # Create composite glyph
            try:
                composite = font.createChar(composite_cp, f"{base_char}_{accidental_type}")
                composite.clear()

                # Reference base character instead of copying outlines
                composite.addReference(base_glyph.glyphname)

                # Position accidental symbol to the right of base character
                # x_offset: Align ink edges by accounting for accidental's left bearing
                #   base_max_x = right edge of base char ink
                #   acc_min_x = left bearing of accidental (distance from origin to ink start)
                #   Subtract acc_min_x to align origins, then add configurable gap
                # y_offset: vertical center alignment
                x_offset = int(base_max_x - acc_min_x + spec.geometry.accidental_x_offset)
                y_offset = int((base_max_y + base_min_y - acc_max_y - acc_min_y) / 2 + spec.geometry.accidental_y_offset)

                # Scale accidental symbol if specified
                scale = spec.geometry.accidental_scale

                # Add single accidental symbol (sharp, flat, double-sharp, or double-flat)
                # FontForge requires integers for transformation matrix (except scale)
                composite.addReference(
                    accidental_glyph.glyphname,
                    (scale, 0, 0, scale, int(x_offset), int(y_offset))
                )

                # Draw slash for half-flat and half-sharp
                if draw_slash:
                    try:
                        import math

                        # Calculate scaled symbol dimensions for slash positioning
                        scaled_acc_min_x = acc_min_x * scale + x_offset
                        scaled_acc_max_x = acc_max_x * scale + x_offset
                        scaled_acc_min_y = acc_min_y * scale + y_offset
                        scaled_acc_max_y = acc_max_y * scale + y_offset

                        # Draw diagonal slash from upper-left to lower-right through the symbol
                        # Extend slash slightly beyond the symbol bounds for visibility
                        slash_extension = int((scaled_acc_max_x - scaled_acc_min_x) * 0.15)

                        # Start point (upper-left)
                        slash_start_x = scaled_acc_min_x - slash_extension
                        slash_start_y = scaled_acc_max_y + slash_extension

                        # End point (lower-right)
                        slash_end_x = scaled_acc_max_x + slash_extension
                        slash_end_y = scaled_acc_min_y - slash_extension

                        # Stroke weight based on symbol size
                        slash_width = scaled_acc_max_x - scaled_acc_min_x
                        stroke_weight = max(int(slash_width * 0.06), 25)  # 6% of width, min 25 units

                        # Draw slash as a filled rectangle (thin rotated stroke)
                        # Create a rectangular stroke along the diagonal
                        pen = composite.glyphPen()

                        # Perpendicular offset to create the stroke width
                        # For a 45-degree diagonal, perpendicular vector is at 45+90 degrees
                        half_weight = stroke_weight / 2
                        perp_dx = int(-half_weight / math.sqrt(2))  # perpendicular x
                        perp_dy = int(half_weight / math.sqrt(2))   # perpendicular y

                        # Draw four corners of the stroke rectangle
                        p1_x = int(slash_start_x + perp_dx)
                        p1_y = int(slash_start_y + perp_dy)
                        p2_x = int(slash_start_x - perp_dx)
                        p2_y = int(slash_start_y - perp_dy)
                        p3_x = int(slash_end_x - perp_dx)
                        p3_y = int(slash_end_y - perp_dy)
                        p4_x = int(slash_end_x + perp_dx)
                        p4_y = int(slash_end_y + perp_dy)

                        # Draw filled rectangle for the slash stroke
                        pen.moveTo((p1_x, p1_y))
                        pen.lineTo((p2_x, p2_y))
                        pen.lineTo((p3_x, p3_y))
                        pen.lineTo((p4_x, p4_y))
                        pen.closePath()

                        # Mark contour as filled (clockwise winding)
                        print(f"    âœ“ Drew slash for {accidental_type} composite")

                    except Exception as slash_err:
                        # If slash drawing fails, continue anyway - the symbol is still there
                        print(f"    WARNING: Could not draw slash for {accidental_type}: {slash_err}")

                # Set width to include both base character AND accidental symbol
                # Total width = position of accidental + width of accidental
                acc_width_scaled = int((acc_max_x - acc_min_x) * scale)
                composite.width = int(x_offset + acc_width_scaled)

                # Correct direction and calculate proper sidebearings
                # This ensures the "after" (right sidebearing) is set correctly
                composite.correctDirection()

                # Round to grid for consistent metrics
                composite.round()

                composites_created += 1

            except Exception as e:
                print(f"    ERROR creating {accidental_type} composite for '{base_char}': {e}")
                continue

    print(f"  âœ“ Created {composites_created} accidental composite glyphs")


# ============================================================================
# Helper: Create Combined Accidental + Octave Composites
# ============================================================================

def create_accidental_octave_composites(font: 'fontforge.font', spec: AtomSpec, layout: CodepointLayout):
    """
    Create triple-composite glyphs combining base character + accidental + octave dots.

    For example: "1# with octave +1" (1 sharp with dot above)

    Code point allocation (752 glyphs total):
    - Sharp + octave:        0xE2B0 - 0xE36F (188 glyphs: 47 chars Ã— 4 octave variants)
    - Flat + octave:         0xE370 - 0xE42F (188 glyphs: 47 chars Ã— 4 octave variants)
    - Double-sharp + octave: 0xE430 - 0xE4EF (188 glyphs: 47 chars Ã— 4 octave variants)
    - Double-flat + octave:  0xE4F0 - 0xE5AF (188 glyphs: 47 chars Ã— 4 octave variants)

    Algorithm:
        1. For each accidental type (sharp, flat, double-sharp, double-flat)
        2. For each of the 47 base characters
        3. For each of the 4 octave variants (1 dot above, 2 dots above, 1 dot below, 2 dots below)
        4. Create composite glyph = base char + accidental symbol + octave dot(s)

    Args:
        font: FontForge font object
        spec: AtomSpec with notation systems and configuration
        layout: CodepointLayout with allocated ranges
    """
    all_chars = spec.character_order

    # Load accidental symbol codepoints
    accidental_types = spec.accidental_composites.get('types', {})

    # Define PUA ranges for combined glyphs
    COMBINED_RANGES = {
        'sharp': (0xE2B0, 0xE36F),
        'flat': (0xE370, 0xE42F),
        'double_sharp': (0xE430, 0xE4EF),
        'double_flat': (0xE4F0, 0xE5AF),
    }

    # Get accidental symbol glyphs from font
    accidental_glyphs = {}
    for acc_name, acc_config in accidental_types.items():
        smufl_code = acc_config.get('smufl_symbol')
        if smufl_code:
            try:
                glyph = font[smufl_code]
                if glyph:
                    accidental_glyphs[acc_name] = glyph
            except:
                accidental_glyphs[acc_name] = None
        else:
            accidental_glyphs[acc_name] = None

    # Get dot glyph (created earlier in build_font)
    try:
        dot_codepoint = ord('.')
        dot_glyph = font[dot_codepoint]
        if not dot_glyph:
            print("    ERROR: Dot glyph not found - cannot create combined accidental+octave glyphs")
            return
        dot_bbox = dot_glyph.boundingBox()
        if not dot_bbox:
            print("    ERROR: Dot glyph has no bounding box - cannot create combined accidental+octave glyphs")
            return
        dx_min, dy_min, dx_max, dy_max = dot_bbox
        dot_width = dx_max - dx_min
        dot_height = dy_max - dy_min
        dot_name = dot_glyph.glyphname
    except Exception as e:
        print(f"    ERROR: Failed to get dot glyph: {e}")
        return

    composites_created = 0
    for acc_type, (pua_start, pua_end) in COMBINED_RANGES.items():
        accidental_glyph = accidental_glyphs.get(acc_type)
        if not accidental_glyph:
            print(f"    Skipping {acc_type}+octave composites (symbol not found)")
            continue

        acc_bbox = accidental_glyph.boundingBox()
        if not acc_bbox:
            print(f"    WARNING: No bounding box for accidental {acc_type}")
            continue

        acc_min_x, acc_min_y, acc_max_x, acc_max_y = acc_bbox

        # Create composite for each character Ã— octave variant
        for char_idx, base_char in enumerate(all_chars):
            try:
                base_glyph = font[ord(base_char)]
            except:
                print(f"    ERROR: Base character '{base_char}' not found in font")
                continue

            if not base_glyph:
                continue

            base_bbox = base_glyph.boundingBox()
            if not base_bbox:
                continue

            bx_min, by_min, bx_max, by_max = base_bbox
            base_width = bx_max - bx_min

            # Calculate accidental position (same as in create_accidental_composites)
            acc_x_offset = int(bx_max - acc_min_x + spec.geometry.accidental_x_offset)
            acc_y_offset = int((by_max + by_min - acc_max_y - acc_min_y) / 2 + spec.geometry.accidental_y_offset)
            acc_scale = spec.geometry.accidental_scale

            # Calculate dot position (same as in octave variant creation)
            dot_x_offset = bx_min + (base_width - dot_width) / 2 - dx_min + (dot_width * 0.8)
            if base_char == "2":
                dot_x_offset -= base_width * 0.1
            if base_char in ["3", "5", "6"]:
                dot_x_offset -= base_width * 0.17
            if base_char == "4":
                dot_x_offset += base_width * 0.04
            if base_char == "7":
                dot_x_offset -= base_width * 0.04

            # Create 4 octave variants for this character+accidental
            double_dot_scale = 0.6
            double_dot_spacing = 2 * dot_height * double_dot_scale

            # Calculate 5% adjustment for dot positioning
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05

            variant_configs = [
                (0, "1_dot_above", 1),   # variant 0: +1 octave
                (1, "2_dots_above", 2),  # variant 1: +2 octaves
                (2, "1_dot_below", -1),  # variant 2: -1 octave
                (3, "2_dots_below", -2), # variant 3: -2 octaves
            ]

            for variant_index, variant_name, octave_shift in variant_configs:
                # Composite codepoint: pua_start + (char_index Ã— 4) + variant_index
                composite_cp = pua_start + (char_idx * 4) + variant_index

                try:
                    composite = font.createChar(composite_cp, f"{base_char}_{acc_type}_{variant_name}")
                    composite.clear()

                    # Add base character
                    composite.addReference(base_glyph.glyphname, (1, 0, 0, 1, 0, 0))

                    # Add accidental symbol
                    composite.addReference(
                        accidental_glyph.glyphname,
                        (acc_scale, 0, 0, acc_scale, int(acc_x_offset), int(acc_y_offset))
                    )

                    # Add octave dot(s)
                    if variant_index == 0:  # 1 dot above
                        y_pos = by_max - dy_min + spec.geometry.dot_above_gap + dot_adjustment
                        composite.addReference(dot_name, (1, 0, 0, 1, dot_x_offset, y_pos))

                    elif variant_index == 1:  # 2 dots above
                        y_pos1 = by_max - dy_min + spec.geometry.dot_above_gap + dot_adjustment
                        y_pos2 = y_pos1 + double_dot_spacing
                        composite.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos1))
                        composite.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos2))

                    elif variant_index == 2:  # 1 dot below
                        y_pos = by_min - dy_max - spec.geometry.dot_below_gap - dot_adjustment
                        composite.addReference(dot_name, (1, 0, 0, 1, dot_x_offset, y_pos))

                    elif variant_index == 3:  # 2 dots below
                        y_pos1 = by_min - dy_max - spec.geometry.dot_below_gap - dot_adjustment
                        y_pos2 = y_pos1 - double_dot_spacing
                        composite.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos1))
                        composite.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos2))

                    # Set width to include both base character AND accidental symbol
                    # Total width = position of accidental + width of accidental
                    acc_width_scaled = int((acc_max_x - acc_min_x) * acc_scale)
                    composite.width = int(acc_x_offset + acc_width_scaled)

                    # Correct direction and calculate proper sidebearings
                    composite.correctDirection()
                    composite.round()

                    composites_created += 1

                except Exception as e:
                    print(f"    ERROR creating {acc_type}+{variant_name} composite for '{base_char}': {e}")
                    continue

    print(f"  âœ“ Created {composites_created} combined accidental+octave composite glyphs")


# ============================================================================
# Stage 3: Build Font
# ============================================================================

def build_font(
    base_font_path: str,
    bold_font_path: str,
    noto_music_path: str,
    spec: AtomSpec,
    layout: CodepointLayout,
    strict_mode: bool = False,
    bravura_path: str = None
) -> 'fontforge.font':
    """
    Generate NotationFont: Noto Sans base + Noto Music symbols + custom octave variants.

    Steps:
        1. Load Noto Sans as base (has ASCII characters with professional typography)
        2. Load Noto Sans Bold for pitch characters
        3. Import SMuFL symbols from Noto Music
        4. Import missing SMuFL symbols from Bravura (fallback)
        5. Add a synthetic dot glyph for octave variants
        6. Create custom octave variants (dots above/below) - using bold for pitches
        7. Rename font to NotationFont
        8. Return the enhanced font

    Args:
        base_font_path: Path to Noto Sans Regular
        bold_font_path: Path to Noto Sans Bold for pitch characters
        strict_mode: If True, fail on errors
        bravura_path: Path to Bravura font for fallback symbols

    Returns:
        fontforge.font object
    """
    print(f"\n[STAGE 3] Building NotationFont (Noto Sans base + Noto Music symbols + custom variants)")

    if not fontforge:
        raise RuntimeError("FontForge module not available. Cannot build font.")

    # Load Noto Sans as the base font (has ASCII characters with professional typography)
    if not base_font_path or not os.path.exists(base_font_path):
        if strict_mode:
            raise FileNotFoundError(f"Base font not found: {base_font_path}")
        else:
            raise FileNotFoundError(f"Base font not found: {base_font_path}")

    print(f"  Loading base font (Noto Sans): {base_font_path}")
    try:
        font = fontforge.open(base_font_path)
        print(f"  âœ“ Base font loaded")
    except Exception as e:
        raise RuntimeError(f"Failed to load base font: {e}")

    # Correct direction and calculate proper sidebearings for ALL base glyphs
    # This fixes the "after" (right sidebearing) for characters like "1", "2", "3"
    print(f"  Correcting base glyphs (fixing sidebearings)...")
    corrected_count = 0
    for glyph in font.glyphs():
        if glyph.unicode > 0:  # Only process encoded glyphs
            try:
                glyph.correctDirection()
                glyph.round()
                corrected_count += 1
            except Exception as e:
                # Some glyphs might fail, that's okay
                pass
    print(f"  âœ“ Corrected {corrected_count} base glyphs")

    # Load Noto Sans Bold for pitch characters
    bold_font = None
    if bold_font_path and os.path.exists(bold_font_path):
        print(f"  Loading bold font (Noto Sans Bold): {bold_font_path}")
        try:
            bold_font = fontforge.open(bold_font_path)
            print(f"  âœ“ Bold font loaded")
            # Correct bold glyphs as well
            bold_corrected = 0
            for glyph in bold_font.glyphs():
                if glyph.unicode > 0:
                    try:
                        glyph.correctDirection()
                        glyph.round()
                        bold_corrected += 1
                    except:
                        pass
            print(f"  âœ“ Corrected {bold_corrected} bold glyphs")
        except Exception as e:
            if strict_mode:
                raise RuntimeError(f"Failed to load bold font: {e}")
            else:
                print(f"  WARNING: Could not load bold font: {e}")
                bold_font = None
    else:
        print(f"  WARNING: Bold font not found: {bold_font_path}")

    # Build set of pitch characters from all notation systems
    pitch_chars = set()
    for system_name, chars in spec.notation_systems.items():
        for char in chars:
            pitch_chars.add(char)
    print(f"  Pitch characters (will use bold): {sorted(pitch_chars)}")

    # Import SMuFL symbols from Noto Music
    noto_music_font = None
    if noto_music_path and os.path.exists(noto_music_path):
        print(f"  Loading Noto Music for SMuFL symbols: {noto_music_path}")
        try:
            noto_music_font = fontforge.open(noto_music_path)
            print(f"  âœ“ Noto Music loaded")
            # Import only the accidental symbols we need for composite glyphs
            # Standard Unicode accidentals (NOT quarter-tone variants):
            # - U+266D: Music Flat Sign (standard flat)
            # - U+266F: Music Sharp Sign (standard sharp)
            # - U+1D12B: Musical Symbol Double Flat
            # - U+1D12A: Musical Symbol Double Sharp
            print(f"  Importing accidental symbols from Noto Music...")
            symbols_imported = 0
            accidental_codepoints = [0x266D, 0x266F, 0x1D12B, 0x1D12A]
            for codepoint in accidental_codepoints:
                try:
                    glyph = noto_music_font[codepoint]
                    if glyph and glyph.glyphname:
                        new_glyph = font.createChar(codepoint, glyph.glyphname)
                        pen = new_glyph.glyphPen()
                        if pen:
                            glyph.draw(pen)
                            pen = None
                        if glyph.width:
                            new_glyph.width = glyph.width
                        symbols_imported += 1
                except:
                    pass
            print(f"  âœ“ Imported {symbols_imported} accidental symbols from Noto Music")
        except Exception as e:
            if strict_mode:
                raise RuntimeError(f"Failed to import Noto Music symbols: {e}")
            else:
                print(f"  WARNING: Could not import Noto Music: {e}")

    # Import symbols that explicitly specify Bravura as source
    bravura_font = None
    bravura_symbols = [s for s in spec.smufl_symbols if s.source_font == "bravura"]
    if bravura_symbols:
        if not bravura_path or not os.path.exists(bravura_path):
            msg = f"Bravura font required for {len(bravura_symbols)} symbols but not found: {bravura_path}"
            if strict_mode:
                raise RuntimeError(msg)
            else:
                print(f"  WARNING: {msg}")
        else:
            print(f"  Loading Bravura for {len(bravura_symbols)} symbols: {bravura_path}")
            try:
                bravura_font = fontforge.open(bravura_path)
                print(f"  âœ“ Bravura loaded")
                bravura_imported = 0
                for symbol in bravura_symbols:
                    try:
                        # Get glyph from Bravura
                        src_glyph = bravura_font[symbol.smufl_codepoint]
                        if src_glyph and src_glyph.glyphname:
                            # Create in target font
                            new_glyph = font.createChar(symbol.smufl_codepoint, src_glyph.glyphname)
                            # Copy the glyph data
                            pen = new_glyph.glyphPen()
                            if pen:
                                src_glyph.draw(pen)
                                pen = None
                            # Copy width
                            if src_glyph.width:
                                new_glyph.width = src_glyph.width
                            bravura_imported += 1
                            print(f"    âœ“ Imported {symbol.label} from Bravura")
                    except Exception as e:
                        msg = f"Failed to import {symbol.label} from Bravura: {e}"
                        if strict_mode:
                            raise RuntimeError(msg)
                        else:
                            print(f"    âœ— {msg}")
                print(f"  âœ“ Imported {bravura_imported}/{len(bravura_symbols)} glyphs from Bravura")
                bravura_font.close()
            except Exception as e:
                msg = f"Could not load Bravura: {e}"
                if strict_mode:
                    raise RuntimeError(msg)
                else:
                    print(f"  WARNING: {msg}")

    # Rename to NotationFont
    font.fontname = "NotationFont"
    font.fullname = "NotationFont"
    font.familyname = "NotationFont"

    # Get or create dot glyph
    dot_glyph = None
    dot_codepoint = ord('.')
    try:
        dot_glyph = font[dot_codepoint]
    except:
        pass

    # If no period glyph exists, create a synthetic one
    if not dot_glyph or not dot_glyph.glyphname:
        print(f"  Creating synthetic dot glyph...")
        try:
            dot_glyph = font.createChar(dot_codepoint, "period")
        except:
            try:
                dot_glyph = font[dot_codepoint]
            except:
                raise RuntimeError("ERROR: Could not create or find dot glyph")

        # Create a small circle/dot using bezier curves
        pen = dot_glyph.glyphPen()
        if pen:
            # Draw a small circle at origin (100 units radius, typical font units)
            # This is a crude implementation - just a square for simplicity
            size = 100
            pen.moveTo((0, 0))
            pen.lineTo((size, 0))
            pen.lineTo((size, size))
            pen.lineTo((0, size))
            pen.closePath()
            pen = None
        dot_glyph.width = size + 50  # Add some padding
        print(f"    Created synthetic dot")

    else:
        print(f"  Using existing dot glyph from Noto Music")

    dot_bbox = dot_glyph.boundingBox()
    if not dot_bbox:
        raise RuntimeError("ERROR: Could not get bounding box for dot glyph")

    dx_min, dy_min, dx_max, dy_max = dot_bbox
    dot_width = dx_max - dx_min
    dot_height = dy_max - dy_min
    dot_name = dot_glyph.glyphname

    print(f"  Dot glyph: {dot_name}, size: {dot_width}x{dot_height}")

    # Create half-flat accidental glyph (flat + diagonal slash)
    # IMPORTANT: The head must remain HOLLOW (not filled)
    # We copy the base flat symbol AS-IS (preserving its hollow head) and add only a slash
    print(f"\n  Creating half-flat accidental glyph...")
    halfflat_cp = 0xF8FF  # Temporary PUA codepoint for half-flat accidental
    halfflat_glyph = font.createChar(halfflat_cp, "halfflat_accidental")
    halfflat_glyph.clear()

    # Copy flat symbol outlines directly (preserves hollow head from Noto Music)
    try:
        flat_glyph = font[0x266D]
        if flat_glyph and flat_glyph.glyphname:
            # Copy flat glyph's outlines AS-IS using draw() method
            # This preserves BOTH the outer contour AND the inner contour (the hollow)
            # NO head filling occurs - the head remains hollow exactly as in the base flat
            pen = halfflat_glyph.glyphPen()
            flat_glyph.draw(pen)

            # Now add diagonal slash through the STEM ONLY (not the head)
            # This is the ONLY modification - we add a slash contour, nothing else
            # Traditional half-flat: hollow head (unchanged from base flat) + slash through vertical stem
            # From halfflat-accidental.svg: slash at x=110-190 (stem), y=100-600
            flat_bbox = flat_glyph.boundingBox()
            fx_min, fy_min, fx_max, fy_max = flat_bbox

            # The flat symbol structure:
            # - Left side: vertical stem (narrow)
            # - Right side: rounded head (wider, HOLLOW)
            # We position the slash ONLY on the stem (left ~20% of the glyph)
            # The head remains completely untouched

            stem_width = (fx_max - fx_min) * 0.25  # Stem is about 25% of total width

            # Position slash at 2/3 up the stem (like a diagonal crossbar through a "t")
            # The slash cuts through the stem at 2/3 height from bottom
            slash_center_y = fy_min + (fy_max - fy_min) * 0.67  # Center at 67% height (2/3 up)

            # Slash geometry (diagonal crossbar through stem, like "t")
            slash_stroke_width = 60  # Thickness of the slash stroke (thinner)
            slash_length = stem_width * 4.0  # Slash extends wider across the stem

            # Calculate diagonal slash endpoints (goes from left-low to right-high)
            # The slash tilts upward as it crosses the stem
            # IMPORTANT: The stem should be at the HALFWAY POINT of the slash
            slash_angle_rise = (fy_max - fy_min) * 0.15  # Diagonal rise over the slash length

            # Center the slash horizontally so the stem (at fx_min) is at the midpoint
            # Left edge of slash (lower) - extends to the left of stem
            slash_left_x = fx_min - slash_length / 2
            slash_left_y = slash_center_y - slash_angle_rise / 2

            # Right edge of slash (higher) - extends to the right of stem
            slash_right_x = fx_min + slash_length / 2
            slash_right_y = slash_center_y + slash_angle_rise / 2

            # Draw diagonal slash as a NEW closed contour (this is the only addition)
            # The slash cuts through the stem like a diagonal crossbar (like a "t")
            # Draw as a parallelogram with perpendicular thickness
            import math

            # Calculate perpendicular offset for stroke width
            # The slash goes diagonally, so we need perpendicular offset
            slash_dx = slash_right_x - slash_left_x
            slash_dy = slash_right_y - slash_left_y
            slash_dist = math.sqrt(slash_dx**2 + slash_dy**2)

            # Unit perpendicular vector (rotated 90 degrees)
            perp_x = -slash_dy / slash_dist
            perp_y = slash_dx / slash_dist

            # Half stroke width offset
            half_stroke = slash_stroke_width / 2
            offset_x = perp_x * half_stroke
            offset_y = perp_y * half_stroke

            # Four corners of the parallelogram
            # Bottom-left corner
            pen.moveTo((int(slash_left_x - offset_x), int(slash_left_y - offset_y)))
            # Bottom-right corner
            pen.lineTo((int(slash_right_x - offset_x), int(slash_right_y - offset_y)))
            # Top-right corner
            pen.lineTo((int(slash_right_x + offset_x), int(slash_right_y + offset_y)))
            # Top-left corner
            pen.lineTo((int(slash_left_x + offset_x), int(slash_left_y + offset_y)))
            pen.closePath()  # Close the slash contour only (does NOT affect the head)
            pen = None

            # Set width to match flat symbol
            halfflat_glyph.width = flat_glyph.width

            # Correct direction after drawing
            halfflat_glyph.correctDirection()
            print(f"  âœ“ Created half-flat accidental glyph at U+{halfflat_cp:04X}")
    except Exception as e:
        print(f"  âœ— Failed to create half-flat accidental: {e}")
        halfflat_glyph = None

    # Create note glyphs
    print(f"\n  Creating {len(layout.note_atoms)} note glyphs...")
    # Track target widths for glyphs with accidentals (to be set after unlinkRef())
    target_widths = {}
    for i, atom in enumerate(layout.note_atoms):
        # Choose source font: bold for pitch characters, regular for everything else
        is_pitch = atom.character in pitch_chars
        source_font = bold_font if (is_pitch and bold_font) else font

        try:
            base_glyph = source_font[ord(atom.character)]
        except Exception as e:
            font_type = "bold" if is_pitch else "regular"
            raise RuntimeError(f"Base character '{atom.character}' (U+{ord(atom.character):04X}) not found in {font_type} font: {e}")

        if not base_glyph:
            font_type = "bold" if is_pitch else "regular"
            raise RuntimeError(f"Base character '{atom.character}' (U+{ord(atom.character):04X}) is empty in {font_type} font")

        base_bbox = base_glyph.boundingBox()
        if not base_bbox:
            raise RuntimeError(f"Could not get bbox for '{atom.character}'")

        bx_min, by_min, bx_max, by_max = base_bbox
        base_width = bx_max - bx_min
        base_glyph_name = base_glyph.glyphname

        # Position dot horizontally (shifted left by 1/5 dot width for all variants)
        dot_x_offset = bx_min + (base_width - dot_width) / 2 - dx_min + (dot_width * 0.8)

        # Special adjustment for "2": shift dots left by 1/10 of character width
        if atom.character == "2":
            dot_x_offset -= base_width * 0.1

        # Special adjustment for "3", "5", "6": shift dots left by 17% of character width
        if atom.character in ["3", "5", "6"]:
            dot_x_offset -= base_width * 0.17

        # Special adjustment for "4": shift dots right by 4% of character width
        if atom.character == "4":
            dot_x_offset += base_width * 0.04

        # Special adjustment for "7": shift dots left by 4% of character width
        if atom.character == "7":
            dot_x_offset -= base_width * 0.04

        # Special adjustment for "S" (Sargam Sa): shift dots left by 1/10 of character width
        if atom.character == "S":
            dot_x_offset -= base_width * 0.1

        # Create composite glyph
        g = font.createChar(atom.assigned_codepoint, f"{atom.character}_v{atom.variant_index}")
        g.clear()

        # Reference the base glyph instead of copying outlines
        # This keeps font lightweight - browser only parses ~47 base glyphs, not 1175 copies
        g.addReference(base_glyph.glyphname)

        # NEW LAYOUT: variant_index (0-24) encodes (accidental_type Ã— 5) + octave_idx
        # accidental_types: [0=natural, 1=flat, 2=double-flat, 3=sharp, 4=double-sharp]
        # octave_idx: [0=base (octave 0), 1=octave -2, 2=octave -1, 3=octave +1, 4=octave +2]
        acc_type = atom.variant_index // 5
        octave_idx = atom.variant_index % 5

        # Add accidental symbol if not natural
        # CRITICAL: Must match assign_codepoints() acc_blocks ordering (lines 369-376)
        # acc_type from variant_index: 0=natural, 1=flat, 2=half-flat, 3=double-flat, 4=double-sharp, 5=sharp
        # EXCEPTION: Sargam komal/tivra notes (r, g, m, d, n, M) should NEVER get accidentals
        # In Sargam, case itself indicates pitch: r=komal Re, g=komal Ga, m=komal ma, d=komal Dha, n=komal Ni, M=tivra Ma
        SARGAM_NO_ACCIDENTALS = {'r', 'g', 'm', 'd', 'n', 'M'}
        if acc_type > 0 and atom.character not in SARGAM_NO_ACCIDENTALS:
            try:
                acc_glyph = None
                if acc_type == 1:  # Flat
                    acc_glyph = font[0x266D]
                elif acc_type == 2:  # Half-flat (use the half-flat accidental glyph we created)
                    acc_glyph = halfflat_glyph if halfflat_glyph else None
                elif acc_type == 3:  # Double-flat
                    acc_glyph = font[0x1D12B]
                elif acc_type == 4:  # Double-sharp
                    acc_glyph = font[0x1D12A]
                elif acc_type == 5:  # Sharp
                    acc_glyph = font[0x266F]

                if acc_glyph and acc_glyph.glyphname:
                    # Calculate y-offset (raise sharp and double-sharp symbols by 30% of font height)
                    y_offset = 0
                    if acc_type == 5 or acc_type == 4:  # Sharp or Double-sharp
                        char_height = by_max - by_min
                        y_offset = char_height * 0.3

                    # Position accidental to the right of the character (at bx_max where char ends)
                    g.addReference(acc_glyph.glyphname, (1, 0, 0, 1, bx_max, y_offset))

                    # Store the target width for later (will be set after unlinkRef())
                    # Width = where base ends + accidental advance width
                    target_width = int(bx_max + acc_glyph.width)
                    target_widths[atom.assigned_codepoint] = target_width
            except:
                pass  # Skip if accidental symbol not available

        # Add octave dots based on octave_idx
        # octave_idx maps to: [0â†’octave 0, 1â†’octave -2, 2â†’octave -1, 3â†’octave +1, 4â†’octave +2]
        if octave_idx == 0:
            # Base octave 0: no dots
            pass
        elif octave_idx == 1:  # Octave -2 (2 dots below)
            double_dot_scale = 0.6
            double_dot_spacing = 2 * dot_height * double_dot_scale
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos1 = by_min - dy_max - spec.geometry.dot_below_gap - dot_adjustment
            y_pos2 = y_pos1 - double_dot_spacing
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos1))
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos2))

        elif octave_idx == 2:  # Octave -1 (1 dot below)
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos = by_min - dy_max - spec.geometry.dot_below_gap - dot_adjustment
            g.addReference(dot_name, (1, 0, 0, 1, dot_x_offset, y_pos))

        elif octave_idx == 3:  # Octave +1 (1 dot above)
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos = by_max - dy_min + spec.geometry.dot_above_gap + dot_adjustment
            g.addReference(dot_name, (1, 0, 0, 1, dot_x_offset, y_pos))

        elif octave_idx == 4:  # Octave +2 (2 dots above)
            double_dot_scale = 0.6
            double_dot_spacing = 2 * dot_height * double_dot_scale
            char_height = by_max - by_min
            dot_adjustment = char_height * 0.05
            y_pos1 = by_max - dy_min + spec.geometry.dot_above_gap + dot_adjustment
            y_pos2 = y_pos1 + double_dot_spacing
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos1))
            g.addReference(dot_name, (double_dot_scale, 0, 0, double_dot_scale, dot_x_offset, y_pos2))

        # Use SAME width as base character (preserve original spacing behavior)
        # Octave variants should have identical horizontal behavior to their base characters
        g.width = base_glyph.width

        if (i + 1) % 50 == 0:
            print(f"    Created {i + 1}/{len(layout.note_atoms)} glyphs")

    # SMuFL symbols are already in Noto Music - no extraction needed!
    # Barlines (U+E030-E042), accidentals (U+E260-E264), ornaments (U+E566-E56E)
    # are all part of the standard font.
    print(f"\n  âœ“ SMuFL symbols already present in Noto Music base font")

    # DISABLED: Accidental composites (overlapping with Western system at 0xE200+)
    # The new architecture uses 25 variants per character (5 accidentals Ã— 5 octaves)
    # These legacy composites are not used and cause conflicts
    # if spec.accidental_composites:
    #     print(f"\n  Creating accidental composite glyphs...")
    #     create_accidental_composites(font, spec, layout, bold_font, pitch_chars)
    # else:
    #     print(f"\n  No accidental_composites configuration found - skipping composite glyph creation")
    print(f"\n  Skipping legacy accidental composites (conflicts with Western system PUA range)")

    # Correct direction for custom note glyphs
    print(f"\n  Finalizing {len(layout.note_atoms)} custom note glyphs...")

    # Correct direction for note atoms
    for atom in layout.note_atoms:
        g = font[atom.assigned_codepoint]
        if g:
            # CRITICAL: Unlink references first to convert them to actual outlines
            # References (accidentals, dots) won't export properly without this
            g.unlinkRef()
            g.correctDirection()

            # Set width AFTER unlinking (unlinkRef resets width to base glyph width)
            if atom.assigned_codepoint in target_widths:
                g.width = target_widths[atom.assigned_codepoint]

    print(f"  âœ“ Finalized {len(layout.note_atoms)} custom note variants")

    # Close bold font if it was opened (and it's not the same as base font)
    if bold_font and bold_font_path != base_font_path:
        try:
            bold_font.close()
            print(f"  âœ“ Closed bold font")
        except:
            pass

    return font


# ============================================================================
# Stage 4: Build Mapping JSON
# ============================================================================

def symbol_kind(glyph_name: str) -> str:
    """
    Classify symbol by glyph name prefix.

    Supports both old (uni*) and new (accidental*, barline*, ornament*, bracket*) naming.
    """
    if glyph_name.startswith("accidental") or glyph_name.startswith("uni266"):
        return "accidental"
    if glyph_name.startswith("barline") or glyph_name.startswith("uniE0"):
        return "barline"
    if glyph_name.startswith("bracket") or glyph_name.startswith("reversedBracket"):
        return "bracket"
    return "ornament"


def build_mapping_json(spec: AtomSpec, layout: CodepointLayout) -> dict:
    """
    Generate minimal runtime JSON mapping.

    Only includes what the editor needs:
        - notes: system, character, variants with codepoints
        - symbols: name, kind, label, codepoint

    Returns:
        dict conforming to SPEC.md schema
    """
    print(f"\n[STAGE 4] Building JSON mapping")

    # Build notes map
    notes_map = {}  # (system, char) -> entry
    for atom in layout.note_atoms:
        key = (atom.system, atom.character)
        if key not in notes_map:
            notes_map[key] = {
                "system": atom.system,
                "character": atom.character,
                "variants": {}
            }

        # Map variant index to name and octave shift
        # Variants 0-3: Natural octaves
        # Variants 4-19: Accidentals with octaves (4 variants each for sharp, flat, double-sharp, double-flat)
        # Variant 20: Base octave natural (no dots)
        variant_index = atom.variant_index

        if variant_index == 0:
            variant_name = "1_dot_above"
            octave_shift = 1
        elif variant_index == 1:
            variant_name = "2_dots_above"
            octave_shift = 2
        elif variant_index == 2:
            variant_name = "1_dot_below"
            octave_shift = -1
        elif variant_index == 3:
            variant_name = "2_dots_below"
            octave_shift = -2
        elif variant_index == 20:
            variant_name = "base_octave"
            octave_shift = 0
        else:
            # Variants 4-19: Accidentals with octaves
            # For now, just generate generic names for these
            variant_name = f"variant_{variant_index}"
            octave_shift = 0  # These are handled differently

        notes_map[key]["variants"][variant_name] = {
            "codepoint": hex(atom.assigned_codepoint),
            "octave_shift": octave_shift
        }

    notes_list = list(notes_map.values())

    # Build symbols map (filter out old accidentals E260-E264 - now part of per-system PUA)
    # The new architecture includes accidentals within each system's PUA block
    old_accidental_range = range(0xE260, 0xE265)  # E260-E264
    symbols_list = [
        {
            "name": symbol.glyph_name,
            "kind": symbol_kind(symbol.glyph_name),
            "label": symbol.label,
            "codepoint": hex(symbol.assigned_codepoint),
        }
        for symbol in layout.symbols
        if symbol.assigned_codepoint not in old_accidental_range
    ]

    mapping = {
        "version": "1.0",
        "generated_from": "atoms.yaml",
        "pua_allocation": {
            "notes_start": hex(layout.notes_range[0]),
            "notes_end": hex(layout.notes_range[1]),
            "symbols_start": hex(layout.symbols_range[0]),
            "symbols_end": hex(layout.symbols_range[1]),
        },
        "notes": notes_list,
        "symbols": symbols_list,
        "summary": {
            "total_notes": len(notes_list),
            "total_symbols": len(symbols_list),
            "systems": {
                name: {
                    "count": len(chars),
                    "chars": ''.join(chars)
                }
                for name, chars in spec.notation_systems.items()
            }
        }
    }

    print(f"  âœ“ Notes: {len(notes_list)}")
    print(f"  âœ“ Symbols: {len(symbols_list)}")

    return mapping


# ============================================================================
# Stage 5: Validate Layout
# ============================================================================

def validate_layout(layout: CodepointLayout):
    """
    Pre-flight checks before font generation.

    Assertions:
        1. All atoms have codepoints assigned
        2. No duplicate codepoints within category (notes or symbols)
        3. All codepoints in valid PUA range
        4. No range overlap between categories
    """
    print(f"\n[STAGE 5] Validating layout")

    # Check all assigned
    all_atoms = layout.note_atoms + layout.symbols
    for i, atom in enumerate(all_atoms):
        if atom.assigned_codepoint is None:
            raise ValueError(f"Atom {i} not assigned a codepoint!")

    # Check no duplicates WITHIN note atoms
    note_codepoints = [atom.assigned_codepoint for atom in layout.note_atoms]
    if len(note_codepoints) != len(set(note_codepoints)):
        duplicates = [cp for cp in note_codepoints if note_codepoints.count(cp) > 1]
        raise ValueError(f"Duplicate codepoints in note atoms: {[hex(cp) for cp in set(duplicates)]}")

    # Check no duplicates WITHIN symbols
    symbol_codepoints = [atom.assigned_codepoint for atom in layout.symbols]
    if len(symbol_codepoints) != len(set(symbol_codepoints)):
        duplicates = [cp for cp in symbol_codepoints if symbol_codepoints.count(cp) > 1]
        raise ValueError(f"Duplicate codepoints in symbols: {[hex(cp) for cp in set(duplicates)]}")

    # Check codepoint ranges
    # Valid ranges:
    # - Note atoms: PUA 0xE100 - 0xE617 (per-system architecture)
    # - Symbols: Unicode Music 0x1D100-0x1D1FF OR SMuFL PUA 0xE000-0xF8FF
    for atom in all_atoms:
        valid = (
            (0xE000 <= atom.assigned_codepoint <= 0xF8FF) or  # PUA (SMuFL + per-system blocks)
            (0x1D100 <= atom.assigned_codepoint <= 0x1D1FF)    # Unicode Music
        )
        if not valid:
            raise ValueError(
                f"Codepoint {hex(atom.assigned_codepoint)} outside valid ranges "
                f"(PUA 0xE000-0xF8FF or Unicode Music 0x1D100-0x1D1FF)!"
            )

    print(f"  âœ“ All {len(all_atoms)} atoms have valid, unique codepoints")
    print(f"  âœ“ Note atoms: {hex(layout.notes_range[0])} - {hex(layout.notes_range[1])}")
    print(f"  âœ“ Symbols: {hex(layout.symbols_range[0])} - {hex(layout.symbols_range[1])}")


# ============================================================================
# Debug Output
# ============================================================================

def write_debug_html(output_path: str, spec: AtomSpec, layout: CodepointLayout):
    """Generate debug specimen HTML"""
    print(f"\n[DEBUG] Writing specimen HTML: {output_path}")

    html_content = """<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>NotationFont Debug Specimen</title>
    <style>
        @font-face {
            font-family: 'NotationFont';
            src: url('./NotationFont.ttf') format('truetype');
        }
        body {
            font-family: 'NotationFont', monospace;
            font-size: 32px;
            line-height: 2;
            background: #fafafa;
            padding: 20px;
        }
        h1 { font-family: sans-serif; }
        h2 { font-family: sans-serif; margin-top: 1em; }
        .system { margin: 2em 0; }
        .char-row { margin: 0.5em 0; padding: 0.5em; background: white; border: 1px solid #ddd; }
        .label { font-family: sans-serif; font-size: 14px; color: #666; }
        .glyph { margin: 0 0.3em; }
    </style>
</head>
<body>
    <h1>NotationFont Debug Specimen</h1>
    <p class="label">Generated: v1.0 | Total glyphs: """ + str(len(layout.note_atoms) + len(layout.symbols)) + """</p>
"""

    # Add systems
    for system_name, characters in spec.notation_systems.items():
        html_content += f"    <div class='system'>\n"
        html_content += f"        <h2>{system_name.capitalize()} System ({len(characters)} chars Ã— 4 variants)</h2>\n"
        for char in characters:
            # Find atoms for this character
            atoms = [a for a in layout.note_atoms if a.character == char and a.system == system_name]
            if atoms:
                atom_0 = atoms[0]
                html_content += f"        <div class='char-row'>\n"
                html_content += f"            <span class='label'>{char}:</span>\n"
                html_content += f"            <span class='glyph'>{char}</span>\n"  # Base
                for i in range(4):
                    atom = [a for a in atoms if a.variant_index == i]
                    if atom:
                        cp = atom[0].assigned_codepoint
                        html_content += f"            <span class='glyph'>{chr(cp)}</span>\n"
                html_content += f"        </div>\n"
        html_content += f"    </div>\n"

    # Add symbols
    html_content += f"""    <div class='system'>
        <h2>Symbols ({len(layout.symbols)} glyphs)</h2>
"""
    for symbol in layout.symbols:
        html_content += f"        <div class='char-row'>\n"
        html_content += f"            <span class='label'>{symbol.label}:</span>\n"
        html_content += f"            <span class='glyph'>{chr(symbol.assigned_codepoint)}</span>\n"
        html_content += f"        </div>\n"

    html_content += """    </div>
</body>
</html>
"""

    with open(output_path, 'w') as f:
        f.write(html_content)

    print(f"  âœ“ Specimen HTML written")


# ============================================================================
# Main
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Notation Font Generator v6+ (SPEC.md-compliant)"
    )

    parser.add_argument(
        "--base-font",
        default="tools/fontgen/sources/NotoSans-Regular.ttf",
        help="Path to base text font (default: Noto Sans Regular)"
    )
    parser.add_argument(
        "--bold-font",
        default="tools/fontgen/sources/NotoSans-Bold.ttf",
        help="Path to bold text font for pitch characters (default: Noto Sans Bold)"
    )
    parser.add_argument(
        "--noto-music-font",
        default="tools/fontgen/sources/NotoMusic.ttf",
        help="Path to Noto Music font for SMuFL symbols (default: tools/fontgen/sources/NotoMusic.ttf)"
    )
    parser.add_argument(
        "--bravura-font",
        default="tools/fontgen/base_fonts/Bravura.otf",
        help="Path to Bravura font for fallback SMuFL symbols (default: tools/fontgen/base_fonts/Bravura.otf)"
    )
    parser.add_argument(
        "--atoms",
        default="build/atoms.yaml",
        help="Path to atoms.yaml (default: build/atoms.yaml)"
    )
    parser.add_argument(
        "--fontspec",
        default="tools/fontgen/fontspec.json",
        help="Path to fontspec.json (default: tools/fontgen/fontspec.json)"
    )
    parser.add_argument(
        "--output-dir",
        default="dist/fonts",
        help="Output directory (default: dist/fonts)"
    )
    parser.add_argument(
        "--strict",
        action="store_true",
        help="Fail on any errors (requires Noto Music)"
    )
    parser.add_argument(
        "--validate-only",
        action="store_true",
        help="Validate YAML only (no FontForge needed)"
    )
    parser.add_argument(
        "--debug-html",
        action="store_true",
        help="Generate debug specimen HTML"
    )
    parser.add_argument(
        "--system",
        choices=["number", "western", "sargam", "doremi", "all"],
        default="all",
        help="Generate font for specific notation system (default: all)"
    )

    args = parser.parse_args()

    # Always generate a single font containing all systems
    generate_font_for_system(args)


def generate_font_for_system(args):
    """Generate font for a specific system"""

    # Resolve paths from repo root
    script_dir = os.path.dirname(os.path.abspath(__file__))
    repo_root = os.path.dirname(os.path.dirname(script_dir))  # tools/fontgen -> editor

    atoms_path = os.path.join(repo_root, args.atoms)
    fontspec_path = os.path.join(repo_root, args.fontspec)
    base_font_path = os.path.join(repo_root, args.base_font)
    bold_font_path = os.path.join(repo_root, args.bold_font)
    noto_music_path = os.path.join(repo_root, args.noto_music_font)
    bravura_path = os.path.join(repo_root, args.bravura_font)
    output_dir = os.path.join(repo_root, args.output_dir)

    # Always generate single unified font
    font_basename = "NotationFont"

    output_font = os.path.join(output_dir, f"{font_basename}.ttf")
    output_mapping = os.path.join(output_dir, f"{font_basename}-map.json")
    output_html = os.path.join(output_dir, f"debug-specimen.html")

    print("=" * 70)
    print("NOTATION FONT GENERATOR (Noto Sans + Noto Music + Bravura)")
    print("=" * 70)
    print(f"\nConfiguration:")
    print(f"  fontspec.json:      {fontspec_path}")
    print(f"  atoms.yaml:         {atoms_path}")
    print(f"  base font (Noto Sans): {base_font_path}")
    print(f"  bold font (Noto Sans Bold): {bold_font_path}")
    print(f"  music symbols (Noto Music):  {noto_music_path}")
    print(f"  fallback symbols (Bravura):  {bravura_path}")
    print(f"  output dir:         {output_dir}")
    print(f"  mode:               {'STRICT' if args.strict else 'DEV'}")
    print()

    # Stage 0: Load fontspec (from Rust)
    try:
        fontspec = load_fontspec_json(fontspec_path)
    except Exception as e:
        print(f"\nERROR: Failed to load fontspec.json: {e}")
        print("  Make sure you ran 'cargo build' first to generate fontspec.json")
        sys.exit(1)

    # Stage 1: Load atom spec
    try:
        spec = load_atom_spec(atoms_path, fontspec, args.system)
    except Exception as e:
        print(f"\nERROR: Failed to load atoms.yaml: {e}")
        sys.exit(1)

    # Stage 2: Assign codepoints
    try:
        layout = assign_codepoints(spec)
    except Exception as e:
        print(f"\nERROR: Codepoint assignment failed: {e}")
        sys.exit(1)

    # Stage 5: Validate
    try:
        validate_layout(layout)
    except Exception as e:
        print(f"\nERROR: Layout validation failed: {e}")
        sys.exit(1)

    # Early exit for validate-only
    if args.validate_only:
        print("\n" + "=" * 70)
        print("VALIDATION PASSED (no font generated)")
        print("=" * 70)
        return 0

    # Stage 4: Build mapping JSON
    try:
        mapping = build_mapping_json(spec, layout)
    except Exception as e:
        print(f"\nERROR: JSON mapping failed: {e}")
        sys.exit(1)

    # Stage 3: Build font (requires FontForge)
    if not fontforge:
        print("\nERROR: FontForge not available")
        print("Install with: pip install fontforge")
        sys.exit(1)

    try:
        os.makedirs(output_dir, exist_ok=True)
        font = build_font(base_font_path, bold_font_path, noto_music_path, spec, layout, args.strict, bravura_path)
        font.generate(output_font)
        print(f"\n  âœ“ Font saved: {output_font}")

        # Generate WOFF2 for web optimization
        output_woff2 = output_font.replace('.ttf', '.woff2')
        import subprocess
        try:
            subprocess.run(['woff2_compress', output_font], check=True, capture_output=True)
            print(f"  âœ“ WOFF2 saved: {output_woff2}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"  âš  WOFF2 generation skipped (woff2_compress not available)")
    except Exception as e:
        print(f"\nERROR: Font generation failed: {e}")
        sys.exit(1)

    # Write JSON mapping
    try:
        with open(output_mapping, 'w') as f:
            json.dump(mapping, f, indent=2)
        print(f"  âœ“ JSON mapping saved: {output_mapping}")
    except Exception as e:
        print(f"\nERROR: Failed to write JSON mapping: {e}")
        sys.exit(1)

    # Write debug HTML
    if args.debug_html:
        try:
            write_debug_html(output_html, spec, layout)
        except Exception as e:
            print(f"\nWARNING: Failed to write debug HTML: {e}")

    print("\n" + "=" * 70)
    print("SUCCESS!")
    print("=" * 70)
    print(f"\nGenerated unified font containing all systems (Number, Western, Sargam, Doremi):")
    print(f"  âœ“ {output_font}")
    output_woff2 = output_font.replace('.ttf', '.woff2')
    if os.path.exists(output_woff2):
        print(f"  âœ“ {output_woff2}")
    print(f"  âœ“ {output_mapping}")
    if args.debug_html:
        print(f"  âœ“ {output_html}")

    print(f"\nNext steps:")
    print(f"  1. Verify font renders in browser")
    print(f"  2. Check all notation systems work correctly")
    print(f"  3. Commit JSON mapping to repo")
    print(f"  4. Deploy to production")

    return 0


if __name__ == "__main__":
    sys.exit(main())
